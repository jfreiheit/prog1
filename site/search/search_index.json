{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Programmieren I \u00b6 Herzlich willkommen zur Programmieren I Veranstaltung! Wir werden unter Verwendung der Programmiersprache die wesentlichen Konzepte lernen, die f\u00fcr das Verst\u00e4ndnis mordenen Programmierens notwendig sind. Es sind keinerlei Vorkenntnisse erforderlich. Hier einige Tipps, damit Sie die Veranstaltung erfolgreich durchf\u00fchren und Sie dabei auch Spa\u00df haben: L\u00f6sen Sie alle \u00dcbungsaufgaben selbst\u00e4ndig! Es ist kein Problem, wenn Sie f\u00fcr das Bew\u00e4ltigen der \u00dcbungen etwas l\u00e4nger ben\u00f6tigen. Sollten Sie es gar nicht alleine schaffen, ist das auch kein Problem. Wichtig ist dann, dass Sie sich die L\u00f6sung anschauen und es erneut selbst\u00e4ndig versuchen. H\u00f6ren Sie nicht auf, bis Sie es geschafft haben! Sie k\u00f6nnen die Hausaufgaben zu zweit l\u00f6sen. Achten Sie aber darauf, dass Sie Ihre gemeinsame L\u00f6sung vollst\u00e4ndig verstanden haben und dass Sie sie danach auch alleine erstellen k\u00f6nnen. Sie k\u00f6nnen beim L\u00f6sen der Hausaufgaben beliebig kreativ sein! Die Aufgabenstellung gibt Ihnen Anhaltspunkte f\u00fcr eine eventuelle L\u00f6sung. Sie k\u00f6nnen es aber auch ganz anders machen! Die Klausurvorbereitung beginnt mit Beginn der Veranstaltung. Es ist nicht m\u00f6glich, die Klausur am Ende des Semesters zu bestehen, wenn Sie nicht das ganze Semester \u00fcber intensiv programmieren. Die \u00dcbungsaufgaben sind \"kleine\" Aufgaben, um das in der Vorlesung vermittelte Wissen direkt anzuwenden. F\u00fcr die L\u00f6sung der Hausaufgaben ist bereits ein gewisses Abstraktionsniveau erforderlich, um zu erkennen, dass das in der Vorlesung vermittelte Wissen daf\u00fcr ausreichend ist. Programmieren lernt man nur durch Programmieren. Sie m\u00fcssen es tun. Das Lesen von B\u00fcchern oder das \"Anschauen\" von Code gen\u00fcgt nicht. Eine Sprache lernt man auch nur durch Sprechen. Sie m\u00fcssen programmieren, programmieren, prohgrammieren... Lassen Sie sich durch Fehler nicht verunsichern, sondern analysieren Sie Ihre Fehler. Bis zur Klausur sollten Sie alle Fehler einmal gemacht haben. Wenn Sie sich \u00fcberlegen, warum das jeweils ein Fehler war, dann werden Sie diesen Fehler nicht wiederholen und haben durch die Reflektion eine Menge gelernt. Fehler zu machen (und dar\u00fcber zu reflektieren) geh\u00f6rt zu den besten Lernmethoden des Programmierens. Haben Sie Spa\u00df! Je mehr Sie das Programmieren lernen, je mehr Spa\u00df werden Sie haben. Wir versuchen, dass Sie das genaze Semester \u00fcber Spa\u00df am Programmieren haben werden. Sollte es Ihnen zwischendurch keinen Spa\u00df mehr machen, geben Sie mir sofort Bescheid! Viel Erfolg! Und viel Spa\u00df! Organisatorisches \u00b6 Der (Corona-)Plan zur Durchf\u00fchrung der Veranstaltung ist derzeit wie folgt: Themen werden ausf\u00fchrlich in diesem Skript beschrieben und anhand von Videos verdeutlicht das Skript und die Videos werden (sp\u00e4testens) freitags hochgeladen (gilt dann f\u00fcr die gesamte Woche - also Freitag + Dienstag) das hei\u00dft, \"Vorlesungen\" finden asynchron statt (im Selbststudium) zusammen mit dem Skript und den Videos werden sowohl die \u00dcbung als auch die Aufgabe hochgeladen die \u00dcbung (und die vergangene Aufgabe) werden dienstags (12.15 Uhr) und mittwochs (9:45 Uhr) besprochen (Sie k\u00f6nnen frei w\u00e4hlen, welche der beiden \u00dcbungen Sie w\u00e4hlen) bei Bedarf k\u00f6nnen wir auch gerne eine Synchron-Video-Vorlesung einschieben, um Fragen zu erkl\u00e4ren sollten Sie W\u00fcnsche haben, diesen Plan zu \u00e4ndern, kommen Sie gerne auf mich zu Zur erfolgreichen Durchf\u00fchrung der Veranstaltung m\u00fcssen die Aufgaben l\u00f6sen und zu den jeweiligen Fristen auf Moodle hochladen. Wenn Sie alle Aufgaben fristgerecht hochgeladen haben, d\u00fcrfen Sie an der Klausur teilnehmen. Es werden insgesamt wahrscheinlich 9 Aufgaben sein, die Sie selbst\u00e4ndig l\u00f6sen und hochladen m\u00fcssen. Sie k\u00f6nnen die Aufgaben auch zu zweit l\u00f6sen. Laden Sie dann aber bitte beide jeweils die L\u00f6sung hoch. Am Ende des Semesters schreiben wir eine Klausur (am Rechner). Diese Klausur wird bewertet und entspricht der Note f\u00fcr \"Programmieren 1\". Unter Aufgaben sind die Aufgaben beschrieben, die Sie in jeder Woche ausf\u00fchren sollen. Damit Sie dies erfolgreich erledigen k\u00f6nnen, ist jeweils angegeben, welche Themen Sie daf\u00fcr durcharbeiten m\u00fcssen. Das Durcharbeiten der jeweiligen Themen entspricht jeweils einer Vorlesung. Diese wird also selbst\u00e4ndig durchgef\u00fchrt. Daneben gibt es jede Woche (zu jedem Thema) \u00dcbungen , die wir in den \u00dcbungszeiten besprechen. Diese dienen der Anwendung und der Festigung der erlangten Kenntnisse. Die \u00dcbungen sind kleine Aufgaben, an denen Sie das neue Wissen anwenden sollen. Die \u00dcbungen dienen der Bef\u00e4higung, die (gr\u00f6\u00dferen) Aufgaben l\u00f6sen zu k\u00f6nnen. F\u00fcr die Kommunikation untereinander verwenden wir Slack . Dort k\u00f6nnen Sie alle inhaltlichen und organisatorischen Fragen stellen. Ich f\u00e4nde es gut, wenn ich dort m\u00f6glichst wenig Fragen - zumindest die inhaltlichen - beantworten m\u00fcsste, sondern eine Art internes Diskussionsforum entsteht. Es ist sehr gew\u00fcnscht, dort Fragen zu stellen und noch mehr gew\u00fcnscht, diese von Ihnen dort beantwortet zu sehen. Damit w\u00e4re allen geholfen und ich kann besser erkennen, wo noch Nachhol- bzw. Erl\u00e4uterungsbedarf bei den meisten besteht. Planung (vorl\u00e4ufig - kann sich noch \u00e4ndern) \u00b6 Nachfolgend der vorl\u00e4ufige Wochenplan (wird eventuell angepasst). Die Vorlesungsvideos finden Sie darunter f\u00fcr die einzelnen Wochen (unter Themen ). Woche Themen (Vorlesung) Aufgabe Abgabe Aufgabe bis 1. 02.-06.11.2020 Einf\u00fchrung und Organisatorisches, erstes Programm - - 2. 09.-13.11.2020 Datentypen und Variablen, logische Ausdr\u00fccke Aufgabe 1 22.11.2020 3. 16.-20.11.2020 Sequenzen, Iterationen und Selektion Aufgabe 2 29.11.2020 4. 23.-27.11.2020 N\u00fctzliche Klassen, Einf\u00fchrung Arrays Aufgabe 3 06.12.2020 5. 30.-04.12.2020 Sortieren von Arrays Aufgabe 4 13.12.2020 6. 07.-11.12.2020 Klassen und Objekte Aufgabe 5 20.12.2020 7. 14.-18.12.2020 Getter, Setter, Konstruktoren, this, private Aufgabe 6 10.01.2021 8. 21.-25.12.2020 Klassen- und Objekt-Variablen und -Methoden Aufgabe 7 17.01.2021 9. 04.-08.01.2021 Vererbung Aufgabe 8 24.01.2021 10. 11.-15.01.2021 Polymorphie Aufgabe 9 31.01.2021 11. 18.-22.01.2021 Object - - 12. 25.-29.01.2021 Sichtbarkeitsmodifizierer Fragen - 13. 01.-05.02.2021 Wiederholung, Klausurvorbereitung - Themen \u00b6 Hier sind die Themen in chronologischer Folge aufgef\u00fchrt, wie wir sie auch in den Vorlesungen behandeln. Durch interne Links werden Bez\u00fcge innerhalb der Themen hergestellt. Sie k\u00f6nnen die Themen in dieser Folge abarbeiten, k\u00f6nnen aber auch beliebig hin- und herspringen. Zu jeden Themen gibt es \u00dcbungsaufgaben. Diese sind ebenfalls verlinkt. Sollten Sie zu einzelnen Themen das Gef\u00fchl haben, dass diese nicht ausf\u00fchrlich genug beschrieben sind, geben Sie mir bitte Bescheid. Ziel ist, dass dieses \"Skript\" Ihnen die Einf\u00fchrung in das Programmieren vollst\u00e4ndig erm\u00f6glicht. Das hei\u00dft nicht, dass Sie nicht weitere Literatur verwenden sollen. Einen \u00dcberblick \u00fcber geeignete Literatur finden Sie hier . 03.11.2020 - Einf\u00fchrung und Organisatorisches siehe \u00dcbung 0 Zoom-Meeting (sorry, leider zu sp\u00e4t auf Aufnahme gedr\u00fcckt - vergessen, aber es steht alles hier oben) MyFirstClass.java package uebungen.uebung0 ; /** * * @author jornfreiheit * */ public class MyFirstClass { public static void main ( String [] args ) { System . out . println ( \"Hallo FIW!\" ); System . out . println (); // das ist eine Leerzeile System . out . println ( \"Wir programmieren!!!\" ); System . out . println ( \"Hurra!!!\" ); /* * * das ist ein Block-Kommentar * kann \u00fcber mehrere Zeilen gehen */ } } 06.11. + 10.11.2020 - Variablen, Datentypen, Methoden, Selektion siehe \u00dcbung 1 Variablen (siehe Skript Variablen ) Variablen.java package themen.variablen ; public class Variablen { public static void main ( String [] args ) { System . out . println ( \"Thema heute: Variablen\" ); System . out . println ( \"Im Skript unter http://freiheit.f4.htw-berlin.de/prog1/variablen/\" ); System . out . println (); /* * Erzeugen einer Variable: \"Deklarieren der Variable\" * datentyp variablenName; * * Datentypen??? * * ganzzahlige Datentypen: int, long, short, byte */ int ganzeZahl ; // Variable ganzeZahl erzeugt (1x)! int nochEineGanzeZahl = 0 ; // Deklaration und Wertzuweisung (Initialisierung) long grosseGanzeZahl = 123456789L ; // int 32 bit , aber long 64 bit short kleinereGanzeZahl = 123 ; // 16 bit byte ganzKleineGanzeZahl = 127 ; // 8 bit /* * Datentypen, um Gleitkommazahlen zu speichern * double, float */ double number1 = 6.789 ; // 64 bit float number2 = 5.0f ; // 32 bit /* * Datentyp, um ein Zeichen (character) zu speichern * char */ char zeichen = 'a' ; char zeichen1 = 97 ; char zeichen2 = '\\u00a9' ; /* * Datentyp, um Wahrheitswerte zu speichern * boolean */ boolean condition = true ; boolean condition1 = false ; /* * Wertzuweisung * Wertzuweisungsoperator = * variablenName = wert; */ ganzeZahl = 7 ; // Wertzuweisung beliebig oft System . out . println ( ganzeZahl ); ganzeZahl = - 123 ; System . out . println ( ganzeZahl ); System . out . println ( grosseGanzeZahl ); System . out . println ( ganzKleineGanzeZahl ); System . out . println ( number1 ); System . out . println ( number2 ); System . out . println ( zeichen ); System . out . println ( zeichen1 ); System . out . println ( zeichen2 ); System . out . println ( condition ); System . out . println ( condition1 ); /* * bis hier her Wertetypen * jetzt noch ein Datentyp * String * (Referenztyp) * */ String zeichenkette = \"Hallo\" ; System . out . println ( zeichenkette ); } } Ausdr\u00fccke und Operatoren (siehe Skript Ausdr\u00fccke und Operatoren ) Ausdruecke.java package themen.ausdruecke ; public class Ausdruecke { public static void main ( String [] args ) { System . out . println ( \"Thema heute: Ausdruecke\" ); System . out . println ( \"Im Skript unter http://freiheit.f4.htw-berlin.de/prog1/ausdruecke/#operatoren-und-ausdrucke\" ); System . out . println (); int a = 8 ; int b = 2 ; int c = 0 ; c = a + b ; System . out . println ( c ); a = a + b ; System . out . println ( a ); a = a * b ; System . out . println ( a ); a = a / b ; System . out . println ( a ); a = a - b ; System . out . println ( a ); a = 7 ; a = a / b ; // 7 / 2 --> ganzzahlige Division! System . out . println ( a ); // a ist 3 a = 7 ; a = a % b ; // Restwertoperator (modulo) System . out . println ( a ); double x = 8.2 ; double y = 2.3 ; x = x + y ; System . out . println ( x ); x = x * y ; System . out . println ( x ); x = x - y ; System . out . println ( x ); x = 7.0 ; y = 2.0 ; x = x / y ; // 7.0 / 2.0 --> Gleitkomma-Division! System . out . println ( x ); // a ist 3.5 x = 7.0 ; x = x % y ; System . out . println ( x ); a ++ ; // a = a + 1; System . out . println ( a ); ++ a ; // a = a + 1; System . out . println ( a ); b = 0 ; a = 2 ; b = ++ a ; System . out . println ( b ); System . out . println ( a ); b = a ++ ; System . out . println ( b ); System . out . println ( a ); a -- ; // a = a - 1; -- a ; // a = a - 1; a = 5 ; a += 4 ; // a = a + 4; a *= 3 ; // a = a * 3; a /= 4 ; // a = a / 4; a -= 3 ; // a = a - 3; a %= 2 ; // a = a % 2; double d = 5.0 ; int e = 2 ; System . out . println ( d / e ); // Gleitkommadivision System . out . println ( e / d ); // Gleitkommadivision System . out . println ( 7 == 2 ); // Gleichheit --> Ergebnis ist boolean System . out . println ( 7 == 7 ); // Gleichheit --> Ergebnis ist boolean System . out . println ( 7 != 2 ); // Ungleichheit --> Ergebnis ist boolean System . out . println ( 7 != 7 ); // Ungleichheit --> Ergebnis ist boolean System . out . println ( 7 > 2 ); // groesser als --> Ergebnis ist boolean System . out . println ( 7 > 7 ); // groesser als --> Ergebnis ist boolean System . out . println ( 7 < 2 ); // kleiner als --> Ergebnis ist boolean System . out . println ( 7 < 7 ); // kleiner als --> Ergebnis ist boolean System . out . println ( 7 <= 2 ); // kleiner gleich --> Ergebnis ist boolean System . out . println ( 7 <= 7 ); // kleiner gleich --> Ergebnis ist boolean System . out . println ( 7 >= 2 ); // groesser gleich --> Ergebnis ist boolean System . out . println ( 7 >= 7 ); // groesser gleich --> Ergebnis ist boolean boolean check = 7 != 2 ; System . out . println ( check ); boolean b1 = true ; boolean b2 = false ; System . out . println ( \" -------- Negation ---------- \" ); System . out . println ( b1 ); b1 = ! b1 ; // Negation b2 = ! b2 ; // Negation System . out . println ( b1 ); System . out . println ( b2 ); System . out . println ( \" -------- logisches UND ---------- \" ); System . out . println ( false && true ); // false UND true --> false System . out . println ( true && true ); // true UND true --> true System . out . println ( true && false ); // true UND false --> false System . out . println ( false && false ); // false UND false --> false System . out . println ( \" -------- logisches ODER ---------- \" ); System . out . println ( false || true ); // false ODER true --> true System . out . println ( true || true ); // true ODER true --> true System . out . println ( true || false ); // true ODER false --> true System . out . println ( false || false ); // false ODER false --> false System . out . println ( \" -------- logisches EXCLUSIVES ODER ---------- \" ); System . out . println ( false ^ true ); // false EXCL. ODER true --> true System . out . println ( true ^ true ); // true EXCL. ODER true --> false System . out . println ( true ^ false ); // true EXCL. ODER false --> true System . out . println ( false ^ false ); // false EXCL. ODER false --> false System . out . println ( \" -------- String-Verkettung ---------- \" ); String s1 = \"Hallo \" ; String s2 = \"FIW!\" ; System . out . println ( s1 + s2 ); // Verkettung von Strings (Konkatenation) s1 = s1 + s2 ; // \"Hallo FIW!\" System . out . println ( s1 ); int z1 = 22 ; int z2 = 11 ; int result = z1 / z2 ; System . out . println ( \"das Resultat ist : \" + result ); // Konkatenation System . out . println ( z1 + \" / \" + z2 + \" = \" + result ); System . out . println ( 3 + \" + \" + 4 + \" = \" + 3 + 4 ); // warum? System . out . println ( 3 + \" + \" + 4 + \" = \" + ( 3 + 4 )); // warum? } } Methoden (siehe Skript Methoden ) Methoden.java package themen.methoden ; public class Methoden { public static void add ( int summand1 , int summand2 ) { int summe = summand1 + summand2 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summe ); } public static void divide ( int divident , int divisor ) { int quotient = divident / divisor ; int rest = divident % divisor ; System . out . println ( divident + \" / \" + divisor + \" = \" + quotient + \" mit dem Rest \" + rest ); } public static int computeSum ( int summand1 , int summand2 ) { int summe = summand1 + summand2 ; return summe ; } public static boolean greaterThanZero ( int number ) { return ( number > 0 ); } public static void main ( String [] args ) { System . out . println ( \"Thema heute: Methoden\" ); System . out . println ( \"Im Skript unter http://freiheit.f4.htw-berlin.de/prog1/methoden/#methoden\" ); System . out . println (); /* int summand1 = 3; int summand2 = 4; int summe = summand1 + summand2; System.out.println(summand1 + \" + \" + summand2 + \" = \" + summe); summand1 = 5; summand2 = 9; summe = summand1 + summand2; System.out.println(summand1 + \" + \" + summand2 + \" = \" + summe); summand1 = -115; summand2 = 999; summe = summand1 + summand2; System.out.println(summand1 + \" + \" + summand2 + \" = \" + summe); */ add ( 3 , 4 ); add ( 5 , 9 ); add ( - 115 , 999 ); divide ( 17 , 12 ); divide ( 12 , 4 ); int sum = computeSum ( 3 , 4 ); System . out . println ( sum ); System . out . println ( computeSum ( 5 , 9 )); System . out . println ( greaterThanZero ( - 7 )); } } Selektion (siehe Skript Selektion ) 13.11. + 17.11.2020 - Iteration (Schleifen), Methodenstack, Sichtbarkeit und Lebensdauer von Variablen siehe Aufgabe 1 siehe \u00dcbung 2 Iteration (siehe Skript Iteration ) Schleifen.java aus dem Video 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 package themen.iteration ; public class Schleifen { /* * verschachtelte Schleife * innere Schleife wird immer vollstaendig ausgefuehrt (j von 0 bis 6) * erst dann wieder i erhoehen --> dann wieder innere Schleife vollstaendig ausfuehren */ public static void printSchleifeInSchleife () { for ( int i = 0 ; i < 8 ; i ++ ) { System . out . println ( \"i : \" + i + \" ----------\" ); for ( int j = 0 ; j < 7 ; j ++ ) { System . out . println ( \"j : \" + j ); } } } /* * width gibt Anzahl der Sterne an, die wir in einer Zeile ausgeben * height gibt an, wieviele Zeilen wir ausgeben */ public static void printRectangle ( int width , int height ) { for ( int row = 0 ; row < height ; row ++ ) { for ( int stars = 0 ; stars < width ; stars ++ ) { System . out . print ( \"*\" ); } System . out . println (); } } /* * es wird eine Folge von Zahlen berechnet * die Folge stoppt, wenn die Zahl den Wert 1 hat * ist die Zahl gerade, wird der Nachfolger berechnet, * indem die Zahl durch 2 geteilt wird * ist die Zahl ungerade, wird der Nachfolger berechnet, * indem die Zahl mal 3 multipliziert und dann 1 addiert wird * Abbruch bei zahl==1, aber gar nicht sicher, ob das fuer * jeden Startwert erreicht wird */ public static void collatzFolge ( int start ) { int zahl = start ; while ( zahl != 1 ) { System . out . print ( zahl + \" \" ); if ( zahl % 2 == 0 ) { zahl = zahl / 2 ; } else { zahl = 3 * zahl + 1 ; } } System . out . println ( \"Ende - Zahl ist \" + zahl ); } /* * Programmethode */ public static void main ( String [] args ) { System . out . println ( \"Thema heute : Iterationen (Schleifen) ------------------------\" ); System . out . println ( \"Skript : http://freiheit.f4.htw-berlin.de/prog1/iteration\" ); /* * Sequenz */ System . out . println ( \"Das\" ); System . out . println ( \"ist \" ); System . out . println ( \"eine Sequenz \" ); /* * Selektion */ int i = - 1 ; if ( i == 0 ) { System . out . println ( \"Der Wert der Variable i ist 0\" ); } else { System . out . println ( \"Der Wert der Variable i ist ungleich 0\" ); } /* * Iteration * 3 verschiedene Schleifen in Java: * - for-Schleife * - while-Schleife * - do-while-Schleife * * zunaechst: for-Schleife */ for ( int lauf = 10 ; lauf > 0 ; lauf -= 2 ) // lauf = lauf - 2; { System . out . println ( lauf + \": Diese Anweisung soll wiederholt werden\" ); if ( lauf % 2 == 0 ) { System . out . println ( \"Zahl ist gerade\" ); } } System . out . println ( \"Schleife verlassen - Bedingung false\" ); /* * verschachtelte Schleife in der Methode * printSchleifeInSchleife() */ System . out . println (); System . out . println (); printSchleifeInSchleife (); /* * verschachtelte Schleife in der Methode * printRectangle(width, height) * siehe auch Skript */ System . out . println (); System . out . println (); printRectangle ( 70 , 14 ); /* * while-Schleife in der Methode * collatzFolge(start) */ System . out . println (); System . out . println (); collatzFolge ( 111 ); /* * letzte Schleife, die es in Java gibt * do-while-Schleife * */ System . out . println (); System . out . println (); int wert = 12 ; do { wert = wert / 3 ; System . out . println ( wert ); } while ( wert > 0 ); System . out . println ( \"Ende\" ); } } Methodenstack, Lebensdauer und Sichtbarkeit von Variablen (siehe Skript Methodenstack ) 20.11. + 24.11.2020 - Scanner, Math, Random, String, Einf\u00fchrung Arrays siehe Aufgabe 2 siehe \u00dcbung 3 siehe Skript N\u00fctzliche Klassen - Scanner, Math, Random, String Video zu N\u00fctzliche Klassen - Scanner, Math, Random, String Hilfsklassen.java aus dem Video 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 package themen.hilfsklassen ; import java.util.Random ; import java.util.Scanner ; /** * * @author jornfreiheit * * Wir erstellen eine Tabelle der Form: * System.out.println(\" a | b | a + b | a - b | a * b | a / b | a % b | sqrt(a) | sqrt(b) | 2^a |\"); * System.out.println(\"-------------------------------------------------------------------------------------------------------------------------\"); * * und verwenden dazu einige n\u00fctzliche Klassen: * Scanner zum Einlesen von Werten von der Konsole * Random f\u00fcr das Erzeugen von Zufallszahlen * Math f\u00fcr einige mathematische Funktionen * * und n\u00fctzliche Methoden f\u00fcr das Formatieren von Ausgaben * String.format() * System.out.printf() * * im Skript: http://freiheit.f4.htw-berlin.de/prog1/hilfsklassen/#nutzliche-klassen * */ public class Hilfsklassen { public static int inputIntNumber () { Scanner sc = new Scanner ( System . in ); System . out . print ( \"Geben Sie eine Zahl ein : \" ); int zahl = sc . nextInt (); return zahl ; } public static void createTable ( int rows ) { System . out . println ( \" a | b | a + b | a - b | a * b | a / b | a % b | sqrt(a) | sqrt(b) | 2^a |\" ); System . out . println ( \"-------------------------------------------------------------------------------------------------------------------------\" ); for ( int i = 0 ; i < rows ; i ++ ) { Random r = new Random (); int number1 = r . nextInt ( 100 ) + 1 ; int number2 = r . nextInt ( 100 ) + 1 ; double sqrtNr1 = Math . sqrt ( number1 ); double sqrtNr2 = Math . sqrt ( number2 ); double pow2Nr1 = Math . pow ( 2 , number1 ); String output = String . format ( \"%4d | %4d | %5d | %5d | %7d | %5d | %6d | %8.5f | %8.5f | %31.0f | %n\" , number1 , number2 , ( number1 + number2 ), ( number1 - number2 ), ( number1 * number2 ), ( number1 / number2 ), ( number1 % number2 ), sqrtNr1 , sqrtNr2 , pow2Nr1 ); //System.out.printf(\"%4d | %4d | %n\", number1, number2); System . out . print ( output ); } } public static void main ( String [] args ) { int rows = inputIntNumber (); System . out . println (); createTable ( rows ); } } siehe Skript Einf\u00fchrung Arrays Video zu Einf\u00fchrung Arrays MyArrays.java aus dem Video 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 package themen.arrays ; /** * * @author jornfreiheit * * Kurze Einfuehrung in Arrays * * Skript: http://freiheit.f4.htw-berlin.de/prog1/arrays/#arrays */ public class MyArrays { public static void main ( String [] args ) { int number1 = 0 ; int number2 = 1 ; int number3 = 4 ; int number4 = 9 ; int number5 = 16 ; int [] numbers = new int [ 5 ] ; // Laenge 5 --> 5 Elemente numbers [ 0 ] = 0 ; numbers [ 1 ] = 1 ; numbers [ 2 ] = 4 ; numbers [ 3 ] = 9 ; numbers [ 4 ] = 16 ; System . out . println ( numbers [ 0 ] ); System . out . println ( numbers [ 1 ] ); System . out . println ( numbers [ 2 ] ); System . out . println ( numbers [ 3 ] ); System . out . println ( numbers [ 4 ] ); System . out . println (); for ( int index = 0 ; index < numbers . length ; index ++ ) { System . out . println ( numbers [ index ] ); } int sum = 0 ; for ( int index = 0 ; index < numbers . length ; index ++ ) { sum = sum + numbers [ index ] ; } System . out . println ( \"Summe aller Werte im Array ist \" + sum ); String [] satz = new String [ 4 ] ; satz [ 0 ] = \"Das\" ; satz [ 1 ] = \"ist\" ; satz [ 2 ] = \"ein\" ; satz [ 3 ] = \"Satz\" ; for ( int index = 0 ; index < satz . length - 1 ; index ++ ) { System . out . print ( satz [ index ]+ \" \" ); } System . out . print ( satz [ satz . length - 1 ]+ \".\" ); int [] numbers1 = { 0 , 1 , 4 , 9 , 16 }; // exakt wie Zeilen 22-27 String [] satz1 = { \"Das\" , \"ist\" , \"ein\" , \"Satz\" }; // exakt wie Zeilen 49-53 } } 27.11. + 01.12.2020 - Algorithmen \u00fcber Arrays siehe Aufgabe 3 siehe \u00dcbung 4 siehe Arrays diese Woche kein Video - Skript ist eh informativer (meine Meinung). Arbeiten Sie das Skript ( Arrays ) bitte eingehend durch! Sowohl in dem Abschnitt \u00fcber Arrays als auch hier gibt es \u00dcbungen zum Thema.","title":"Home"},{"location":"#programmieren-i","text":"Herzlich willkommen zur Programmieren I Veranstaltung! Wir werden unter Verwendung der Programmiersprache die wesentlichen Konzepte lernen, die f\u00fcr das Verst\u00e4ndnis mordenen Programmierens notwendig sind. Es sind keinerlei Vorkenntnisse erforderlich. Hier einige Tipps, damit Sie die Veranstaltung erfolgreich durchf\u00fchren und Sie dabei auch Spa\u00df haben: L\u00f6sen Sie alle \u00dcbungsaufgaben selbst\u00e4ndig! Es ist kein Problem, wenn Sie f\u00fcr das Bew\u00e4ltigen der \u00dcbungen etwas l\u00e4nger ben\u00f6tigen. Sollten Sie es gar nicht alleine schaffen, ist das auch kein Problem. Wichtig ist dann, dass Sie sich die L\u00f6sung anschauen und es erneut selbst\u00e4ndig versuchen. H\u00f6ren Sie nicht auf, bis Sie es geschafft haben! Sie k\u00f6nnen die Hausaufgaben zu zweit l\u00f6sen. Achten Sie aber darauf, dass Sie Ihre gemeinsame L\u00f6sung vollst\u00e4ndig verstanden haben und dass Sie sie danach auch alleine erstellen k\u00f6nnen. Sie k\u00f6nnen beim L\u00f6sen der Hausaufgaben beliebig kreativ sein! Die Aufgabenstellung gibt Ihnen Anhaltspunkte f\u00fcr eine eventuelle L\u00f6sung. Sie k\u00f6nnen es aber auch ganz anders machen! Die Klausurvorbereitung beginnt mit Beginn der Veranstaltung. Es ist nicht m\u00f6glich, die Klausur am Ende des Semesters zu bestehen, wenn Sie nicht das ganze Semester \u00fcber intensiv programmieren. Die \u00dcbungsaufgaben sind \"kleine\" Aufgaben, um das in der Vorlesung vermittelte Wissen direkt anzuwenden. F\u00fcr die L\u00f6sung der Hausaufgaben ist bereits ein gewisses Abstraktionsniveau erforderlich, um zu erkennen, dass das in der Vorlesung vermittelte Wissen daf\u00fcr ausreichend ist. Programmieren lernt man nur durch Programmieren. Sie m\u00fcssen es tun. Das Lesen von B\u00fcchern oder das \"Anschauen\" von Code gen\u00fcgt nicht. Eine Sprache lernt man auch nur durch Sprechen. Sie m\u00fcssen programmieren, programmieren, prohgrammieren... Lassen Sie sich durch Fehler nicht verunsichern, sondern analysieren Sie Ihre Fehler. Bis zur Klausur sollten Sie alle Fehler einmal gemacht haben. Wenn Sie sich \u00fcberlegen, warum das jeweils ein Fehler war, dann werden Sie diesen Fehler nicht wiederholen und haben durch die Reflektion eine Menge gelernt. Fehler zu machen (und dar\u00fcber zu reflektieren) geh\u00f6rt zu den besten Lernmethoden des Programmierens. Haben Sie Spa\u00df! Je mehr Sie das Programmieren lernen, je mehr Spa\u00df werden Sie haben. Wir versuchen, dass Sie das genaze Semester \u00fcber Spa\u00df am Programmieren haben werden. Sollte es Ihnen zwischendurch keinen Spa\u00df mehr machen, geben Sie mir sofort Bescheid! Viel Erfolg! Und viel Spa\u00df!","title":"Programmieren I"},{"location":"#organisatorisches","text":"Der (Corona-)Plan zur Durchf\u00fchrung der Veranstaltung ist derzeit wie folgt: Themen werden ausf\u00fchrlich in diesem Skript beschrieben und anhand von Videos verdeutlicht das Skript und die Videos werden (sp\u00e4testens) freitags hochgeladen (gilt dann f\u00fcr die gesamte Woche - also Freitag + Dienstag) das hei\u00dft, \"Vorlesungen\" finden asynchron statt (im Selbststudium) zusammen mit dem Skript und den Videos werden sowohl die \u00dcbung als auch die Aufgabe hochgeladen die \u00dcbung (und die vergangene Aufgabe) werden dienstags (12.15 Uhr) und mittwochs (9:45 Uhr) besprochen (Sie k\u00f6nnen frei w\u00e4hlen, welche der beiden \u00dcbungen Sie w\u00e4hlen) bei Bedarf k\u00f6nnen wir auch gerne eine Synchron-Video-Vorlesung einschieben, um Fragen zu erkl\u00e4ren sollten Sie W\u00fcnsche haben, diesen Plan zu \u00e4ndern, kommen Sie gerne auf mich zu Zur erfolgreichen Durchf\u00fchrung der Veranstaltung m\u00fcssen die Aufgaben l\u00f6sen und zu den jeweiligen Fristen auf Moodle hochladen. Wenn Sie alle Aufgaben fristgerecht hochgeladen haben, d\u00fcrfen Sie an der Klausur teilnehmen. Es werden insgesamt wahrscheinlich 9 Aufgaben sein, die Sie selbst\u00e4ndig l\u00f6sen und hochladen m\u00fcssen. Sie k\u00f6nnen die Aufgaben auch zu zweit l\u00f6sen. Laden Sie dann aber bitte beide jeweils die L\u00f6sung hoch. Am Ende des Semesters schreiben wir eine Klausur (am Rechner). Diese Klausur wird bewertet und entspricht der Note f\u00fcr \"Programmieren 1\". Unter Aufgaben sind die Aufgaben beschrieben, die Sie in jeder Woche ausf\u00fchren sollen. Damit Sie dies erfolgreich erledigen k\u00f6nnen, ist jeweils angegeben, welche Themen Sie daf\u00fcr durcharbeiten m\u00fcssen. Das Durcharbeiten der jeweiligen Themen entspricht jeweils einer Vorlesung. Diese wird also selbst\u00e4ndig durchgef\u00fchrt. Daneben gibt es jede Woche (zu jedem Thema) \u00dcbungen , die wir in den \u00dcbungszeiten besprechen. Diese dienen der Anwendung und der Festigung der erlangten Kenntnisse. Die \u00dcbungen sind kleine Aufgaben, an denen Sie das neue Wissen anwenden sollen. Die \u00dcbungen dienen der Bef\u00e4higung, die (gr\u00f6\u00dferen) Aufgaben l\u00f6sen zu k\u00f6nnen. F\u00fcr die Kommunikation untereinander verwenden wir Slack . Dort k\u00f6nnen Sie alle inhaltlichen und organisatorischen Fragen stellen. Ich f\u00e4nde es gut, wenn ich dort m\u00f6glichst wenig Fragen - zumindest die inhaltlichen - beantworten m\u00fcsste, sondern eine Art internes Diskussionsforum entsteht. Es ist sehr gew\u00fcnscht, dort Fragen zu stellen und noch mehr gew\u00fcnscht, diese von Ihnen dort beantwortet zu sehen. Damit w\u00e4re allen geholfen und ich kann besser erkennen, wo noch Nachhol- bzw. Erl\u00e4uterungsbedarf bei den meisten besteht.","title":"Organisatorisches"},{"location":"#planung-vorlaufig-kann-sich-noch-andern","text":"Nachfolgend der vorl\u00e4ufige Wochenplan (wird eventuell angepasst). Die Vorlesungsvideos finden Sie darunter f\u00fcr die einzelnen Wochen (unter Themen ). Woche Themen (Vorlesung) Aufgabe Abgabe Aufgabe bis 1. 02.-06.11.2020 Einf\u00fchrung und Organisatorisches, erstes Programm - - 2. 09.-13.11.2020 Datentypen und Variablen, logische Ausdr\u00fccke Aufgabe 1 22.11.2020 3. 16.-20.11.2020 Sequenzen, Iterationen und Selektion Aufgabe 2 29.11.2020 4. 23.-27.11.2020 N\u00fctzliche Klassen, Einf\u00fchrung Arrays Aufgabe 3 06.12.2020 5. 30.-04.12.2020 Sortieren von Arrays Aufgabe 4 13.12.2020 6. 07.-11.12.2020 Klassen und Objekte Aufgabe 5 20.12.2020 7. 14.-18.12.2020 Getter, Setter, Konstruktoren, this, private Aufgabe 6 10.01.2021 8. 21.-25.12.2020 Klassen- und Objekt-Variablen und -Methoden Aufgabe 7 17.01.2021 9. 04.-08.01.2021 Vererbung Aufgabe 8 24.01.2021 10. 11.-15.01.2021 Polymorphie Aufgabe 9 31.01.2021 11. 18.-22.01.2021 Object - - 12. 25.-29.01.2021 Sichtbarkeitsmodifizierer Fragen - 13. 01.-05.02.2021 Wiederholung, Klausurvorbereitung -","title":"Planung (vorl\u00e4ufig - kann sich noch \u00e4ndern)"},{"location":"#themen","text":"Hier sind die Themen in chronologischer Folge aufgef\u00fchrt, wie wir sie auch in den Vorlesungen behandeln. Durch interne Links werden Bez\u00fcge innerhalb der Themen hergestellt. Sie k\u00f6nnen die Themen in dieser Folge abarbeiten, k\u00f6nnen aber auch beliebig hin- und herspringen. Zu jeden Themen gibt es \u00dcbungsaufgaben. Diese sind ebenfalls verlinkt. Sollten Sie zu einzelnen Themen das Gef\u00fchl haben, dass diese nicht ausf\u00fchrlich genug beschrieben sind, geben Sie mir bitte Bescheid. Ziel ist, dass dieses \"Skript\" Ihnen die Einf\u00fchrung in das Programmieren vollst\u00e4ndig erm\u00f6glicht. Das hei\u00dft nicht, dass Sie nicht weitere Literatur verwenden sollen. Einen \u00dcberblick \u00fcber geeignete Literatur finden Sie hier . 03.11.2020 - Einf\u00fchrung und Organisatorisches siehe \u00dcbung 0 Zoom-Meeting (sorry, leider zu sp\u00e4t auf Aufnahme gedr\u00fcckt - vergessen, aber es steht alles hier oben) MyFirstClass.java package uebungen.uebung0 ; /** * * @author jornfreiheit * */ public class MyFirstClass { public static void main ( String [] args ) { System . out . println ( \"Hallo FIW!\" ); System . out . println (); // das ist eine Leerzeile System . out . println ( \"Wir programmieren!!!\" ); System . out . println ( \"Hurra!!!\" ); /* * * das ist ein Block-Kommentar * kann \u00fcber mehrere Zeilen gehen */ } } 06.11. + 10.11.2020 - Variablen, Datentypen, Methoden, Selektion siehe \u00dcbung 1 Variablen (siehe Skript Variablen ) Variablen.java package themen.variablen ; public class Variablen { public static void main ( String [] args ) { System . out . println ( \"Thema heute: Variablen\" ); System . out . println ( \"Im Skript unter http://freiheit.f4.htw-berlin.de/prog1/variablen/\" ); System . out . println (); /* * Erzeugen einer Variable: \"Deklarieren der Variable\" * datentyp variablenName; * * Datentypen??? * * ganzzahlige Datentypen: int, long, short, byte */ int ganzeZahl ; // Variable ganzeZahl erzeugt (1x)! int nochEineGanzeZahl = 0 ; // Deklaration und Wertzuweisung (Initialisierung) long grosseGanzeZahl = 123456789L ; // int 32 bit , aber long 64 bit short kleinereGanzeZahl = 123 ; // 16 bit byte ganzKleineGanzeZahl = 127 ; // 8 bit /* * Datentypen, um Gleitkommazahlen zu speichern * double, float */ double number1 = 6.789 ; // 64 bit float number2 = 5.0f ; // 32 bit /* * Datentyp, um ein Zeichen (character) zu speichern * char */ char zeichen = 'a' ; char zeichen1 = 97 ; char zeichen2 = '\\u00a9' ; /* * Datentyp, um Wahrheitswerte zu speichern * boolean */ boolean condition = true ; boolean condition1 = false ; /* * Wertzuweisung * Wertzuweisungsoperator = * variablenName = wert; */ ganzeZahl = 7 ; // Wertzuweisung beliebig oft System . out . println ( ganzeZahl ); ganzeZahl = - 123 ; System . out . println ( ganzeZahl ); System . out . println ( grosseGanzeZahl ); System . out . println ( ganzKleineGanzeZahl ); System . out . println ( number1 ); System . out . println ( number2 ); System . out . println ( zeichen ); System . out . println ( zeichen1 ); System . out . println ( zeichen2 ); System . out . println ( condition ); System . out . println ( condition1 ); /* * bis hier her Wertetypen * jetzt noch ein Datentyp * String * (Referenztyp) * */ String zeichenkette = \"Hallo\" ; System . out . println ( zeichenkette ); } } Ausdr\u00fccke und Operatoren (siehe Skript Ausdr\u00fccke und Operatoren ) Ausdruecke.java package themen.ausdruecke ; public class Ausdruecke { public static void main ( String [] args ) { System . out . println ( \"Thema heute: Ausdruecke\" ); System . out . println ( \"Im Skript unter http://freiheit.f4.htw-berlin.de/prog1/ausdruecke/#operatoren-und-ausdrucke\" ); System . out . println (); int a = 8 ; int b = 2 ; int c = 0 ; c = a + b ; System . out . println ( c ); a = a + b ; System . out . println ( a ); a = a * b ; System . out . println ( a ); a = a / b ; System . out . println ( a ); a = a - b ; System . out . println ( a ); a = 7 ; a = a / b ; // 7 / 2 --> ganzzahlige Division! System . out . println ( a ); // a ist 3 a = 7 ; a = a % b ; // Restwertoperator (modulo) System . out . println ( a ); double x = 8.2 ; double y = 2.3 ; x = x + y ; System . out . println ( x ); x = x * y ; System . out . println ( x ); x = x - y ; System . out . println ( x ); x = 7.0 ; y = 2.0 ; x = x / y ; // 7.0 / 2.0 --> Gleitkomma-Division! System . out . println ( x ); // a ist 3.5 x = 7.0 ; x = x % y ; System . out . println ( x ); a ++ ; // a = a + 1; System . out . println ( a ); ++ a ; // a = a + 1; System . out . println ( a ); b = 0 ; a = 2 ; b = ++ a ; System . out . println ( b ); System . out . println ( a ); b = a ++ ; System . out . println ( b ); System . out . println ( a ); a -- ; // a = a - 1; -- a ; // a = a - 1; a = 5 ; a += 4 ; // a = a + 4; a *= 3 ; // a = a * 3; a /= 4 ; // a = a / 4; a -= 3 ; // a = a - 3; a %= 2 ; // a = a % 2; double d = 5.0 ; int e = 2 ; System . out . println ( d / e ); // Gleitkommadivision System . out . println ( e / d ); // Gleitkommadivision System . out . println ( 7 == 2 ); // Gleichheit --> Ergebnis ist boolean System . out . println ( 7 == 7 ); // Gleichheit --> Ergebnis ist boolean System . out . println ( 7 != 2 ); // Ungleichheit --> Ergebnis ist boolean System . out . println ( 7 != 7 ); // Ungleichheit --> Ergebnis ist boolean System . out . println ( 7 > 2 ); // groesser als --> Ergebnis ist boolean System . out . println ( 7 > 7 ); // groesser als --> Ergebnis ist boolean System . out . println ( 7 < 2 ); // kleiner als --> Ergebnis ist boolean System . out . println ( 7 < 7 ); // kleiner als --> Ergebnis ist boolean System . out . println ( 7 <= 2 ); // kleiner gleich --> Ergebnis ist boolean System . out . println ( 7 <= 7 ); // kleiner gleich --> Ergebnis ist boolean System . out . println ( 7 >= 2 ); // groesser gleich --> Ergebnis ist boolean System . out . println ( 7 >= 7 ); // groesser gleich --> Ergebnis ist boolean boolean check = 7 != 2 ; System . out . println ( check ); boolean b1 = true ; boolean b2 = false ; System . out . println ( \" -------- Negation ---------- \" ); System . out . println ( b1 ); b1 = ! b1 ; // Negation b2 = ! b2 ; // Negation System . out . println ( b1 ); System . out . println ( b2 ); System . out . println ( \" -------- logisches UND ---------- \" ); System . out . println ( false && true ); // false UND true --> false System . out . println ( true && true ); // true UND true --> true System . out . println ( true && false ); // true UND false --> false System . out . println ( false && false ); // false UND false --> false System . out . println ( \" -------- logisches ODER ---------- \" ); System . out . println ( false || true ); // false ODER true --> true System . out . println ( true || true ); // true ODER true --> true System . out . println ( true || false ); // true ODER false --> true System . out . println ( false || false ); // false ODER false --> false System . out . println ( \" -------- logisches EXCLUSIVES ODER ---------- \" ); System . out . println ( false ^ true ); // false EXCL. ODER true --> true System . out . println ( true ^ true ); // true EXCL. ODER true --> false System . out . println ( true ^ false ); // true EXCL. ODER false --> true System . out . println ( false ^ false ); // false EXCL. ODER false --> false System . out . println ( \" -------- String-Verkettung ---------- \" ); String s1 = \"Hallo \" ; String s2 = \"FIW!\" ; System . out . println ( s1 + s2 ); // Verkettung von Strings (Konkatenation) s1 = s1 + s2 ; // \"Hallo FIW!\" System . out . println ( s1 ); int z1 = 22 ; int z2 = 11 ; int result = z1 / z2 ; System . out . println ( \"das Resultat ist : \" + result ); // Konkatenation System . out . println ( z1 + \" / \" + z2 + \" = \" + result ); System . out . println ( 3 + \" + \" + 4 + \" = \" + 3 + 4 ); // warum? System . out . println ( 3 + \" + \" + 4 + \" = \" + ( 3 + 4 )); // warum? } } Methoden (siehe Skript Methoden ) Methoden.java package themen.methoden ; public class Methoden { public static void add ( int summand1 , int summand2 ) { int summe = summand1 + summand2 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summe ); } public static void divide ( int divident , int divisor ) { int quotient = divident / divisor ; int rest = divident % divisor ; System . out . println ( divident + \" / \" + divisor + \" = \" + quotient + \" mit dem Rest \" + rest ); } public static int computeSum ( int summand1 , int summand2 ) { int summe = summand1 + summand2 ; return summe ; } public static boolean greaterThanZero ( int number ) { return ( number > 0 ); } public static void main ( String [] args ) { System . out . println ( \"Thema heute: Methoden\" ); System . out . println ( \"Im Skript unter http://freiheit.f4.htw-berlin.de/prog1/methoden/#methoden\" ); System . out . println (); /* int summand1 = 3; int summand2 = 4; int summe = summand1 + summand2; System.out.println(summand1 + \" + \" + summand2 + \" = \" + summe); summand1 = 5; summand2 = 9; summe = summand1 + summand2; System.out.println(summand1 + \" + \" + summand2 + \" = \" + summe); summand1 = -115; summand2 = 999; summe = summand1 + summand2; System.out.println(summand1 + \" + \" + summand2 + \" = \" + summe); */ add ( 3 , 4 ); add ( 5 , 9 ); add ( - 115 , 999 ); divide ( 17 , 12 ); divide ( 12 , 4 ); int sum = computeSum ( 3 , 4 ); System . out . println ( sum ); System . out . println ( computeSum ( 5 , 9 )); System . out . println ( greaterThanZero ( - 7 )); } } Selektion (siehe Skript Selektion ) 13.11. + 17.11.2020 - Iteration (Schleifen), Methodenstack, Sichtbarkeit und Lebensdauer von Variablen siehe Aufgabe 1 siehe \u00dcbung 2 Iteration (siehe Skript Iteration ) Schleifen.java aus dem Video 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 package themen.iteration ; public class Schleifen { /* * verschachtelte Schleife * innere Schleife wird immer vollstaendig ausgefuehrt (j von 0 bis 6) * erst dann wieder i erhoehen --> dann wieder innere Schleife vollstaendig ausfuehren */ public static void printSchleifeInSchleife () { for ( int i = 0 ; i < 8 ; i ++ ) { System . out . println ( \"i : \" + i + \" ----------\" ); for ( int j = 0 ; j < 7 ; j ++ ) { System . out . println ( \"j : \" + j ); } } } /* * width gibt Anzahl der Sterne an, die wir in einer Zeile ausgeben * height gibt an, wieviele Zeilen wir ausgeben */ public static void printRectangle ( int width , int height ) { for ( int row = 0 ; row < height ; row ++ ) { for ( int stars = 0 ; stars < width ; stars ++ ) { System . out . print ( \"*\" ); } System . out . println (); } } /* * es wird eine Folge von Zahlen berechnet * die Folge stoppt, wenn die Zahl den Wert 1 hat * ist die Zahl gerade, wird der Nachfolger berechnet, * indem die Zahl durch 2 geteilt wird * ist die Zahl ungerade, wird der Nachfolger berechnet, * indem die Zahl mal 3 multipliziert und dann 1 addiert wird * Abbruch bei zahl==1, aber gar nicht sicher, ob das fuer * jeden Startwert erreicht wird */ public static void collatzFolge ( int start ) { int zahl = start ; while ( zahl != 1 ) { System . out . print ( zahl + \" \" ); if ( zahl % 2 == 0 ) { zahl = zahl / 2 ; } else { zahl = 3 * zahl + 1 ; } } System . out . println ( \"Ende - Zahl ist \" + zahl ); } /* * Programmethode */ public static void main ( String [] args ) { System . out . println ( \"Thema heute : Iterationen (Schleifen) ------------------------\" ); System . out . println ( \"Skript : http://freiheit.f4.htw-berlin.de/prog1/iteration\" ); /* * Sequenz */ System . out . println ( \"Das\" ); System . out . println ( \"ist \" ); System . out . println ( \"eine Sequenz \" ); /* * Selektion */ int i = - 1 ; if ( i == 0 ) { System . out . println ( \"Der Wert der Variable i ist 0\" ); } else { System . out . println ( \"Der Wert der Variable i ist ungleich 0\" ); } /* * Iteration * 3 verschiedene Schleifen in Java: * - for-Schleife * - while-Schleife * - do-while-Schleife * * zunaechst: for-Schleife */ for ( int lauf = 10 ; lauf > 0 ; lauf -= 2 ) // lauf = lauf - 2; { System . out . println ( lauf + \": Diese Anweisung soll wiederholt werden\" ); if ( lauf % 2 == 0 ) { System . out . println ( \"Zahl ist gerade\" ); } } System . out . println ( \"Schleife verlassen - Bedingung false\" ); /* * verschachtelte Schleife in der Methode * printSchleifeInSchleife() */ System . out . println (); System . out . println (); printSchleifeInSchleife (); /* * verschachtelte Schleife in der Methode * printRectangle(width, height) * siehe auch Skript */ System . out . println (); System . out . println (); printRectangle ( 70 , 14 ); /* * while-Schleife in der Methode * collatzFolge(start) */ System . out . println (); System . out . println (); collatzFolge ( 111 ); /* * letzte Schleife, die es in Java gibt * do-while-Schleife * */ System . out . println (); System . out . println (); int wert = 12 ; do { wert = wert / 3 ; System . out . println ( wert ); } while ( wert > 0 ); System . out . println ( \"Ende\" ); } } Methodenstack, Lebensdauer und Sichtbarkeit von Variablen (siehe Skript Methodenstack ) 20.11. + 24.11.2020 - Scanner, Math, Random, String, Einf\u00fchrung Arrays siehe Aufgabe 2 siehe \u00dcbung 3 siehe Skript N\u00fctzliche Klassen - Scanner, Math, Random, String Video zu N\u00fctzliche Klassen - Scanner, Math, Random, String Hilfsklassen.java aus dem Video 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 package themen.hilfsklassen ; import java.util.Random ; import java.util.Scanner ; /** * * @author jornfreiheit * * Wir erstellen eine Tabelle der Form: * System.out.println(\" a | b | a + b | a - b | a * b | a / b | a % b | sqrt(a) | sqrt(b) | 2^a |\"); * System.out.println(\"-------------------------------------------------------------------------------------------------------------------------\"); * * und verwenden dazu einige n\u00fctzliche Klassen: * Scanner zum Einlesen von Werten von der Konsole * Random f\u00fcr das Erzeugen von Zufallszahlen * Math f\u00fcr einige mathematische Funktionen * * und n\u00fctzliche Methoden f\u00fcr das Formatieren von Ausgaben * String.format() * System.out.printf() * * im Skript: http://freiheit.f4.htw-berlin.de/prog1/hilfsklassen/#nutzliche-klassen * */ public class Hilfsklassen { public static int inputIntNumber () { Scanner sc = new Scanner ( System . in ); System . out . print ( \"Geben Sie eine Zahl ein : \" ); int zahl = sc . nextInt (); return zahl ; } public static void createTable ( int rows ) { System . out . println ( \" a | b | a + b | a - b | a * b | a / b | a % b | sqrt(a) | sqrt(b) | 2^a |\" ); System . out . println ( \"-------------------------------------------------------------------------------------------------------------------------\" ); for ( int i = 0 ; i < rows ; i ++ ) { Random r = new Random (); int number1 = r . nextInt ( 100 ) + 1 ; int number2 = r . nextInt ( 100 ) + 1 ; double sqrtNr1 = Math . sqrt ( number1 ); double sqrtNr2 = Math . sqrt ( number2 ); double pow2Nr1 = Math . pow ( 2 , number1 ); String output = String . format ( \"%4d | %4d | %5d | %5d | %7d | %5d | %6d | %8.5f | %8.5f | %31.0f | %n\" , number1 , number2 , ( number1 + number2 ), ( number1 - number2 ), ( number1 * number2 ), ( number1 / number2 ), ( number1 % number2 ), sqrtNr1 , sqrtNr2 , pow2Nr1 ); //System.out.printf(\"%4d | %4d | %n\", number1, number2); System . out . print ( output ); } } public static void main ( String [] args ) { int rows = inputIntNumber (); System . out . println (); createTable ( rows ); } } siehe Skript Einf\u00fchrung Arrays Video zu Einf\u00fchrung Arrays MyArrays.java aus dem Video 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 package themen.arrays ; /** * * @author jornfreiheit * * Kurze Einfuehrung in Arrays * * Skript: http://freiheit.f4.htw-berlin.de/prog1/arrays/#arrays */ public class MyArrays { public static void main ( String [] args ) { int number1 = 0 ; int number2 = 1 ; int number3 = 4 ; int number4 = 9 ; int number5 = 16 ; int [] numbers = new int [ 5 ] ; // Laenge 5 --> 5 Elemente numbers [ 0 ] = 0 ; numbers [ 1 ] = 1 ; numbers [ 2 ] = 4 ; numbers [ 3 ] = 9 ; numbers [ 4 ] = 16 ; System . out . println ( numbers [ 0 ] ); System . out . println ( numbers [ 1 ] ); System . out . println ( numbers [ 2 ] ); System . out . println ( numbers [ 3 ] ); System . out . println ( numbers [ 4 ] ); System . out . println (); for ( int index = 0 ; index < numbers . length ; index ++ ) { System . out . println ( numbers [ index ] ); } int sum = 0 ; for ( int index = 0 ; index < numbers . length ; index ++ ) { sum = sum + numbers [ index ] ; } System . out . println ( \"Summe aller Werte im Array ist \" + sum ); String [] satz = new String [ 4 ] ; satz [ 0 ] = \"Das\" ; satz [ 1 ] = \"ist\" ; satz [ 2 ] = \"ein\" ; satz [ 3 ] = \"Satz\" ; for ( int index = 0 ; index < satz . length - 1 ; index ++ ) { System . out . print ( satz [ index ]+ \" \" ); } System . out . print ( satz [ satz . length - 1 ]+ \".\" ); int [] numbers1 = { 0 , 1 , 4 , 9 , 16 }; // exakt wie Zeilen 22-27 String [] satz1 = { \"Das\" , \"ist\" , \"ein\" , \"Satz\" }; // exakt wie Zeilen 49-53 } } 27.11. + 01.12.2020 - Algorithmen \u00fcber Arrays siehe Aufgabe 3 siehe \u00dcbung 4 siehe Arrays diese Woche kein Video - Skript ist eh informativer (meine Meinung). Arbeiten Sie das Skript ( Arrays ) bitte eingehend durch! Sowohl in dem Abschnitt \u00fcber Arrays als auch hier gibt es \u00dcbungen zum Thema.","title":"Themen"},{"location":"arrays/","text":"Arrays \u00b6 In einer Variable k\u00f6nnen wir genau einen Wert speichern. Wenn wir 5 Werte speichern wollen, ben\u00f6tigen wir 5 Variablen und wenn wir 1000 Werte speichern wollen, ben\u00f6tigen wir 1000 Variablen. Das ist nat\u00fcrlich unzweckm\u00e4\u00dfig. Wenn Sie mehrere Werte gleichen Typs speichern wollen, dann verwenden Sie dazu besser Arrays ( Felder ). Arrays sind Objekte. Wir schauen uns mal ein einf\u00fchrendes Beispiel an. Angenommen, wir wollen 5 int -Werte 0 , 1 , 4 , 9 und 16 speichern. Bis jetzt ben\u00f6tigten wir dazu 5 Variablen: int number1 = 0 ; int number2 = 1 ; int number3 = 4 ; int number4 = 9 ; int number5 = 16 ; Jetzt wollen wir dazu ein Array verwenden. Die Erzeugung und Initialisierung sieht so aus: 1 2 3 4 5 6 int [] numbers = new int [ 5 ] ; // Array der Laenge 5 numbers [ 0 ] = 0 ; // erstes Element Wert 0 numbers [ 1 ] = 1 ; // zweites Element Wert 1 numbers [ 2 ] = 4 ; // drittes Element Wert 4 numbers [ 3 ] = 9 ; // viertes Element Wert 9 numbers [ 4 ] = 16 ; // fuenftes Element Wert 16 Ein Array erkennen wir an den eckigen Klammern [] . Unser Array im Beispiel ist vom Typ int , d.h. jedes Element in diesem Array ist vom Typ int . Arrays k\u00f6nnen von einem beliebigen Typ sein, sowohl Wertetypen als auch Referenztypen. Ein Array wird immer f\u00fcr genau einen Typ deklariert, bei uns int \u2192 deshalb int[] . Best\u00fcnde das Array aus lauter Strings, dann w\u00e4re der Typ String[] . In unserem Beispiel ist numbers die Referenzvariable, die auf unser Array-Objekt zeigt. Mithilfe des Schl\u00fcsselwortes new wird unser Array erzeugt. Nach new kommt nochmal das Array ( Typ[] ), aber in den eckigen Klammern steht die L\u00e4nge des Arrays. In unserem Beispiel 5 . Bei der Erzeugung des Arrays muss immer die L\u00e4nge angegeben werden. Die L\u00e4nge eines Arrays kann sich nicht \u00e4ndern. Der Zugriff auf die einzelnen Elemente erfolgt \u00fcber den Index . Jedes Array ist automatisch \"nummeriert\". Die \"Nummerierung\" (der Index) beginnt immer mit 0 und erh\u00f6ht sich f\u00fcr jedes Element um 1 . Der Index eines Arrays ist immer vom Typ int . Wir k\u00f6nnen uns unser Array numbers so vorstellen: Wir haben 5 Elemente (L\u00e4nge 5 ), die jeweils durch den Index nummeriert sind. Diese Elemente k\u00f6nnen nun Werte enthalten: Der Zugriff auf die Werte eines Arrays erfolgt dann immer unter Verwendung der Referenzvariable, dahinter eckige Klammern und in den Klammern der entsprechende Index: Referenzvariable[Index]=Wert; Also in unserem Beispiel numbers[0] . Erzeugung und Initialisierung eines Arrays \u00b6 Die Erzeugung und Initialisierung eines Arrays erfolgt in drei Schritten: Schritt: Definition einer Referenzvariablen, die auf das Array-Objekt zeigt (siehe oben in Zeile 1 : int[] numbers t) Schritt: Erzeugen des Arrays, d. h. eines Array-Objektes, das aus Elementen eines bestimmten Datentyps besteht (und Zuweisung an die zuvor definiere Referenzvariable - siehe oben Zeile 1 : new int[5] ) Schritt: Belegen der Array-Elemente mit Werten, d. h. Initialisierung des Arrays (siehe oben Zeilen 2-6 ). Beispiele verschiedene Arrays erzeugen: double [] noten = new double [ 10 ] ; // Array aus double-Elemente Laenge 10 String [] satz = new String [ 30 ] ; // Array aus Zeichenketten Laenge 30 boolean [] filled = new boolean [ 100 ] ; // Array aus boolean-Elementen Laenge 100 int [] statistics = new int [ 10000 ] ; // Array aus int-Elementen Laenge 10000 Die Initialisierung erfolgt elementweise \u00fcber den Zugriff auf den Index, z.B. (siehe oben): numbers [ 0 ] = 0 ; // erstes Element Wert 0 numbers [ 1 ] = 1 ; // zweites Element Wert 1 numbers [ 2 ] = 4 ; // drittes Element Wert 4 numbers [ 3 ] = 9 ; // viertes Element Wert 9 numbers [ 4 ] = 16 ; // fuenftes Element Wert 16 Da der Index stets vom Typ int ist, h\u00e4tten wir unser Array auch wie folgt initialisieren k\u00f6nnen: 1 2 3 4 for ( int index = 0 ; index < 5 ; index ++ ) { numbers [ index ] = ( index * index ); } Beachten Sie: Der gr\u00f6\u00dfte Index ist immer um eins kleiner als die L\u00e4nge des Arrays (L\u00e4nge ist 5 , gr\u00f6\u00dfter Index ist 4 \u2192 deshalb index < 5 ) Der Index ist immer int , egal von welchem Typ das Array ist In unserem Beispiel entsprechen die Werte der einzelnen Elementen Quadratzahlen. Deshalb konnten wir als Wert (index * index) verwenden. Die Eigenschaft length \u00b6 Jedes Array besitzt die Eigenschaft length . Dar\u00fcber k\u00f6nnen wir die L\u00e4nge des Arrays auslesen. Der Wert von length kann nicht neu gesetzt werden (ist konstant). Wir benutzen die Eigenschaft length insbesondere in den Schleifen, mit denen wir auf den Index zugreifen. Referenzvariable.length Unser obiges Initialisierungsbeispiel h\u00e4tte also besser so ausgesehen: 1 2 3 4 for ( int index = 0 ; index < numbers . length ; index ++ ) { numbers [ index ] = ( index * index ); } Ausgabe der Werte \u00b6 Den jetzt bereits bekannten Zugriff auf die einzelnen Elemente k\u00f6nnen wir auch f\u00fcr das Auslesen der Werte eines Arrays verwenden: 1 2 3 4 for ( int index = 0 ; index < numbers . length ; index ++ ) { System . out . println ( numbers [ index ] ); } Verwenden der Werte \u00b6 Wir erl\u00e4utern ein einfaches Beispiel zur Verwendung der Werte, wir bilden die Summe aller Werte \u00fcber das Array (wir gehen davon aus, dass das numbers -Array so wie oben erzeugt un initialisiert wurde): int sum = 0 ; for ( int index = 0 ; index < numbers . length ; index ++ ) { sum = sum + numbers [ index ] ; } System . out . println ( \"Summe aller Elemente : \" + sum ); M\u00f6gliche andere Form der Erzeugung und Initialisierung \u00b6 Das Array kann auch in einer anderen Form erzeugt und initilisiert werden: int [] numbers = { 0 , 1 , 4 , 9 , 16 }; Diese Form erzeugt ein int[] -Array der L\u00e4nge 5 mit den Werten numbers [ 0 ] = 0 ; // erstes Element Wert 0 numbers [ 1 ] = 1 ; // zweites Element Wert 1 numbers [ 2 ] = 4 ; // drittes Element Wert 4 numbers [ 3 ] = 9 ; // viertes Element Wert 9 numbers [ 4 ] = 16 ; // fuenftes Element Wert 16 Es handelt sich um eine einfache Form der Erzeugung und Initialisierung in einem Schritt. Weitere Beispiele von Arrays \u00b6 Wir zeigen einige Beispiele anderer Arrays: 1 2 3 4 5 6 7 8 9 10 String [] satz = new String [ 4 ] ; satz [ 0 ] = \"Das\" ; satz [ 1 ] = \"ist\" ; satz [ 2 ] = \"ein\" ; satz [ 3 ] = \"Satz\" ; for ( int index = 0 ; index < satz . length - 1 ; index ++ ) { System . out . print ( satz [ index ] + \" \" ); } System . out . println ( satz [ satz . length - 1 ] + \".\" ); Das Beispiel zeigt die Erzeugung und Initialisierung eines Arrays, in dem alle Elemente vom Typ String sind. Nach der Erzeugung und Initialisierung in den Zeilen 1 bis 5 folgt die Ausgabe der Werte des Arrays. Es werden alle Werte ausgegeben und ein Leerzeichen angeh\u00e4ngt. Das gilt aber nur f\u00fcr alle Elemente einschlie\u00dflich des vorletzten ( index<satz.length-1 ). Hinter das letzte Element ( satz[satz.length-1] ) folgt kein Leerzeichen, sondern ein Punkt. Wir h\u00e4tten das Array auch so erzeugen und initialisieren k\u00f6nnen: String[] satz = {\"Das\", \"ist\", \"ein\", \"Satz\"}; Ein weiteres Beispiel mit einem char -Array: 1 2 3 4 5 6 7 8 9 char [] alphabet = new char [ 26 ] ; for ( int index = 0 ; index < 26 ; index ++ ) { alphabet [ index ] = ( char ) ( index + 65 ); } for ( int index = 0 ; index < 26 ; index ++ ) { System . out . print ( alphabet [ index ]+ \" \" ); } Es wird zun\u00e4chst ein char -Array erzeugt (Zeile 1 ) und initialisiert (Zeilen 2 bis 5 ). Anschlie\u00dfend wird es ausgelesen Zeilen 6 bis 9 ). Es entsteht folgende Ausgabe: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z Success Wir k\u00f6nnen uns Arrays erzeugen und initialisieren. Wir k\u00f6nnen Werte in diesen Arrays \u00e4ndern und aus den Arrays auslesen. Wir kennen die length -Variable von Arrays und k\u00f6nnen den Index verwenden, um auf die einzelnen Elemente zuzugreifen. N\u00e4chste Woche geht es mit Arrays weiter! Algorithmen \u00fcber Arrays \u00b6 Wir werden uns mit verschiedenen Algorithmen besch\u00e4ftigen, die alle Arrays zur Grundlage haben. Wir beginnen zur Auffrischung mal mit einer kleinen \u00dcbung. Wir wollen ein Array erstellen, in dem die Fibonacci-Folge enthalten ist. Diese geht so, dass das erste Element den Wert 0 hat und das zweite Element den Wert 1 und alle nachfolgenden Elemente als Wert die Summe der Werte ihrer beiden Vorg\u00e4nger hat, also 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ... . Ausgangspunkt ist also etwas in der folgenden Art: public static void main ( String [] args ) { int length = 20 ; int [] fibonacci = new int [ length ] ; fibonacci [ 0 ] = 0 ; fibonacci [ 1 ] = 1 ; } Bef\u00fcllen Sie den Rest des fibonacci -Arrays! public static void main ( String [] args ) { int length = 20 ; int [] fibonacci = new int [ length ] ; fibonacci [ 0 ] = 0 ; fibonacci [ 1 ] = 1 ; for ( int index = 2 ; index < fibonacci . length ; index ++ ) { fibonacci [ index ] = fibonacci [ index - 1 ] + fibonacci [ index - 2 ] ; } } Wir wollen dieses Array nun mehrfach verwenden, um anhand von Beispielen einige Algorithmen \u00fcber Arrays kennenzulernen. Beachten Sie, dass wir f\u00fcr das fibonacci -Array die L\u00e4nge auf 20 festgesetzt hatten. Dies k\u00f6nnen wir aber problemlos \u00e4ndern und deutlich l\u00e4ngere fibonacci -Arrays erstellen. Alles, was wir dazu tun m\u00fcssen, ist den Wert von length zu \u00e4ndern. Beachten Sie au\u00dferdem, dass length eine von uns erzeugte Variable ist, aber fibonacci.length eine Variable des Arrays (deren Wert wir nicht \u00e4ndern, sondern nur auslesen k\u00f6nnnen). Methoden mit Arrays als Parameter \u00b6 Wir werden uns einige Methoden erstellen, um z.B. ein als Parameter \u00fcbergebenes Array auszugeben oder einige Berechnungen \u00fcber die Werte des Arrays durchzuf\u00fchren. Wir beginnen damit, uns eine Methode zu schreiben, die ein als Parameter \u00fcbergebenes Array auf die Konsole ausgibt. Ausgabe der Werte auf die Konsole \u00b6 Zun\u00e4chst wollen wir alle Werte nur durch Leerzeichen getrennt auf die Konsole ausgeben. Die dazugeh\u00f6rige Methode sieht so aus: 1 2 3 4 5 6 7 8 public static void printArray ( int [] a ) { for ( int index = 0 ; index < a . length ; index ++ ) { System . out . print ( a [ index ] + \" \" ); } System . out . println (); } Wir \u00fcbergeben also ein int[] -Array als Parameter und durchlaufen es in einer Schleife vollst\u00e4ndig von index=0 bis index=a.length-1 und geben alle Werte von a[index] auf die Konsole durch Leerzeichen getrennt aus. Wenn wir nun in main() printArray(fibonacci); aufrufen, bekommen wir folgende Ausgabe: 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 Jetzt wollen wir die Ausgabe \u00e4ndern. Das Array soll in folgender Form ausgegeben werden: [ 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 , 89 , 144 , 233 , 377 , 610 , 987 , 1597 , 2584 , 4181 ] Das hei\u00dft, die Werte sollen alle innerhalb von eckigen Klammern erscheinen und die Werte sind durch Komma getrennt. Das Hauptproblem dabei ist, dass nach dem letzten Wert kein Komma ausgegeben werden soll. Angenommen, wir \u00e4ndern obigen Code nur geringf\u00fcgig: 1 2 3 4 5 6 7 8 9 public static void printArray ( int [] a ) { System . out . print ( \"[ \" ); for ( int index = 0 ; index < a . length ; index ++ ) { System . out . print ( a [ index ] + \", \" ); } System . out . println ( \" ]\" ); } dann h\u00e4tten wir eine Ausgabe in der Form: [ 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 , 89 , 144 , 233 , 377 , 610 , 987 , 1597 , 2584 , 4181 , ] Wir h\u00e4tten also schonmal die eckigen Klammern, aber nach dem letzten Wert k\u00e4me noch ein Komma. Deshalb lassen wir nun die Schleife nur noch bis index<a.length-1 laufen und behandeln das letzte Element extra. Welchen Index hat das letzte Element von a ? Wir kennen die L\u00e4nge nicht, wir kennen aber a.length . Das letzte Element hat den Index a.length-1 , d.h. der gr\u00f6\u00dfte Index ist stets die L\u00e4nge des Arrays minus 1. Wir k\u00f6nnten die Methode also so schreiben: 1 2 3 4 5 6 7 8 9 10 public static void printArray ( int [] a ) { System . out . print ( \"[ \" ); for ( int index = 0 ; index < a . length - 1 ; index ++ ) { System . out . print ( a [ index ] + \", \" ); } System . out . print ( a [ a . length - 1 ] ); System . out . println ( \" ]\" ); } Jetzt gibt es nur noch ein kleines Problem: Was passiert, wenn die L\u00e4nge des Arrays 0 ist, das als Parameter \u00fcbergebene Array also gar keine Elemente besitzt? Ein solches Array lie\u00dfe sich z.B. durch int [] arr1 = new int [ 0 ] ; int [] arr2 = {}; erzeugen. Wenn a die L\u00e4nge 0 h\u00e4tte, dann w\u00fcrden wir mit a[a.length-1] auf das Element von a mit dem Index -1 zugreifen wollen und ein solches Element/ein solcher Index existiert nicht. Es w\u00fcrde eine ArrayIndexOutOfBounds -Exception geworfen werden. Um sich dagegen zu sch\u00fctzen, pr\u00fcfen wir vor diesem Zugriff noch, ob die L\u00e4nge gr\u00dfer als 0 ist: 1 2 3 4 5 6 7 8 9 10 11 12 13 public static void printArray ( int [] a ) { System . out . print ( \"[ \" ); for ( int index = 0 ; index < a . length - 1 ; index ++ ) { System . out . print ( a [ index ] + \", \" ); } if ( a . length > 0 ) { System . out . print ( a [ a . length - 1 ] ); } System . out . println ( \" ]\" ); } Was wird ausgegeben, wenn a die L\u00e4nge 0 hat? [ ] Schreiben Sie die obige Methode so, dass die Ausgabe nicht auf der Konsole erfolgt, sondern der Ausgabe-String zur\u00fcckgegeben wird! public static String getOutputStringOfArray ( int [] a ) { String s = \"[ \" ; for ( int index = 0 ; index < a . length - 1 ; index ++ ) { s = s + a [ index ] + \", \" ; } if ( a . length > 0 ) { s = s + a [ a . length - 1 ] + \" ]\" ; } return s ; } Maximumwert ermitteln \u00b6 Angenommen, wir bekommen ein int[] -Array als Parameter \u00fcbergeben und sollen den gr\u00f6\u00dften Wert innerhalb dieses Arrays ermitteln (und zur\u00fcckgeben). Eine Idee f\u00fcr einen solchen Algorithmus w\u00e4re: wir merken uns das aktuelle Maximum in einer Variablen wir laufen durch das Array durch und immer wenn der aktuelle Wert im Array gr\u00f6\u00dfer ist, als unser aktuelles Maximum, speichern wir den Wert als (neues) aktuelles Maximum wenn wir vollst\u00e4ndig durch das Array durchgelaufen sind, haben wir den gr\u00f6\u00dften Wert als aktuelles Maximum gespeichert und k\u00f6nnen ihn zur\u00fcckgeben Eine solche Implementierung k\u00f6nnte so aussehen: 1 2 3 4 5 6 7 8 9 10 11 12 public static int getMaximum ( int [] a ) { int currentMaximum = 0 ; for ( int index = 0 ; index < a . length ; index ++ ) { if ( a [ index ]> currentMaximum ) { currentMaximum = a [ index ] ; } } return currentMaximum ; } Das sieht zun\u00e4chst exakt wie die Implementierung des oben beschriebenen Algorithmus' aus. In Zeile 3 erstellen wir unsere Variable currentMaximum , mit der wir uns das aktuelle Maximum speichern wollen. Mit der for -Schleife laufen wir durch alle Elemente unseres Arrays (Zeile 4 ) und wenn ein Wert aus dem Array gr\u00f6\u00dfer ist als das bis dahin gespeicherte Maximum (Zeile 6 ), speichern wir den Wert des Elements als neues Maximum (Zeile 8 ). Nach dem Verlassen der for -Schleife ist der gr\u00f6\u00dfte Wert in currentMaximum gespeichert und kann zur\u00fcckgegeben werden. Wir testen das mal in main() mit unserer Fibonacci-Folge und rufen System.out.println(getMaximum(fibonacci)); auf. Wir erhalten: 4181 Es scheint also zu funktionieren. Wir haben jedoch ein Problem: Was passiert, wenn die Werte in a alle negativ sind? Dann w\u00fcrde der Vergleich in Zeile 6 nie true sein und currentMaximum nie den Wert \u00e4ndern, da der initiale Wert von currentMaximum gr\u00f6\u00dfer als alle Werte aus dem Array ist. Wir m\u00fcssen also etwas am initialen Wert von currentMaximum \u00e4ndern. Eine Idee ist, dass wir currentMaximum mit dem ersten Wert aus dem a -Array initialisieren: 1 2 3 4 5 6 7 8 9 10 11 12 public static int getMaximum ( int [] a ) { int currentMaximum = a [ 0 ] ; for ( int index = 1 ; index < a . length ; index ++ ) { if ( a [ index ]> currentMaximum ) { currentMaximum = a [ index ] ; } } return currentMaximum ; } Dann m\u00fcssen wir beim Schleifendurchlauf nur noch alle Elemente betrachten, deren Index >=1 ist, da wir das Element mit dem Index 0 (das erste Element aus a ) bereits bei der Initialisierung von currentMaximum betrachtet haben. Nun funktioniert unsere Methode auch f\u00fcr Arrays, die nur negative Werte enthalten. Ein Problem bleibt noch: Was passiert, wenn das Array a leer ist, also eine L\u00e4nge von 0 hat? Dann k\u00f6nnen wir n\u00e4mlich auch nicht a[0] aufrufen, da dieses Element (der Index 0 ) nicht existiert. Wir bek\u00e4men eine ArrayIndexOutOfBounds -Exception. Hierbei stellt sich die grunds\u00e4tzliche Frage, was durch unsere Methode zur\u00fcckgegeben werden soll, wenn das \u00fcbergebene Array gar kein Maximum hat, n\u00e4mlich dann, wenn es leer ist? Darauf gibt es keine befriedigende Antwort. W\u00fcr m\u00fcssen ein int zur\u00fcckgeben, aber kein int aus dem Wertebereich w\u00e4re korrekt. Grunds\u00e4tzlich sollte so etwas vor Aufruf der Methode gepr\u00fcft werden. Wir k\u00f6nnten uns z.B. eine Methode isEmpty() schreiben: public static boolean isEmpty ( int [] a ) { return ( a . length == 0 ); } Diese Methode gibt true zur\u00fcck, wenn das Array a leer ist (also die L\u00e4nge 0 ) hat und false sonst. Diese Methode kann man f\u00fcr den Aufruf von getMaximum() verwenden: if ( ! isEmpty ( arr1 )) { int maximum = getMaximum ( arr1 ); } Das hei\u00dft, wir rufen die Methode getMaximum() f\u00fcr ein Array nur dann auf, wenn wir wissen, dass dieses Array nicht leer ist. Dann arbeitet unsere Methode n\u00e4mlich korrekt - und nur dann. Zwei Arrays auf Gleichheit pr\u00fcfen \u00b6 Wir wollen eine Methode schreiben, die \u00fcberpr\u00fcft, ob 2 Arrays gleich sind - also vollst\u00e4ndig gleiche Werte enthalten. Z.B. sollen diese Arrays gleich sein: int [] arr1 = { 8 , 9 , 2 , 3 , 7 , 4 , 1 , 0 , 9 , 6 }; int [] arr2 = { 8 , 9 , 2 , 3 , 7 , 4 , 1 , 0 , 9 , 6 }; aber int [] arr3 = { 8 , 9 , 2 , 3 , 7 , 5 , 1 , 0 , 9 , 6 }; ist ungleich zu arr1 und arr2 , da arr3 an 6. Stelle den Wert 5 statt 4 hat. Die algorithmische Idee ist: wir laufen gleichzeitig durch beide Arrays durch solange die Werte bei gleichem Index gleich sind, machen wir weiter sobald zwei Werte bei gleichem Index ungleich sind, wissen wir, dass die Arrays ungleich sind wenn wir alle Elemente betrachtet haben und alle waren gleich, dann sind auch unsere Arrays gleich 1 2 3 4 5 6 7 8 9 10 11 12 public static boolean areEqual ( int [] a , int [] b ) { boolean areEqual = true ; for ( int index = 0 ; index < a . length ; index ++ ) { if ( a [ index ]!= b [ index ] ) { areEqual = false ; } } return areEqual ; } Diese Methode setzt unseren Algorithmus um und wenn wir die Methode mit den obigen Arrays testen System . out . println ( areEqual ( arr1 , arr2 )); System . out . println ( areEqual ( arr1 , arr3 )); , dann wird auch korrekt true false ausgegeben. Doch was passiert, wenn wir die Methode f\u00fcr diese beiden Arrays aufrufen: int [] arr4 = { 8 , 9 , 2 }; int [] arr5 = { 8 , 9 , 2 , 3 }; Welcher Wert wird bei Aufruf System.out.println(areEqual(arr4, arr5)); ausgegeben? true Wollen wir das? Welcher Wert wird bei Aufruf System.out.println(areEqual(arr5, arr4)); ausgegeben? keiner, sondern Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3 Warum? Grunds\u00e4tzlich sollte es bei einer solchen Methode egal sein, welche Reihenfolge die \u00fcbergebenen Arrays in der Parameterliste haben, d.h. areEqual(arr4, arr5) und areEqual(arr5, arr4) sollten den gleichen Wert zur\u00fcckliefern, denn entweder sind sie gleich true oder sie sind es nicht false . Die Gleichheit ist eine symmetrische Relation . Was ist das Problem unserer bisherigen L\u00f6sung? Wir durchlaufen die Schleife auch dann, wenn die Arrays unterschiedliche L\u00e4nge haben. In dem Aufruf areEqual(arr4, arr5) wird das letzte Element von arr5 gar nicht mehr gepr\u00fcft, da der index in der Schleife nur bis arr4.length-1 l\u00e4uft. In dem Aufruf areEqual(arr5, arr4) wird versucht, das letzte Element von arr5 mit einem Element von arr4 zu vergleichen, das gar nicht existiert. Der Zugriff auf arr4[3] f\u00fchrt zu einer ArrayIndexOutOfBoundsException . Wir werden deshalb zun\u00e4chst pr\u00fcfen, ob die beiden Arrays \u00fcberhaupt gleich lang sind und nur dann durchlaufen wir die beiden Arrays: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public static boolean areEqual ( int [] a , int [] b ) { boolean areEqual = true ; if ( a . length != b . length ) { areEqual = false ; } for ( int index = 0 ; index < a . length && areEqual ; index ++ ) { if ( a [ index ]!= b [ index ] ) { areEqual = false ; } } return areEqual ; } Au\u00dferdem haben wir in die for -Schleife die Bedingung um && areEqual erweitert. Das hat zwei Gr\u00fcnde: erstens betreten wir die for -Schleife dann gar nicht, wenn die beiden Arrays unterschiedliche L\u00e4ngen haben, denn dann ist areEqual==fasle und somit ist die gesamte Bedingung index < a.length && areEqual false . \u2192 das ist also notwendig, um korrekt zu sein (wir k\u00f6nnten auch die for -Schleife in den else -Block der Selektion packen) zweitens beenden wir das Durchlaufen der for -Schleife sofort, wenn wir ungleiche Elemente gefunden haben, denn dann setzen wir ja auch areEqual auf false . Es gen\u00fcgt ja, zwei ungleiche Elemente zu finden, dann sind die Arrays ungleich und wir m\u00fcssen gar nicht weiter suchen. \u2192 das ist also nicht notwendig, aber performanter Zur \u00dcbung mit einem Array als Parameter k\u00f6nnen Sie: Bestimmen Sie die Summe aller Werte eines int -Arrays, welches als Parameter der Methode \u00fcbergeben wird. Geben Sie die Summe zur\u00fcck. public static int getSumme ( int [] a ) { int sum = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { sum += a [ i ] ; } return sum ; } Bestimmen Sie den Durchschnitt/Mittelwert aller Werte eines int -Arrays, welches als Parameter der Methode \u00fcbergeben wird. Geben Sie den Durchschnitt zur\u00fcck zur\u00fcck. public static double getAverage ( int [] a ) { /* * diese Aufgabe ist leider komplizierter, da wir * das Problem haben, dass getSumme(a) ein int * zurueckliefert und a.length ebenfalls ein int ist * und wir somit int / int rechnen, also eine * ganzzahlige Division durchf\u00fchren * Mithilfe des Typkonvertierungsoperators (double) * k\u00f6nnen wir aber aus einem int ein double machen, * z.B. wird mit (double)a.length aus der Laenge ein * double * int / double ist eine Gleitkommadivision * Probieren Sie es einmal ohne (double) und * einmal mit (double) aus */ double average = getSumme ( a ) / ( double ) a . length ; return average ; } Methoden mit Array als R\u00fcckgabe \u00b6 Wir betrachten nun Methoden, die ein Array zur\u00fcckgeben. Wir fangen an mit einer Methode, der eine int length \u00fcbergeben wird und die damit ein int[] der L\u00e4nge length erzeugt und dieses Array mit Zufallszahlen bef\u00fcllt: 1 2 3 4 5 6 7 8 9 10 public static int [] createAndFillArray ( int length ) { int [] a = new int [ length ] ; Random r = new Random (); for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ]= r . nextInt (); } return a ; } Betrachten wir die Methode genauer: in Zeile 3 wird eine Variable a vom Typ int[] deklariert und ein int[] -Array der L\u00e4nge length erzeugt. Die Variable a zeigt auf dieses neu erzeugte Array. in Zeile 4 erzeugen wir ein Random -Objekt und die Referenzvariable r vom Typ Random zeigt auf dieses Objekt. Beachten Sie, dass Sie die Klasse Random aus dem java.util -Paket importieren m\u00fcssen! in den Zeilen 5-8 laufen wir durch das Array durch und belegen jedes Element mit einer Zufallszahl indem wir r.nextInt() aufrufen. in Zeile 9 wird das Array zur\u00fcckgegeben. Aufruf der Methode in main() (oder einer anderen Methode): int [] arr6 = createAndFillArray ( 5 ); printArray ( arr6 ); Wir rufen die Methode mit einem Wert 5 f\u00fcr length auf. Das bedeutet, dass die Methode ein Array der L\u00e4nge 5 erzeugt und mit Zufallszahlen bef\u00fcllt. Das zur\u00fcckgegebene Arry speichern wir in der Variablen arr6 , die ebenfalls vom Typ int[] ist. Wir geben das Array mithilfe der von uns erzeugten Methode printArray(arr6); aus (wir h\u00e4tten auch direkt printArray(createAndFillArray(5)); aufrufen k\u00f6nnen, dann h\u00e4tten wir das erzeugte Array aber nirgendwo gespeichert). Es erscheint z.B. eine Ausgabe wie: [ 1463666318 , -2121738539, -1174806146, 337579240 , -108604609 ] Wenn wir den Wertebereich der zuf\u00e4llig erzeugten Zahlen eingrenzen m\u00f6chten, z.B. nur Werte aus dem Bereich [0, 1, ..., 19] , k\u00f6nnen wir die nextInt(int bound) -Methode von Random verwenden ( siehe ). Wir erweitern die Methode createAndFillArray() um einen solchen bound -Parameter: 1 2 3 4 5 6 7 8 9 10 public static int [] createAndFillArray ( int length , int bound ) { int [] a = new int [ length ] ; Random r = new Random (); for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ]= r . nextInt ( bound ); } return a ; } Beachten Sie, dass bei nextInt(int bound) der Wert von bound exklusiv ist, d.h. dieser Wert gibt die erste Zahl an, die nicht mehr zuf\u00e4llig erzeugt wird. Wenn wir also zuf\u00e4llig Zahlen aus dem Bereich [0, 1, ..., 19] erzeugen wollen, dann muss bound=20 sein. Der Aufruf von int [] arr7 = createAndFillArray ( 10 , 20 ); printArray ( arr7 ); erzeugt dann z.B. eine solche Ausgabe (bei Ihnen nat\u00fcrlich anders - sind ja Zufallszahlen): [ 2 , 17 , 7 , 5 , 17 , 3 , 19 , 8 , 6 , 18 ] Array kopieren \u00b6 Wir erstellen eine Methode, der ein Array als Parameter \u00fcbergeben wird und die davon eine Kopie erstellt und diese Kopie zur\u00fcckgibt. 1 2 3 4 5 6 7 8 9 10 public static int [] copyArray ( int [] original ) { int length = original . length ; int [] copy = new int [ length ] ; for ( int index = 0 ; index < length ; index ++ ) { copy [ index ] = original [ index ] ; } return copy ; } in Zeile 1 wird das Original-Array \u00fcbergeben und in der Referenzvariablen original gespeichert, in Zeile 3 erstellen wir uns eine Variable length vom Typ int , in der die L\u00e4nge des Original-Arrays gespeichert wird, in Zeile 4 wird das copy -Array erstellt, das genau so lang ist, wie das Original, In den Zeilen 5-8 kopieren wir jeden einzelnen Wert aus dem Original-Array in das copy -Array (elementweise), in Zeile 9 geben wir das copy -Array zur\u00fcck 1 Der Aufruf der Methode, z.B. int [] original = createAndFillArray ( 10 , 20 ); System . out . print ( \"original : \" ); printArray ( original ); int [] copy = copyArray ( original ); System . out . print ( \"copy : \" ); printArray ( copy ); erzeugt folgende Ausgabe (Zufallszahlen): original : [ 2 , 2 , 5 , 19 , 19 , 6 , 1 , 1 , 4 , 8 ] copy : [ 2 , 2 , 5 , 19 , 19 , 6 , 1 , 1 , 4 , 8 ] Angenommen, wir \u00fcbergeben unserer Methode nicht nur das Original-Array, sondern auch eine L\u00e4nge, bis zu der das Original-Array kopiert werden soll. Der Methodenkopf w\u00fcrde dann also so aussehen: public static int [] copyArray ( int [] original , int newLength ) Dann gibt es 3 verschiedene Varianten: Original-Array und Kopie des Arrays gleich lang (wenn newLength == original.length ) Original-Array k\u00fcrzer als Kopie (z.B. falls Original-Array zu klein geworden ist, um weitere Elemente einzuf\u00fcgen; wenn newLength > original.length ) Original-Array l\u00e4nger als Kopie (falls nur ein Teil kopiert werden soll; wenn newLength < original.length ) Wir f\u00fcgen in unsere Methode eine entsprechende Fallunterscheidung ein: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public static int [] copyArray ( int [] original , int newLength ) { int [] copy = new int [ newLength ] ; if ( original . length <= newLength ) { for ( int index = 0 ; index < original . length ; index ++ ) { copy [ index ]= original [ index ] ; } } else { for ( int index = 0 ; index < copy . length ; index ++ ) { copy [ index ]= original [ index ] ; } } return copy ; } in Zeile 1 wurde der neue Parameter newLength hinzugef\u00fcgt, der die L\u00e4nge des copy -Arrays bestimmt, in Zeile 3 wird das copy -Array mit der L\u00e4nge newLength erzeugt, in Zeile 4 erfolgt die Fallunterscheidung: falls die Kopie mindestens so lang ist wie das Original, werden alle Elemente aus dem Original in die Kopie kopiert (Zeilen 6-9 ) \u2192 Beachten Sie Verwendung von original.length in der Bedingung der for -Schleife, falls die Kopie k\u00fcrzer ist als das Original, werden nur die ersten newLength Elemente aus dem Original-Array kopiert (Zeilen 13-16 ) \u2192 Beachten Sie Verwendung von copy.length in der Bedingung der for -Schleife, Bei dem Aufruf von int [] original = createAndFillArray ( 10 , 20 ); // Original Laenge 10 System . out . print ( \"original : \" ); printArray ( original ); int [] copy = copyArray ( original , 8 ); // Kopie Laenge 8 System . out . print ( \"copy : \" ); printArray ( copy ); erfolgt folgende Ausgabe (Zufallszahlen): original : [ 8 , 13 , 11 , 4 , 7 , 2 , 5 , 1 , 15 , 5 ] copy : [ 8 , 13 , 11 , 4 , 7 , 2 , 5 , 1 ] Bei dem Aufruf von int [] original = createAndFillArray ( 10 , 20 ); // Original Laenge 10 System . out . print ( \"original : \" ); printArray ( original ); int [] copy = copyArray ( original , 18 ); // Kopie Laenge 18 System . out . print ( \"copy : \" ); printArray ( copy ); erfolgt folgende Ausgabe (Zufallszahlen): original : [ 1 , 18 , 0 , 9 , 12 , 18 , 2 , 8 , 17 , 12 ] copy : [ 1 , 18 , 0 , 9 , 12 , 18 , 2 , 8 , 17 , 12 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] Beachten Sie, dass Elementen, denen kein Wert zugewiesen wurde, den Wert 0 haben (Standardwert von int ). Array verketten \u00b6 Wir erstellen eine Methode, der zwei Arrays als Parameter \u00fcbergeben werden und die daraus ein neues Array erstellt, welche alle Elemente des einen und alle Elemente des anderen Arrays enth\u00e4lt. Die algorithmische Idee dabei ist wie folgt: Array a und Array b aneinanderh\u00e4ngen: neues Array c erzeugen (die L\u00e4nge von c ergibt sich aus a.length + b.length ), Elemente von a nach c kopieren (bis Index a.length-1 ), Elemente von b nach c kopieren (ab Index a.length ), c zur\u00fcckgeben Die folgende Abbildung verdeutlicht ein Beispiel mit a.length==6 und b.length==4 . Es wird ein Array c mit L\u00e4nge 10 erzeugt. In die ersten 6 Elemente von c werden die Werte von a kopiert und in die folgenden 4 Elemente die Werte von b . Beachten Sie, dass in dem Beispiel z.B. c[6]=b[0] kopiert wird. Eine m\u00f6gliche Methode k\u00f6nnte so aussehen: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public static int [] concatArrays ( int [] a , int [] b ) { int [] c = new int [ a . length + b . length ] ; for ( int index = 0 ; index < a . length ; index ++ ) { c [ index ] = a [ index ] ; } for ( int index = 0 ; index < b . length ; index ++ ) { c [ index + a . length ] = b [ index ] ; } return c ; } Wichtig ist hier, unbedingt zu verstehen, warum wir innerhalb der zweiten for -Schleife c[index+a.length] = b[index]; verwenden! Suchen in Arrays \u00b6 Bei der Suche in Arrays geht es darum, einen bestimmten Wert zu finden, der im Array enthalten ist (oder er wird nicht gefunden, falls er nicht im Array existiert.) Grunds\u00e4tzlich m\u00fcssen wir zwischen der Suche in unsortierten und sortierten Arrays unterscheiden. In sortierten Arrays sind die Elemente alle hinsichtlich ihrer Werte geordnet, also z.B. numerisch bei Zahlen oder alphanumerisch bei Zeichen und Zeichenketten. Wir beginnen mit der Suche in unsortierten Arrays. Suche in unsortierten Arrays \u00b6 Wir wollen eine Methode erstellen, der ein Array \u00fcbergeben wird und ein Element gleichen Typs. Die Methode soll ein true zur\u00fcckgeben, wenn das Element in dem Array enthalten ist und ein false , wenn nicht. Die Idee dabei ist wir durchlaufen das Array solange, bis wir entweder das Element gefunden haben \u2192 dann k\u00f6nnen wir die Suche beenden und ein true zur\u00fcckgeben oder wir am Ende des Arrays angekommen sind und das Element nicht gefunden haben \u2192 dann geben wir ein false zur\u00fcck Eine solche Methode k\u00f6nnte so aussehen: public static boolean contains ( int [] a , int element ) { boolean found = false ; for ( int index = 0 ; index < a . length && ! found ; index ++ ) { if ( a [ index ]== element ) { found = true ; } } return found ; } Wir pr\u00fcfen also, ob element als Wert in a enthalten ist. in Zeile 3 definieren wir uns eine Variable found , deren Wert initial auf false gesetzt wird ( element noch nicht gefunden) in Zeilen 4-10 durchlaufen wir das Array, entweder so lange bis wir das element gefunden haben (Zeilen 6-9 ) \u2192 found==true oder bis wir das Ende des Arrays erreicht haben ( index==a.length ) \u2192 found==false in Zeile 11 geben wir den Wert von found zur\u00fcck Beachten Sie, dass es wichtig ist, dass found initial den Wert false bekommt und dass die Schleife sofort verlassen wird, sobald wir das Element gefunden haben (Schleifen bedingung && !found ). Wir bleiben bei der Suche in unsortierten Arrays. Jetzt soll unsere Methode aber den Index zur\u00fcckgeben, an dem das Element im Array enthalten ist. Wir wissen, dass der Index nur Werte zwischen 0 und array.length-1 annehmen kann, also nur positive Werte. Wenn das Element nicht im Array enthalten ist, dann geben wir eine -1 zur\u00fcck. Hierbei sind zwei Sachen zu beachten: Erstens sollten wir solche \"Codierungen\" von R\u00fcckgabewerten vermeiden. Die aufrufende Methode muss ja \"wissen\", dass ein negativer R\u00fcckgabewert bedeutet, dass das Element gar nicht im Array enthalten ist. Auf der anderen Seite m\u00fcssen wir aber ein int zur\u00fcckgeben. Im Gegensatz zur getMaximum() -Methode oben, gibt es hier jedoch zumindest eine \"L\u00f6sung\" f\u00fcr das Problem, dass das Element nicht enthalten ist. Trotzdem sollte man auf jeden Fall zun\u00e4chst contains() aufrufen und nur, wenn contains() ein true zur\u00fcckliefert, dann die getIndex() -Methode. Zweitens ist die -1 eine sogenannte magic number . Wir sollten ihr einen Namen geben. Wir betrachten die Methode zun\u00e4chst ohne einen Namen f\u00fcr die -1 : 1 2 3 4 5 6 7 8 9 10 11 12 public static int getIndex ( int [] a , int element ) { int indexAtElement = - 1 ; for ( int index = 0 ; index < a . length ; index ++ ) { if ( a [ index ]== element ) { indexAtElement = index ; } } return indexAtElement ; } Wir durchlaufen das Array und sobald wir das element \"finden\" (Zeile 6 ), merken wir uns den aktuellen Index (Zeile 8 ). Am Ende wird der gemerkte Index zur\u00fcckgegeben (Zeile 11 ). Wenn Zeile 8 nie ausgef\u00fchrt wurde, dann wird der initiale Wert von indexAtElement zur\u00fcckgegeben, n\u00e4mlich -1 . Diese -1 ist eine sogenannte magic number . Man kennt die Bedeutung dieses Wertes nicht. Es ist deshalb besser, daf\u00fcr einen Namen einzuf\u00fchren - als Konstante (zu Konstanten siehe hier ). 1 2 3 4 5 6 7 8 9 10 11 12 13 public static int getIndex ( int [] a , int element ) { final int NOT_FOUND = - 1 ; int indexAtElement = NOT_FOUND ; for ( int index = 0 ; index < a . length ; index ++ ) { if ( a [ index ]== element ) { indexAtElement = index ; } } return indexAtElement ; } Eine Konstante ist eine Variable, die genau einmal einen Wert zugewiesen bekommt (initailisiert wird) und deren Wert nie wieder \u00fcberschrieben werden kann. Die Namen von Konstanten schreiben wir durchgehend GROSS. Angenommen, das element kommt mehrmals im Array a vor. Wird der erste Index des Auftretens von element im Array zur\u00fcckgegeben oder der letzte Index? Wie k\u00f6nnte man das \u00e4ndern? Der letzte. Man k\u00f6nnte beim ersten Finden des Elementes die Schleife sofort verlassen (aber nicht break; verwenden!) Suche in sortierten Arrays \u00b6 In sortierten Arrays sucht es sich etwas schneller nach einem element . Daf\u00fcr gibt es zwei Gr\u00fcnde: einerseits kann eine sequentielle Suche (also das Durchlaufen des Arrays) schneller abgebrochen werden, falls das Element nicht im Array enthalten ist, denn sobald man einen Wert im Array erreicht, der gr\u00f6\u00dfer ist, als der gesuchte Wert, kann das element ja gar nicht mehr vorkommen (falls das Array aufsteigend sortiert ist) andererseits kann man Algorithmen anwenden, die den Suchraum schnell einschr\u00e4nken, eine sogenannte bin\u00e4re Suche . Wir betrachten zun\u00e4chst die sequentielle Suche. Angenommen, wir haben folgendes aufsteigend sortiertes Array: [ 0 , 2 , 2 , 3 , 4 , 4 , 5 , 7 , 8 , 9 , 11 , 11 , 11 , 14 , 16 , 16 , 18 , 18 , 18 , 19 ] und angenommen, wir wollen pr\u00fcfen, ob die 10 im Array enthalten ist. In einem unsortierten Array m\u00fcssten wir das gesamte Array durchlaufen, um zu merken, dass die 10 nicht enthalten ist. Hier, bei dem sortierten Array, merken wir das schon, wenn wir die erste 11 gefunden haben, denn danach kann die 10 nicht mehr kommen. Die contains() -Methode kann also ein weiteres Abbruchkriterium der Suche enthalten: public static boolean containsSorted ( int [] aSorted , int element ) { boolean found = false ; boolean greater = false ; for ( int index = 0 ; index < aSorted . length && ! found && ! greater ; index ++ ) { if ( aSorted [ index ]== element ) { found = true ; } if ( aSorted [ index ]> element ) { greater = true ; } } return found ; } Im Vergleich zur contains() -Methode f\u00fcr unsortierte Arrays haben wir einen weiteren \"Schalter\" hinzugef\u00fcgt, greater . Damit haben wir auch die Bedingung in der for -Schleife erweitert ( && !greater ). Sollten wir das element noch nicht gefunden haben, der Wert aSorted[index] aber gr\u00f6\u00dfer als element sein (Zeile 11 ), setzen wir greater auf true und die Schleife wird verlassen. Funktioniert die contains() -Methode, die wir f\u00fcr unsortierte Arrays implementiert haben, auch f\u00fcr sortierte Arrays? Ja, wir nutzen nur die M\u00f6glichkeit des fr\u00fcheren Abbruchs der Suche nicht aus. Schreiben Sie eine Methode getIndexSorted(int[] aSorted, int element) , die den Index von element in a zur\u00fcckgibt (und sonst -1 ). Genau wie getIndex() f\u00fcr unsortierte Arrays, aber auch hier nutzen Sie die fr\u00fchere Abbruchm\u00f6glichkeit der Suche aus. public static int getIndexSorted ( int [] aSorted , int element ) { final int NOT_FOUND = - 1 ; boolean greater = false ; int indexAtElement = NOT_FOUND ; for ( int index = 0 ; index < aSorted . length && ! greater ; index ++ ) { if ( aSorted [ index ]== element ) { indexAtElement = index ; } if ( aSorted [ index ]> element ) { greater = true ; } } return indexAtElement ; } Bis jetzt sind wir immer sequenziell durch das Array durchgelaufen, also von vorne nach hinten, beginnend mit dem Index 0 bis wir bei array.length angekommen waren. In sortierten Arrays k\u00f6nnen wir das Prinzip \u00e4ndern: Wir fangen einfach in der Mitte des Arrays an und wenn der Wert, den wir suchen, kleiner ist, als der Wert in der Mitte, dann suchen wir links weiter und sonst suchen wir rechts weiter. Dann gehen wir mit der linken bzw. rechten H\u00e4lft egenau so vor usw. Diese Suche nennt sich bin\u00e4re Suche ( binary search ), in jedem Schritt wird der (verbliebene) Suchraum halbiert. Angenommen, wir suchen in dem folgenden Array die 25 : wir ermitteln zun\u00e4chst den Index, der in der Mitte des Arrays ist ( mid ). Dieser ergibt sich aus dem Mittelwert von lo (das ist der kleinste Index, der ist am Anfang 0 ) und hi (das ist der gr\u00f6\u00dfte Index, der ist am Anfang 14 , da unser Beispiel-Array die L\u00e4nge 15 hat). Unserer Index in der Mitte ist also mid=7 . Wir greifen \u00fcber diesen Index mid auf den Wert in dem Array zu; der Wert ist 34 . 34 ist gr\u00f6\u00dfer als die gesuchte 25 \u2192 wir suchen also in dem linken Teil des Arrays weiter. Wir ermitteln den gr\u00f6\u00dften Index hi in diesem Teil (der ist um 1 kleiner als mid davor, also 6 ). Der Wert von lo bleibt 0 . Der neue Wert von mid ist 3 . Wir greifen \u00fcber diesen Index mid auf den Wert in dem Array zu; der Wert ist 16 . 16 ist kleiner als die gesuchte 25 \u2192 wir suchen also in dem rechten Teil des Arrays weiter. Wir ermitteln den gr\u00f6\u00dften Index lo in diesem Teil (der ist um 1 gr\u00f6\u00dfer als mid davor, also 4 ). Der Wert von hi bleibt 6 . Der neue Wert von mid ist 5 . Wir greifen \u00fcber diesen Index mid auf den Wert in dem Array zu; der Wert ist 25 . Wir haben das Element gefunden. Ehe Sie sich die Implementierung der bin\u00e4ren Suche anschauen, sollten Sie in dem Beispiel aus dem Bild noch die 41 suchen. Achten Sie insbesondere darauf, wie sich die Werte von lo , mid und high in jedem Suchschritt \u00e4ndern. wir beginnen mit lo=0 , hi=14 und also mid=7 . Der Wert im Index 7 ist 34 und somit kleiner als die gesuchte 41 \u2192 wir suchen rechts weiter lo=8 , hi=14 und also mid=11 . Der Wert im Index 11 ist 46 und somit gr\u00f6\u00dfer als die gesuchte 41 \u2192 wir suchen links weiter lo=8 , hi=10 und also mid=9 . Der Wert im Index 9 ist 41 \u2192 gefunden Ehe Sie sich die Implementierung der bin\u00e4ren Suche anschauen, sollten Sie in dem Beispiel aus dem Bild noch die 42 suchen. Wann stellen Sie fest, dass die 42 nicht im Array enthalten ist? wir beginnen mit lo=0 , hi=14 und also mid=7 . Der Wert im Index 7 ist 34 und somit kleiner als die gesuchte 42 \u2192 wir suchen rechts weiter lo=8 , hi=14 und also mid=11 . Der Wert im Index 11 ist 46 und somit gr\u00f6\u00dfer als die gesuchte 42 \u2192 wir suchen links weiter lo=8 , hi=10 und also mid=9 . Der Wert im Index 9 ist 41 und somit kleiner als die gesuchte 42 \u2192 wir suchen rechts weiter lo=10 , hi=10 und also mid=10 . Der Wert im Index 10 ist 46 \u2192 nicht gefunden ( hi und lo haben den gleichen Wert \u2192 zu Ende) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public static boolean containsBinarySearch ( int [] aSorted , int element ) { boolean found = false ; int lo = 0 ; int hi = aSorted . length - 1 ; while ( lo <= hi && ! found ) { int mid = ( hi + lo ) / 2 ; if ( element == aSorted [ mid ] ) // gefunden { found = true ; } else // nicht gefunden { if ( element < aSorted [ mid ] ) // links weitersuchen { hi = mid - 1 ; } else // element > aSorted[mid] rechts weitersuchen { lo = mid + 1 ; } } } return found ; } in Zeile 4 wir die lo -Variable mit dem Index-Wert 0 initialisiert (kleinster Index), in Zeile 5 wir die hi -Variable mit dem Index-Wert aSorted.length-1 initialisiert (gr\u00f6\u00dfter Index), in Zeile 6 steht die Bedingung, wie lange die Suche fortgesetzt werden soll: solange das Element noch nicht gefunden wurde ( !found ) oder solange der kleinere Index lo kleiner (gleich) hi ist; falls element nicht gefunden wurde in Zeile 8 steht die Berechnung des mittleren Index mid . Beachten Sie, dass es sich um eine Integer-Division handelt. Es k\u00f6nnte also auch sein, dass die Summe von lo und hi ungerade ist, aber selbst dann ist mid eine ganze positive Zahl wenn das element gefunden wird (Bedingung in Zeile 9 ist true ), dann wird found auf true gesetzt und die while -Schleife wird verlassen wenn links weiter gesucht wird (Bedingung in Zeile 15 ist true ), dann wird hi neu gesetzt und die Schleifenbedingung erneut gepr\u00fcft wenn rechts weiter gesucht wird (Bedingung in Zeile 15 ist false ), dann wird lo neu gesetzt und die Schleifenbedingung erneut gepr\u00fcft zur\u00fcckgegeben (Zeile 25 ) wird true , wenn das element gefunden wurde (Zeilen 9-12 oder false , wenn es nicht gefunden wurde - initialer Wert von found ) Implementieren Sie eine getIndexBinarySearch() -Methode unter Verwendung des Prinzips der bin\u00e4ren Suche! public static int getIndexBinarySearch ( int [] aSorted , int element ) { boolean found = false ; final int NOT_FOUND = - 1 ; int indexAtElement = NOT_FOUND ; int lo = 0 ; int hi = aSorted . length - 1 ; while ( lo <= hi && ! found ) { int mid = ( hi + lo ) / 2 ; if ( element == aSorted [ mid ] ) // gefunden { found = true ; indexAtElement = mid ; } else // nicht gefunden { if ( element < aSorted [ mid ] ) // links weitersuchen { hi = mid - 1 ; } else // element > aSorted[mid] rechts weitersuchen { lo = mid + 1 ; } } } return indexAtElement ; } Nur zur Info : Mithilfe der bin\u00e4ren Suche ist die Suche nach einem Element in einem sortierten Array enorm beschleunigt. Unter der Komplexit\u00e4t eines Algorithmus wird der Bedarf des Algorithmus an den zur Verf\u00fcgung stehenden Ressourcen Laufzeit (wie schnell?) \u2192 sogenannte Zeitkomplexit\u00e4t Speicherplatz (wie viel Speicherplatz n\u00f6tig?) \u2192 sogenannte Speicherkomplexit\u00e4t verstanden. Die Komplexit\u00e4t eines Algorithmus in Abh\u00e4ngigkeit von der Gr\u00f6\u00dfe n der von ihm bearbeiteten Daten ausgedr\u00fcckt. Daf\u00fcr hat sich die Landau-Notation durchgesetzt. Diese beschreibt mit O(n) sogenannte Komplexit\u00e4tsklassen . Beispielsweise wird die Verkettung von zwei Arrays der L\u00e4nge n und m mit der Komplexit\u00e4tsklasse O(n+m) angegeben (maximale Zeit- und Speicherkomplexit\u00e4t), w\u00e4hrend die Komplexit\u00e4tsklasse der sequentiellen Suche in unsortierten und sortierten Arrays O(n) ist und die bin\u00e4re Suche in sortierten Arrays O(log n) . Wir messen im Folgenden einmal den Zeitverbrauch der Methoden getIndex() , getIndexSorted() und getIndexBinarySearch() unter Verweung der Klassen Instant und Duration aus dem Paket java.time : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int [] test = createAndFillArray ( 100000000 , 10000000 ); Arrays . sort ( test ); Instant start = Instant . now (); int index = getIndex ( test , 80000000 ); Instant finish = Instant . now (); long duration = Duration . between ( start , finish ). toMillis (); System . out . println ( \"index : \" + index + \" duration : \" + duration ); start = Instant . now (); index = getIndexSorted ( test , 80000000 ); finish = Instant . now (); duration = Duration . between ( start , finish ). toMillis (); System . out . println ( \"index : \" + index + \" duration : \" + duration ); start = Instant . now (); index = getIndexBinarySearch ( test , 80000000 ); finish = Instant . now (); duration = Duration . between ( start , finish ). toMillis (); System . out . println ( \"index : \" + index + \" duration : \" + duration ); Zeile 1 : Wir erstellen uns mithilfe der Methode createAndFillArray() ein Array mit 100 Millionen Eintr\u00e4gen. Zeile 2 : Unter Verwendung der Klasse Arrays (aus dem java.util -Paket) wird dieses Array sortiert (die Klasse kennen wir noch nicht). Zeile 3 : Mithilfe der Instant -Klasse (aus java.time ) und deren Methode now() ermitteln wir die aktuelle Zeit und speichern sie in der Variablen start (vom Typ Instant ); die Klasse kennen wir noch nicht Zeile 4 : Wir verwenden die Methode getIndex() , um das Element mit dem Wert 8.000.000 im Array test zu suchen Zeile 5 : Mithilfe Instant.now() ermitteln wir erneut die aktuelle Zeit und speichern sie in der Variablen finish Zeile 6 : wir berechnen die Differenz zwischen finish und start in Millisekunden und speichern sie in der Variablen duration vom Typ long (zur Differenzberechnung verwenden wir die Klassae Duration aus dem java.time -Paket; die Klasse kennen wir noch nicht) Zeile 7 : wir geben die Index und die Dauer der Ausf\u00fchrung aus Zeile 10 : wir wiederholen alles mit der getIndexSorted() -Methode Zeile 16 : wir wiederholen alles mit der getIndexBinarySearch() -Methode Es erfolgt folgende Ausgabe (Element wurde in diesem Fall nicht gefunden): index : -1 duration : 47 index : -1 duration : 94 index : -1 duration : 0 getIndexBinarySearch() verbraucht also (fast) keine Zeit. Es \u00fcberrrascht vielleicht, dass getIndexSorted() doppelt so viel Zeit verbraucht, wie getIndex() . Das liegt aber daran, dass in getIndex() einerseits die Bedingung der for -Schleife nur eine Pr\u00fcfung enth\u00e4lt, w\u00e4hrend es in getIndexSorted() drei Teilbedingungen sind, die verkn\u00fcpft werden m\u00fcssen und es au\u00dferdem in getIndex() innerhalb der for -Schleife nur eine Bedingung zur Pr\u00fcfung gibt, w\u00e4hrend es in getIndexSorted() zwei sind. Da das gesuchte Element mit dem Wert 8 Mio relativ weit hinten im Array liegen w\u00fcrde (der Bereich der Zufallszahlen ist [0 ... 9999999] Zufallszahlen in den 100 Mio Eintr\u00e4gen des Arrays), ist der Vorteil der Suche im sortierten Array hier zu gering. W\u00fcrden wir z.B. stattdessen nach der Zahl 100000 suchen, w\u00e4re das Ergebnis so: index : 1000579 duration : 53 index : 1000579 duration : 4 index : 1000575 duration : 0 Einf\u00fcgen in Arrays \u00b6 Hier geht es darum, dass wir ein Element in ein Array einf\u00fcgen wollen. Wir unterscheiden wieder zwischen dem Einf\u00fcgen in ein unsortiertes und dem Einf\u00fcgen in ein sortiertes Array. Wir betrachten zun\u00e4chst das EInf\u00fcgen in ein unsortiertes Array. Einf\u00fcgen in ein unsortiertes Array \u00b6 Angenommen, wir haben folgendes int -Array a : und wir wollen ein weiteres Element mit dem Wert 13 einf\u00fcgen. Man k\u00f6nnte auf die Idee kommen, dass die Elemente mit dem Index 10 bis 14 daf\u00fcr zur Verf\u00fcgung stehen, da diese mit dem Standartwert f\u00fcr int , der 0 belegt sind. Aber woher sollen wir wissen, dass dies gar keine \"richtigen\" Werte sind? Da das Array ein unsortiertes int -Array ist, k\u00f6nnen Nullen an allen Stellen vorkommen. Bei dem Einf\u00fcgen in ein unsortiertes Array handelt es sich eigentlich um ein Anh\u00e4ngen ( append ) des neuen Elementes an das alte Array. Wir ben\u00f6tigen dazu ein neues Array, das um 1 l\u00e4nger ist als das urspr\u00fcngliche Array. Wir gehen also wie folgt vor: wir erzeugen ein neues Array b , das um 1 l\u00e4nger ist als das Array a wir kopieren alle Werte aus a nach b wir speichern in das letzte Element von b den neuen Wert element Eine m\u00f6gliche Implementierung daf\u00fcr sieht so aus: 1 2 3 4 5 6 7 8 9 10 11 public static int [] append ( int [] a , int element ) { int [] b = new int [ a . length + 1 ] ; for ( int index = 0 ; index < a . length ; index ++ ) { b [ index ]= a [ index ] ; } b [ b . length - 1 ] = element ; return b ; } in Zeile 3 wird das neue Array b erzeugt, das um 1 \u00e4nger ist als a in den Zeilen 4-7 werden alle Werte aus a nach b kopiert in Zeile 9 wird dem letzten Element von b der Wert element zugewiesen Es geschieht also folgendes: Wir merken uns also: das Einf\u00fcgen in ein unsortiertes Array ist in Wirklichkeit ein Anh\u00e4ngen des Elementes an ein unsortiertes Array. Dazu muss ein neues Array erzeugt werden, das um 1 l\u00e4nger ist als das Array, an das angeh\u00e4ngt werden soll. Einf\u00fcgen in ein sortiertes Array \u00b6 Das Einf\u00fcgen in ein sortiertes Array ist deutlich komplizierter, denn das einzuf\u00fcgende Element muss korrekt, d.h. an die richtige Stelle entsprechend der Sortierung, eingef\u00fcgt werden. Angenommen, wir haben folgende Ausgangsposition: Das einzuf\u00fcgende Element mit dem Wert 13 muss zwischen die beiden Elemente mit den Werten 12 und 14 eingef\u00fcgt werden. Wir gehen dabei wie folgt vor: wir erzeugen ein neues Array b , das um 1 l\u00e4nger ist als a wir kopieren alle Werte aus a nach b solange die Werte kleiner sind als das einzuf\u00fcgende Element wenn wir auf das erste Element in a sto\u00dfen, das gr\u00f6\u00dfer ist als das einzuf\u00fcgende Element, f\u00fcgen wir das Element ein danach kopieren wir die restlichen Werte aus a nach b Wir setzen obigen Algorithmus in folgender Methode um: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public static int [] insertIntoSortedArray ( int [] a , int element ) { int [] b = new int [ a . length + 1 ] ; int indexB = 0 , indexA = 0 ; while ( indexA < a . length && a [ indexA ]< element ) { b [ indexB ++]= a [ indexA ++] ; } b [ indexB ++] = element ; // from now on indexB = indexA+1 while ( indexB < b . length ) { b [ indexB ++]= a [ indexA ++] ; } return b ; } in Zeile 3 wird das Array b erzeugt, welches um 1 l\u00e4nger ist als a in Zeilen 5-8 kopieren wir alle Werte aus a nach b , die kleiner sind als unser element in Zeile 10 wird element in b eingef\u00fcgt in Zeilen 12-15 kopieren wir die restlichen Werte aus a nach b Beachten Sie: in der Anweisung b[indexB++]=a[indexA++]; passieren mehrere Sachen auf einmal: einerseits b[indexB]=a[indexA]; und au\u00dferdem noch indexB++; und indexA++ ; nach der Anweisung b[indexB++] = element; ist indexB um 1 gr\u00f6\u00dfer als indexA (was ja auch gut ist, siehe im Bild das \"rote\" Kopieren) Spielen Sie den Fall durch, dass eine 0 in das Beispiel-Array aus der Abbildung eingef\u00fcgt werden soll! Dann wird die erste while -Schleife gar nicht betreten, da die (Teil-)Bedingung a[indexA]<element gleich false ist Spielen Sie den Fall durch, dass eine 27 in das Beispiel-Array aus der Abbildung eingef\u00fcgt werden soll! Dann wird die zweite while -Schleife gar nicht betreten, da die Bedingung indexB<b.length gleich false ist Die Bedingung der ersten while -Schleife lautet indexA<a.length && a[indexA]<element . K\u00f6nnte man das auch umdrehen und a[indexA]<element && indexA<a.length schreiben? Nein, das k\u00f6nnte zu einem Fehler f\u00fchren. Der Operator && hat (im Gegensatz zum Operator & ) die Eigenschaft, dass die zweite Teilbedingung (also a[indexA]<element ) gar nicht mehr gepr\u00fcft wird, wenn die erste bereits false ist. Angenommen, die Teilbedingung indexA<a.length ist false , dann ist indexA==a.length . Dann k\u00f6nnen wir aber nicht mehr mit a[indexA] auf ein Element in a zugreifen, da der Index a.length nicht existiert. Wir w\u00fcrden eine ArrayIndexOutOfBoundsException geworfen bekommen. F\u00fcr den Fall also, dass das neu einzuf\u00fcgende Element ganz an das Ende des neuen Arrays b kommt, muss die Bedingung genau in dieser Reihenfolge formuliert werden. Success Wir kennen jetzt Arrays. Wir k\u00f6nnen sie erzeugen, wir k\u00f6nnen sie miteinander verbinden. Wir k\u00f6nnen Elemente darin suchen, sowohl in sortierten als auch in unsortierten Arrays. Wir k\u00f6nnen Elemente einf\u00fcgen. Bitte beachten Sie, dass die Elemente eines Arrays von jedem beliebigen Typ sein k\u00f6nnen, auch Referenztypen. Jetzt lernen wir noch, wie wir Arrays sortieren k\u00f6nnen und werden uns sp\u00e4ter nochmal mit Arrays besch\u00e4ftigen, deren Elemente von Referenztypen sind und somit Objekte beinhalten. ganz genau geben wir die Referenz auf das copy -Array zur\u00fcck, aber dazu sp\u00e4ter \u21a9","title":"Arrays"},{"location":"arrays/#arrays","text":"In einer Variable k\u00f6nnen wir genau einen Wert speichern. Wenn wir 5 Werte speichern wollen, ben\u00f6tigen wir 5 Variablen und wenn wir 1000 Werte speichern wollen, ben\u00f6tigen wir 1000 Variablen. Das ist nat\u00fcrlich unzweckm\u00e4\u00dfig. Wenn Sie mehrere Werte gleichen Typs speichern wollen, dann verwenden Sie dazu besser Arrays ( Felder ). Arrays sind Objekte. Wir schauen uns mal ein einf\u00fchrendes Beispiel an. Angenommen, wir wollen 5 int -Werte 0 , 1 , 4 , 9 und 16 speichern. Bis jetzt ben\u00f6tigten wir dazu 5 Variablen: int number1 = 0 ; int number2 = 1 ; int number3 = 4 ; int number4 = 9 ; int number5 = 16 ; Jetzt wollen wir dazu ein Array verwenden. Die Erzeugung und Initialisierung sieht so aus: 1 2 3 4 5 6 int [] numbers = new int [ 5 ] ; // Array der Laenge 5 numbers [ 0 ] = 0 ; // erstes Element Wert 0 numbers [ 1 ] = 1 ; // zweites Element Wert 1 numbers [ 2 ] = 4 ; // drittes Element Wert 4 numbers [ 3 ] = 9 ; // viertes Element Wert 9 numbers [ 4 ] = 16 ; // fuenftes Element Wert 16 Ein Array erkennen wir an den eckigen Klammern [] . Unser Array im Beispiel ist vom Typ int , d.h. jedes Element in diesem Array ist vom Typ int . Arrays k\u00f6nnen von einem beliebigen Typ sein, sowohl Wertetypen als auch Referenztypen. Ein Array wird immer f\u00fcr genau einen Typ deklariert, bei uns int \u2192 deshalb int[] . Best\u00fcnde das Array aus lauter Strings, dann w\u00e4re der Typ String[] . In unserem Beispiel ist numbers die Referenzvariable, die auf unser Array-Objekt zeigt. Mithilfe des Schl\u00fcsselwortes new wird unser Array erzeugt. Nach new kommt nochmal das Array ( Typ[] ), aber in den eckigen Klammern steht die L\u00e4nge des Arrays. In unserem Beispiel 5 . Bei der Erzeugung des Arrays muss immer die L\u00e4nge angegeben werden. Die L\u00e4nge eines Arrays kann sich nicht \u00e4ndern. Der Zugriff auf die einzelnen Elemente erfolgt \u00fcber den Index . Jedes Array ist automatisch \"nummeriert\". Die \"Nummerierung\" (der Index) beginnt immer mit 0 und erh\u00f6ht sich f\u00fcr jedes Element um 1 . Der Index eines Arrays ist immer vom Typ int . Wir k\u00f6nnen uns unser Array numbers so vorstellen: Wir haben 5 Elemente (L\u00e4nge 5 ), die jeweils durch den Index nummeriert sind. Diese Elemente k\u00f6nnen nun Werte enthalten: Der Zugriff auf die Werte eines Arrays erfolgt dann immer unter Verwendung der Referenzvariable, dahinter eckige Klammern und in den Klammern der entsprechende Index: Referenzvariable[Index]=Wert; Also in unserem Beispiel numbers[0] .","title":"Arrays"},{"location":"arrays/#erzeugung-und-initialisierung-eines-arrays","text":"Die Erzeugung und Initialisierung eines Arrays erfolgt in drei Schritten: Schritt: Definition einer Referenzvariablen, die auf das Array-Objekt zeigt (siehe oben in Zeile 1 : int[] numbers t) Schritt: Erzeugen des Arrays, d. h. eines Array-Objektes, das aus Elementen eines bestimmten Datentyps besteht (und Zuweisung an die zuvor definiere Referenzvariable - siehe oben Zeile 1 : new int[5] ) Schritt: Belegen der Array-Elemente mit Werten, d. h. Initialisierung des Arrays (siehe oben Zeilen 2-6 ). Beispiele verschiedene Arrays erzeugen: double [] noten = new double [ 10 ] ; // Array aus double-Elemente Laenge 10 String [] satz = new String [ 30 ] ; // Array aus Zeichenketten Laenge 30 boolean [] filled = new boolean [ 100 ] ; // Array aus boolean-Elementen Laenge 100 int [] statistics = new int [ 10000 ] ; // Array aus int-Elementen Laenge 10000 Die Initialisierung erfolgt elementweise \u00fcber den Zugriff auf den Index, z.B. (siehe oben): numbers [ 0 ] = 0 ; // erstes Element Wert 0 numbers [ 1 ] = 1 ; // zweites Element Wert 1 numbers [ 2 ] = 4 ; // drittes Element Wert 4 numbers [ 3 ] = 9 ; // viertes Element Wert 9 numbers [ 4 ] = 16 ; // fuenftes Element Wert 16 Da der Index stets vom Typ int ist, h\u00e4tten wir unser Array auch wie folgt initialisieren k\u00f6nnen: 1 2 3 4 for ( int index = 0 ; index < 5 ; index ++ ) { numbers [ index ] = ( index * index ); } Beachten Sie: Der gr\u00f6\u00dfte Index ist immer um eins kleiner als die L\u00e4nge des Arrays (L\u00e4nge ist 5 , gr\u00f6\u00dfter Index ist 4 \u2192 deshalb index < 5 ) Der Index ist immer int , egal von welchem Typ das Array ist In unserem Beispiel entsprechen die Werte der einzelnen Elementen Quadratzahlen. Deshalb konnten wir als Wert (index * index) verwenden.","title":"Erzeugung und Initialisierung eines Arrays"},{"location":"arrays/#die-eigenschaft-length","text":"Jedes Array besitzt die Eigenschaft length . Dar\u00fcber k\u00f6nnen wir die L\u00e4nge des Arrays auslesen. Der Wert von length kann nicht neu gesetzt werden (ist konstant). Wir benutzen die Eigenschaft length insbesondere in den Schleifen, mit denen wir auf den Index zugreifen. Referenzvariable.length Unser obiges Initialisierungsbeispiel h\u00e4tte also besser so ausgesehen: 1 2 3 4 for ( int index = 0 ; index < numbers . length ; index ++ ) { numbers [ index ] = ( index * index ); }","title":"Die Eigenschaft length"},{"location":"arrays/#ausgabe-der-werte","text":"Den jetzt bereits bekannten Zugriff auf die einzelnen Elemente k\u00f6nnen wir auch f\u00fcr das Auslesen der Werte eines Arrays verwenden: 1 2 3 4 for ( int index = 0 ; index < numbers . length ; index ++ ) { System . out . println ( numbers [ index ] ); }","title":"Ausgabe der Werte"},{"location":"arrays/#verwenden-der-werte","text":"Wir erl\u00e4utern ein einfaches Beispiel zur Verwendung der Werte, wir bilden die Summe aller Werte \u00fcber das Array (wir gehen davon aus, dass das numbers -Array so wie oben erzeugt un initialisiert wurde): int sum = 0 ; for ( int index = 0 ; index < numbers . length ; index ++ ) { sum = sum + numbers [ index ] ; } System . out . println ( \"Summe aller Elemente : \" + sum );","title":"Verwenden der Werte"},{"location":"arrays/#mogliche-andere-form-der-erzeugung-und-initialisierung","text":"Das Array kann auch in einer anderen Form erzeugt und initilisiert werden: int [] numbers = { 0 , 1 , 4 , 9 , 16 }; Diese Form erzeugt ein int[] -Array der L\u00e4nge 5 mit den Werten numbers [ 0 ] = 0 ; // erstes Element Wert 0 numbers [ 1 ] = 1 ; // zweites Element Wert 1 numbers [ 2 ] = 4 ; // drittes Element Wert 4 numbers [ 3 ] = 9 ; // viertes Element Wert 9 numbers [ 4 ] = 16 ; // fuenftes Element Wert 16 Es handelt sich um eine einfache Form der Erzeugung und Initialisierung in einem Schritt.","title":"M\u00f6gliche andere Form der Erzeugung und Initialisierung"},{"location":"arrays/#weitere-beispiele-von-arrays","text":"Wir zeigen einige Beispiele anderer Arrays: 1 2 3 4 5 6 7 8 9 10 String [] satz = new String [ 4 ] ; satz [ 0 ] = \"Das\" ; satz [ 1 ] = \"ist\" ; satz [ 2 ] = \"ein\" ; satz [ 3 ] = \"Satz\" ; for ( int index = 0 ; index < satz . length - 1 ; index ++ ) { System . out . print ( satz [ index ] + \" \" ); } System . out . println ( satz [ satz . length - 1 ] + \".\" ); Das Beispiel zeigt die Erzeugung und Initialisierung eines Arrays, in dem alle Elemente vom Typ String sind. Nach der Erzeugung und Initialisierung in den Zeilen 1 bis 5 folgt die Ausgabe der Werte des Arrays. Es werden alle Werte ausgegeben und ein Leerzeichen angeh\u00e4ngt. Das gilt aber nur f\u00fcr alle Elemente einschlie\u00dflich des vorletzten ( index<satz.length-1 ). Hinter das letzte Element ( satz[satz.length-1] ) folgt kein Leerzeichen, sondern ein Punkt. Wir h\u00e4tten das Array auch so erzeugen und initialisieren k\u00f6nnen: String[] satz = {\"Das\", \"ist\", \"ein\", \"Satz\"}; Ein weiteres Beispiel mit einem char -Array: 1 2 3 4 5 6 7 8 9 char [] alphabet = new char [ 26 ] ; for ( int index = 0 ; index < 26 ; index ++ ) { alphabet [ index ] = ( char ) ( index + 65 ); } for ( int index = 0 ; index < 26 ; index ++ ) { System . out . print ( alphabet [ index ]+ \" \" ); } Es wird zun\u00e4chst ein char -Array erzeugt (Zeile 1 ) und initialisiert (Zeilen 2 bis 5 ). Anschlie\u00dfend wird es ausgelesen Zeilen 6 bis 9 ). Es entsteht folgende Ausgabe: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z Success Wir k\u00f6nnen uns Arrays erzeugen und initialisieren. Wir k\u00f6nnen Werte in diesen Arrays \u00e4ndern und aus den Arrays auslesen. Wir kennen die length -Variable von Arrays und k\u00f6nnen den Index verwenden, um auf die einzelnen Elemente zuzugreifen. N\u00e4chste Woche geht es mit Arrays weiter!","title":"Weitere Beispiele von Arrays"},{"location":"arrays/#algorithmen-uber-arrays","text":"Wir werden uns mit verschiedenen Algorithmen besch\u00e4ftigen, die alle Arrays zur Grundlage haben. Wir beginnen zur Auffrischung mal mit einer kleinen \u00dcbung. Wir wollen ein Array erstellen, in dem die Fibonacci-Folge enthalten ist. Diese geht so, dass das erste Element den Wert 0 hat und das zweite Element den Wert 1 und alle nachfolgenden Elemente als Wert die Summe der Werte ihrer beiden Vorg\u00e4nger hat, also 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ... . Ausgangspunkt ist also etwas in der folgenden Art: public static void main ( String [] args ) { int length = 20 ; int [] fibonacci = new int [ length ] ; fibonacci [ 0 ] = 0 ; fibonacci [ 1 ] = 1 ; } Bef\u00fcllen Sie den Rest des fibonacci -Arrays! public static void main ( String [] args ) { int length = 20 ; int [] fibonacci = new int [ length ] ; fibonacci [ 0 ] = 0 ; fibonacci [ 1 ] = 1 ; for ( int index = 2 ; index < fibonacci . length ; index ++ ) { fibonacci [ index ] = fibonacci [ index - 1 ] + fibonacci [ index - 2 ] ; } } Wir wollen dieses Array nun mehrfach verwenden, um anhand von Beispielen einige Algorithmen \u00fcber Arrays kennenzulernen. Beachten Sie, dass wir f\u00fcr das fibonacci -Array die L\u00e4nge auf 20 festgesetzt hatten. Dies k\u00f6nnen wir aber problemlos \u00e4ndern und deutlich l\u00e4ngere fibonacci -Arrays erstellen. Alles, was wir dazu tun m\u00fcssen, ist den Wert von length zu \u00e4ndern. Beachten Sie au\u00dferdem, dass length eine von uns erzeugte Variable ist, aber fibonacci.length eine Variable des Arrays (deren Wert wir nicht \u00e4ndern, sondern nur auslesen k\u00f6nnnen).","title":"Algorithmen \u00fcber Arrays"},{"location":"arrays/#methoden-mit-arrays-als-parameter","text":"Wir werden uns einige Methoden erstellen, um z.B. ein als Parameter \u00fcbergebenes Array auszugeben oder einige Berechnungen \u00fcber die Werte des Arrays durchzuf\u00fchren. Wir beginnen damit, uns eine Methode zu schreiben, die ein als Parameter \u00fcbergebenes Array auf die Konsole ausgibt.","title":"Methoden mit Arrays als Parameter"},{"location":"arrays/#ausgabe-der-werte-auf-die-konsole","text":"Zun\u00e4chst wollen wir alle Werte nur durch Leerzeichen getrennt auf die Konsole ausgeben. Die dazugeh\u00f6rige Methode sieht so aus: 1 2 3 4 5 6 7 8 public static void printArray ( int [] a ) { for ( int index = 0 ; index < a . length ; index ++ ) { System . out . print ( a [ index ] + \" \" ); } System . out . println (); } Wir \u00fcbergeben also ein int[] -Array als Parameter und durchlaufen es in einer Schleife vollst\u00e4ndig von index=0 bis index=a.length-1 und geben alle Werte von a[index] auf die Konsole durch Leerzeichen getrennt aus. Wenn wir nun in main() printArray(fibonacci); aufrufen, bekommen wir folgende Ausgabe: 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 Jetzt wollen wir die Ausgabe \u00e4ndern. Das Array soll in folgender Form ausgegeben werden: [ 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 , 89 , 144 , 233 , 377 , 610 , 987 , 1597 , 2584 , 4181 ] Das hei\u00dft, die Werte sollen alle innerhalb von eckigen Klammern erscheinen und die Werte sind durch Komma getrennt. Das Hauptproblem dabei ist, dass nach dem letzten Wert kein Komma ausgegeben werden soll. Angenommen, wir \u00e4ndern obigen Code nur geringf\u00fcgig: 1 2 3 4 5 6 7 8 9 public static void printArray ( int [] a ) { System . out . print ( \"[ \" ); for ( int index = 0 ; index < a . length ; index ++ ) { System . out . print ( a [ index ] + \", \" ); } System . out . println ( \" ]\" ); } dann h\u00e4tten wir eine Ausgabe in der Form: [ 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 , 89 , 144 , 233 , 377 , 610 , 987 , 1597 , 2584 , 4181 , ] Wir h\u00e4tten also schonmal die eckigen Klammern, aber nach dem letzten Wert k\u00e4me noch ein Komma. Deshalb lassen wir nun die Schleife nur noch bis index<a.length-1 laufen und behandeln das letzte Element extra. Welchen Index hat das letzte Element von a ? Wir kennen die L\u00e4nge nicht, wir kennen aber a.length . Das letzte Element hat den Index a.length-1 , d.h. der gr\u00f6\u00dfte Index ist stets die L\u00e4nge des Arrays minus 1. Wir k\u00f6nnten die Methode also so schreiben: 1 2 3 4 5 6 7 8 9 10 public static void printArray ( int [] a ) { System . out . print ( \"[ \" ); for ( int index = 0 ; index < a . length - 1 ; index ++ ) { System . out . print ( a [ index ] + \", \" ); } System . out . print ( a [ a . length - 1 ] ); System . out . println ( \" ]\" ); } Jetzt gibt es nur noch ein kleines Problem: Was passiert, wenn die L\u00e4nge des Arrays 0 ist, das als Parameter \u00fcbergebene Array also gar keine Elemente besitzt? Ein solches Array lie\u00dfe sich z.B. durch int [] arr1 = new int [ 0 ] ; int [] arr2 = {}; erzeugen. Wenn a die L\u00e4nge 0 h\u00e4tte, dann w\u00fcrden wir mit a[a.length-1] auf das Element von a mit dem Index -1 zugreifen wollen und ein solches Element/ein solcher Index existiert nicht. Es w\u00fcrde eine ArrayIndexOutOfBounds -Exception geworfen werden. Um sich dagegen zu sch\u00fctzen, pr\u00fcfen wir vor diesem Zugriff noch, ob die L\u00e4nge gr\u00dfer als 0 ist: 1 2 3 4 5 6 7 8 9 10 11 12 13 public static void printArray ( int [] a ) { System . out . print ( \"[ \" ); for ( int index = 0 ; index < a . length - 1 ; index ++ ) { System . out . print ( a [ index ] + \", \" ); } if ( a . length > 0 ) { System . out . print ( a [ a . length - 1 ] ); } System . out . println ( \" ]\" ); } Was wird ausgegeben, wenn a die L\u00e4nge 0 hat? [ ] Schreiben Sie die obige Methode so, dass die Ausgabe nicht auf der Konsole erfolgt, sondern der Ausgabe-String zur\u00fcckgegeben wird! public static String getOutputStringOfArray ( int [] a ) { String s = \"[ \" ; for ( int index = 0 ; index < a . length - 1 ; index ++ ) { s = s + a [ index ] + \", \" ; } if ( a . length > 0 ) { s = s + a [ a . length - 1 ] + \" ]\" ; } return s ; }","title":"Ausgabe der Werte auf die Konsole"},{"location":"arrays/#maximumwert-ermitteln","text":"Angenommen, wir bekommen ein int[] -Array als Parameter \u00fcbergeben und sollen den gr\u00f6\u00dften Wert innerhalb dieses Arrays ermitteln (und zur\u00fcckgeben). Eine Idee f\u00fcr einen solchen Algorithmus w\u00e4re: wir merken uns das aktuelle Maximum in einer Variablen wir laufen durch das Array durch und immer wenn der aktuelle Wert im Array gr\u00f6\u00dfer ist, als unser aktuelles Maximum, speichern wir den Wert als (neues) aktuelles Maximum wenn wir vollst\u00e4ndig durch das Array durchgelaufen sind, haben wir den gr\u00f6\u00dften Wert als aktuelles Maximum gespeichert und k\u00f6nnen ihn zur\u00fcckgeben Eine solche Implementierung k\u00f6nnte so aussehen: 1 2 3 4 5 6 7 8 9 10 11 12 public static int getMaximum ( int [] a ) { int currentMaximum = 0 ; for ( int index = 0 ; index < a . length ; index ++ ) { if ( a [ index ]> currentMaximum ) { currentMaximum = a [ index ] ; } } return currentMaximum ; } Das sieht zun\u00e4chst exakt wie die Implementierung des oben beschriebenen Algorithmus' aus. In Zeile 3 erstellen wir unsere Variable currentMaximum , mit der wir uns das aktuelle Maximum speichern wollen. Mit der for -Schleife laufen wir durch alle Elemente unseres Arrays (Zeile 4 ) und wenn ein Wert aus dem Array gr\u00f6\u00dfer ist als das bis dahin gespeicherte Maximum (Zeile 6 ), speichern wir den Wert des Elements als neues Maximum (Zeile 8 ). Nach dem Verlassen der for -Schleife ist der gr\u00f6\u00dfte Wert in currentMaximum gespeichert und kann zur\u00fcckgegeben werden. Wir testen das mal in main() mit unserer Fibonacci-Folge und rufen System.out.println(getMaximum(fibonacci)); auf. Wir erhalten: 4181 Es scheint also zu funktionieren. Wir haben jedoch ein Problem: Was passiert, wenn die Werte in a alle negativ sind? Dann w\u00fcrde der Vergleich in Zeile 6 nie true sein und currentMaximum nie den Wert \u00e4ndern, da der initiale Wert von currentMaximum gr\u00f6\u00dfer als alle Werte aus dem Array ist. Wir m\u00fcssen also etwas am initialen Wert von currentMaximum \u00e4ndern. Eine Idee ist, dass wir currentMaximum mit dem ersten Wert aus dem a -Array initialisieren: 1 2 3 4 5 6 7 8 9 10 11 12 public static int getMaximum ( int [] a ) { int currentMaximum = a [ 0 ] ; for ( int index = 1 ; index < a . length ; index ++ ) { if ( a [ index ]> currentMaximum ) { currentMaximum = a [ index ] ; } } return currentMaximum ; } Dann m\u00fcssen wir beim Schleifendurchlauf nur noch alle Elemente betrachten, deren Index >=1 ist, da wir das Element mit dem Index 0 (das erste Element aus a ) bereits bei der Initialisierung von currentMaximum betrachtet haben. Nun funktioniert unsere Methode auch f\u00fcr Arrays, die nur negative Werte enthalten. Ein Problem bleibt noch: Was passiert, wenn das Array a leer ist, also eine L\u00e4nge von 0 hat? Dann k\u00f6nnen wir n\u00e4mlich auch nicht a[0] aufrufen, da dieses Element (der Index 0 ) nicht existiert. Wir bek\u00e4men eine ArrayIndexOutOfBounds -Exception. Hierbei stellt sich die grunds\u00e4tzliche Frage, was durch unsere Methode zur\u00fcckgegeben werden soll, wenn das \u00fcbergebene Array gar kein Maximum hat, n\u00e4mlich dann, wenn es leer ist? Darauf gibt es keine befriedigende Antwort. W\u00fcr m\u00fcssen ein int zur\u00fcckgeben, aber kein int aus dem Wertebereich w\u00e4re korrekt. Grunds\u00e4tzlich sollte so etwas vor Aufruf der Methode gepr\u00fcft werden. Wir k\u00f6nnten uns z.B. eine Methode isEmpty() schreiben: public static boolean isEmpty ( int [] a ) { return ( a . length == 0 ); } Diese Methode gibt true zur\u00fcck, wenn das Array a leer ist (also die L\u00e4nge 0 ) hat und false sonst. Diese Methode kann man f\u00fcr den Aufruf von getMaximum() verwenden: if ( ! isEmpty ( arr1 )) { int maximum = getMaximum ( arr1 ); } Das hei\u00dft, wir rufen die Methode getMaximum() f\u00fcr ein Array nur dann auf, wenn wir wissen, dass dieses Array nicht leer ist. Dann arbeitet unsere Methode n\u00e4mlich korrekt - und nur dann.","title":"Maximumwert ermitteln"},{"location":"arrays/#zwei-arrays-auf-gleichheit-prufen","text":"Wir wollen eine Methode schreiben, die \u00fcberpr\u00fcft, ob 2 Arrays gleich sind - also vollst\u00e4ndig gleiche Werte enthalten. Z.B. sollen diese Arrays gleich sein: int [] arr1 = { 8 , 9 , 2 , 3 , 7 , 4 , 1 , 0 , 9 , 6 }; int [] arr2 = { 8 , 9 , 2 , 3 , 7 , 4 , 1 , 0 , 9 , 6 }; aber int [] arr3 = { 8 , 9 , 2 , 3 , 7 , 5 , 1 , 0 , 9 , 6 }; ist ungleich zu arr1 und arr2 , da arr3 an 6. Stelle den Wert 5 statt 4 hat. Die algorithmische Idee ist: wir laufen gleichzeitig durch beide Arrays durch solange die Werte bei gleichem Index gleich sind, machen wir weiter sobald zwei Werte bei gleichem Index ungleich sind, wissen wir, dass die Arrays ungleich sind wenn wir alle Elemente betrachtet haben und alle waren gleich, dann sind auch unsere Arrays gleich 1 2 3 4 5 6 7 8 9 10 11 12 public static boolean areEqual ( int [] a , int [] b ) { boolean areEqual = true ; for ( int index = 0 ; index < a . length ; index ++ ) { if ( a [ index ]!= b [ index ] ) { areEqual = false ; } } return areEqual ; } Diese Methode setzt unseren Algorithmus um und wenn wir die Methode mit den obigen Arrays testen System . out . println ( areEqual ( arr1 , arr2 )); System . out . println ( areEqual ( arr1 , arr3 )); , dann wird auch korrekt true false ausgegeben. Doch was passiert, wenn wir die Methode f\u00fcr diese beiden Arrays aufrufen: int [] arr4 = { 8 , 9 , 2 }; int [] arr5 = { 8 , 9 , 2 , 3 }; Welcher Wert wird bei Aufruf System.out.println(areEqual(arr4, arr5)); ausgegeben? true Wollen wir das? Welcher Wert wird bei Aufruf System.out.println(areEqual(arr5, arr4)); ausgegeben? keiner, sondern Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3 Warum? Grunds\u00e4tzlich sollte es bei einer solchen Methode egal sein, welche Reihenfolge die \u00fcbergebenen Arrays in der Parameterliste haben, d.h. areEqual(arr4, arr5) und areEqual(arr5, arr4) sollten den gleichen Wert zur\u00fcckliefern, denn entweder sind sie gleich true oder sie sind es nicht false . Die Gleichheit ist eine symmetrische Relation . Was ist das Problem unserer bisherigen L\u00f6sung? Wir durchlaufen die Schleife auch dann, wenn die Arrays unterschiedliche L\u00e4nge haben. In dem Aufruf areEqual(arr4, arr5) wird das letzte Element von arr5 gar nicht mehr gepr\u00fcft, da der index in der Schleife nur bis arr4.length-1 l\u00e4uft. In dem Aufruf areEqual(arr5, arr4) wird versucht, das letzte Element von arr5 mit einem Element von arr4 zu vergleichen, das gar nicht existiert. Der Zugriff auf arr4[3] f\u00fchrt zu einer ArrayIndexOutOfBoundsException . Wir werden deshalb zun\u00e4chst pr\u00fcfen, ob die beiden Arrays \u00fcberhaupt gleich lang sind und nur dann durchlaufen wir die beiden Arrays: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public static boolean areEqual ( int [] a , int [] b ) { boolean areEqual = true ; if ( a . length != b . length ) { areEqual = false ; } for ( int index = 0 ; index < a . length && areEqual ; index ++ ) { if ( a [ index ]!= b [ index ] ) { areEqual = false ; } } return areEqual ; } Au\u00dferdem haben wir in die for -Schleife die Bedingung um && areEqual erweitert. Das hat zwei Gr\u00fcnde: erstens betreten wir die for -Schleife dann gar nicht, wenn die beiden Arrays unterschiedliche L\u00e4ngen haben, denn dann ist areEqual==fasle und somit ist die gesamte Bedingung index < a.length && areEqual false . \u2192 das ist also notwendig, um korrekt zu sein (wir k\u00f6nnten auch die for -Schleife in den else -Block der Selektion packen) zweitens beenden wir das Durchlaufen der for -Schleife sofort, wenn wir ungleiche Elemente gefunden haben, denn dann setzen wir ja auch areEqual auf false . Es gen\u00fcgt ja, zwei ungleiche Elemente zu finden, dann sind die Arrays ungleich und wir m\u00fcssen gar nicht weiter suchen. \u2192 das ist also nicht notwendig, aber performanter Zur \u00dcbung mit einem Array als Parameter k\u00f6nnen Sie: Bestimmen Sie die Summe aller Werte eines int -Arrays, welches als Parameter der Methode \u00fcbergeben wird. Geben Sie die Summe zur\u00fcck. public static int getSumme ( int [] a ) { int sum = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { sum += a [ i ] ; } return sum ; } Bestimmen Sie den Durchschnitt/Mittelwert aller Werte eines int -Arrays, welches als Parameter der Methode \u00fcbergeben wird. Geben Sie den Durchschnitt zur\u00fcck zur\u00fcck. public static double getAverage ( int [] a ) { /* * diese Aufgabe ist leider komplizierter, da wir * das Problem haben, dass getSumme(a) ein int * zurueckliefert und a.length ebenfalls ein int ist * und wir somit int / int rechnen, also eine * ganzzahlige Division durchf\u00fchren * Mithilfe des Typkonvertierungsoperators (double) * k\u00f6nnen wir aber aus einem int ein double machen, * z.B. wird mit (double)a.length aus der Laenge ein * double * int / double ist eine Gleitkommadivision * Probieren Sie es einmal ohne (double) und * einmal mit (double) aus */ double average = getSumme ( a ) / ( double ) a . length ; return average ; }","title":"Zwei Arrays auf Gleichheit pr\u00fcfen"},{"location":"arrays/#methoden-mit-array-als-ruckgabe","text":"Wir betrachten nun Methoden, die ein Array zur\u00fcckgeben. Wir fangen an mit einer Methode, der eine int length \u00fcbergeben wird und die damit ein int[] der L\u00e4nge length erzeugt und dieses Array mit Zufallszahlen bef\u00fcllt: 1 2 3 4 5 6 7 8 9 10 public static int [] createAndFillArray ( int length ) { int [] a = new int [ length ] ; Random r = new Random (); for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ]= r . nextInt (); } return a ; } Betrachten wir die Methode genauer: in Zeile 3 wird eine Variable a vom Typ int[] deklariert und ein int[] -Array der L\u00e4nge length erzeugt. Die Variable a zeigt auf dieses neu erzeugte Array. in Zeile 4 erzeugen wir ein Random -Objekt und die Referenzvariable r vom Typ Random zeigt auf dieses Objekt. Beachten Sie, dass Sie die Klasse Random aus dem java.util -Paket importieren m\u00fcssen! in den Zeilen 5-8 laufen wir durch das Array durch und belegen jedes Element mit einer Zufallszahl indem wir r.nextInt() aufrufen. in Zeile 9 wird das Array zur\u00fcckgegeben. Aufruf der Methode in main() (oder einer anderen Methode): int [] arr6 = createAndFillArray ( 5 ); printArray ( arr6 ); Wir rufen die Methode mit einem Wert 5 f\u00fcr length auf. Das bedeutet, dass die Methode ein Array der L\u00e4nge 5 erzeugt und mit Zufallszahlen bef\u00fcllt. Das zur\u00fcckgegebene Arry speichern wir in der Variablen arr6 , die ebenfalls vom Typ int[] ist. Wir geben das Array mithilfe der von uns erzeugten Methode printArray(arr6); aus (wir h\u00e4tten auch direkt printArray(createAndFillArray(5)); aufrufen k\u00f6nnen, dann h\u00e4tten wir das erzeugte Array aber nirgendwo gespeichert). Es erscheint z.B. eine Ausgabe wie: [ 1463666318 , -2121738539, -1174806146, 337579240 , -108604609 ] Wenn wir den Wertebereich der zuf\u00e4llig erzeugten Zahlen eingrenzen m\u00f6chten, z.B. nur Werte aus dem Bereich [0, 1, ..., 19] , k\u00f6nnen wir die nextInt(int bound) -Methode von Random verwenden ( siehe ). Wir erweitern die Methode createAndFillArray() um einen solchen bound -Parameter: 1 2 3 4 5 6 7 8 9 10 public static int [] createAndFillArray ( int length , int bound ) { int [] a = new int [ length ] ; Random r = new Random (); for ( int i = 0 ; i < a . length ; i ++ ) { a [ i ]= r . nextInt ( bound ); } return a ; } Beachten Sie, dass bei nextInt(int bound) der Wert von bound exklusiv ist, d.h. dieser Wert gibt die erste Zahl an, die nicht mehr zuf\u00e4llig erzeugt wird. Wenn wir also zuf\u00e4llig Zahlen aus dem Bereich [0, 1, ..., 19] erzeugen wollen, dann muss bound=20 sein. Der Aufruf von int [] arr7 = createAndFillArray ( 10 , 20 ); printArray ( arr7 ); erzeugt dann z.B. eine solche Ausgabe (bei Ihnen nat\u00fcrlich anders - sind ja Zufallszahlen): [ 2 , 17 , 7 , 5 , 17 , 3 , 19 , 8 , 6 , 18 ]","title":"Methoden mit Array als R\u00fcckgabe"},{"location":"arrays/#array-kopieren","text":"Wir erstellen eine Methode, der ein Array als Parameter \u00fcbergeben wird und die davon eine Kopie erstellt und diese Kopie zur\u00fcckgibt. 1 2 3 4 5 6 7 8 9 10 public static int [] copyArray ( int [] original ) { int length = original . length ; int [] copy = new int [ length ] ; for ( int index = 0 ; index < length ; index ++ ) { copy [ index ] = original [ index ] ; } return copy ; } in Zeile 1 wird das Original-Array \u00fcbergeben und in der Referenzvariablen original gespeichert, in Zeile 3 erstellen wir uns eine Variable length vom Typ int , in der die L\u00e4nge des Original-Arrays gespeichert wird, in Zeile 4 wird das copy -Array erstellt, das genau so lang ist, wie das Original, In den Zeilen 5-8 kopieren wir jeden einzelnen Wert aus dem Original-Array in das copy -Array (elementweise), in Zeile 9 geben wir das copy -Array zur\u00fcck 1 Der Aufruf der Methode, z.B. int [] original = createAndFillArray ( 10 , 20 ); System . out . print ( \"original : \" ); printArray ( original ); int [] copy = copyArray ( original ); System . out . print ( \"copy : \" ); printArray ( copy ); erzeugt folgende Ausgabe (Zufallszahlen): original : [ 2 , 2 , 5 , 19 , 19 , 6 , 1 , 1 , 4 , 8 ] copy : [ 2 , 2 , 5 , 19 , 19 , 6 , 1 , 1 , 4 , 8 ] Angenommen, wir \u00fcbergeben unserer Methode nicht nur das Original-Array, sondern auch eine L\u00e4nge, bis zu der das Original-Array kopiert werden soll. Der Methodenkopf w\u00fcrde dann also so aussehen: public static int [] copyArray ( int [] original , int newLength ) Dann gibt es 3 verschiedene Varianten: Original-Array und Kopie des Arrays gleich lang (wenn newLength == original.length ) Original-Array k\u00fcrzer als Kopie (z.B. falls Original-Array zu klein geworden ist, um weitere Elemente einzuf\u00fcgen; wenn newLength > original.length ) Original-Array l\u00e4nger als Kopie (falls nur ein Teil kopiert werden soll; wenn newLength < original.length ) Wir f\u00fcgen in unsere Methode eine entsprechende Fallunterscheidung ein: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public static int [] copyArray ( int [] original , int newLength ) { int [] copy = new int [ newLength ] ; if ( original . length <= newLength ) { for ( int index = 0 ; index < original . length ; index ++ ) { copy [ index ]= original [ index ] ; } } else { for ( int index = 0 ; index < copy . length ; index ++ ) { copy [ index ]= original [ index ] ; } } return copy ; } in Zeile 1 wurde der neue Parameter newLength hinzugef\u00fcgt, der die L\u00e4nge des copy -Arrays bestimmt, in Zeile 3 wird das copy -Array mit der L\u00e4nge newLength erzeugt, in Zeile 4 erfolgt die Fallunterscheidung: falls die Kopie mindestens so lang ist wie das Original, werden alle Elemente aus dem Original in die Kopie kopiert (Zeilen 6-9 ) \u2192 Beachten Sie Verwendung von original.length in der Bedingung der for -Schleife, falls die Kopie k\u00fcrzer ist als das Original, werden nur die ersten newLength Elemente aus dem Original-Array kopiert (Zeilen 13-16 ) \u2192 Beachten Sie Verwendung von copy.length in der Bedingung der for -Schleife, Bei dem Aufruf von int [] original = createAndFillArray ( 10 , 20 ); // Original Laenge 10 System . out . print ( \"original : \" ); printArray ( original ); int [] copy = copyArray ( original , 8 ); // Kopie Laenge 8 System . out . print ( \"copy : \" ); printArray ( copy ); erfolgt folgende Ausgabe (Zufallszahlen): original : [ 8 , 13 , 11 , 4 , 7 , 2 , 5 , 1 , 15 , 5 ] copy : [ 8 , 13 , 11 , 4 , 7 , 2 , 5 , 1 ] Bei dem Aufruf von int [] original = createAndFillArray ( 10 , 20 ); // Original Laenge 10 System . out . print ( \"original : \" ); printArray ( original ); int [] copy = copyArray ( original , 18 ); // Kopie Laenge 18 System . out . print ( \"copy : \" ); printArray ( copy ); erfolgt folgende Ausgabe (Zufallszahlen): original : [ 1 , 18 , 0 , 9 , 12 , 18 , 2 , 8 , 17 , 12 ] copy : [ 1 , 18 , 0 , 9 , 12 , 18 , 2 , 8 , 17 , 12 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] Beachten Sie, dass Elementen, denen kein Wert zugewiesen wurde, den Wert 0 haben (Standardwert von int ).","title":"Array kopieren"},{"location":"arrays/#array-verketten","text":"Wir erstellen eine Methode, der zwei Arrays als Parameter \u00fcbergeben werden und die daraus ein neues Array erstellt, welche alle Elemente des einen und alle Elemente des anderen Arrays enth\u00e4lt. Die algorithmische Idee dabei ist wie folgt: Array a und Array b aneinanderh\u00e4ngen: neues Array c erzeugen (die L\u00e4nge von c ergibt sich aus a.length + b.length ), Elemente von a nach c kopieren (bis Index a.length-1 ), Elemente von b nach c kopieren (ab Index a.length ), c zur\u00fcckgeben Die folgende Abbildung verdeutlicht ein Beispiel mit a.length==6 und b.length==4 . Es wird ein Array c mit L\u00e4nge 10 erzeugt. In die ersten 6 Elemente von c werden die Werte von a kopiert und in die folgenden 4 Elemente die Werte von b . Beachten Sie, dass in dem Beispiel z.B. c[6]=b[0] kopiert wird. Eine m\u00f6gliche Methode k\u00f6nnte so aussehen: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public static int [] concatArrays ( int [] a , int [] b ) { int [] c = new int [ a . length + b . length ] ; for ( int index = 0 ; index < a . length ; index ++ ) { c [ index ] = a [ index ] ; } for ( int index = 0 ; index < b . length ; index ++ ) { c [ index + a . length ] = b [ index ] ; } return c ; } Wichtig ist hier, unbedingt zu verstehen, warum wir innerhalb der zweiten for -Schleife c[index+a.length] = b[index]; verwenden!","title":"Array verketten"},{"location":"arrays/#suchen-in-arrays","text":"Bei der Suche in Arrays geht es darum, einen bestimmten Wert zu finden, der im Array enthalten ist (oder er wird nicht gefunden, falls er nicht im Array existiert.) Grunds\u00e4tzlich m\u00fcssen wir zwischen der Suche in unsortierten und sortierten Arrays unterscheiden. In sortierten Arrays sind die Elemente alle hinsichtlich ihrer Werte geordnet, also z.B. numerisch bei Zahlen oder alphanumerisch bei Zeichen und Zeichenketten. Wir beginnen mit der Suche in unsortierten Arrays.","title":"Suchen in Arrays"},{"location":"arrays/#suche-in-unsortierten-arrays","text":"Wir wollen eine Methode erstellen, der ein Array \u00fcbergeben wird und ein Element gleichen Typs. Die Methode soll ein true zur\u00fcckgeben, wenn das Element in dem Array enthalten ist und ein false , wenn nicht. Die Idee dabei ist wir durchlaufen das Array solange, bis wir entweder das Element gefunden haben \u2192 dann k\u00f6nnen wir die Suche beenden und ein true zur\u00fcckgeben oder wir am Ende des Arrays angekommen sind und das Element nicht gefunden haben \u2192 dann geben wir ein false zur\u00fcck Eine solche Methode k\u00f6nnte so aussehen: public static boolean contains ( int [] a , int element ) { boolean found = false ; for ( int index = 0 ; index < a . length && ! found ; index ++ ) { if ( a [ index ]== element ) { found = true ; } } return found ; } Wir pr\u00fcfen also, ob element als Wert in a enthalten ist. in Zeile 3 definieren wir uns eine Variable found , deren Wert initial auf false gesetzt wird ( element noch nicht gefunden) in Zeilen 4-10 durchlaufen wir das Array, entweder so lange bis wir das element gefunden haben (Zeilen 6-9 ) \u2192 found==true oder bis wir das Ende des Arrays erreicht haben ( index==a.length ) \u2192 found==false in Zeile 11 geben wir den Wert von found zur\u00fcck Beachten Sie, dass es wichtig ist, dass found initial den Wert false bekommt und dass die Schleife sofort verlassen wird, sobald wir das Element gefunden haben (Schleifen bedingung && !found ). Wir bleiben bei der Suche in unsortierten Arrays. Jetzt soll unsere Methode aber den Index zur\u00fcckgeben, an dem das Element im Array enthalten ist. Wir wissen, dass der Index nur Werte zwischen 0 und array.length-1 annehmen kann, also nur positive Werte. Wenn das Element nicht im Array enthalten ist, dann geben wir eine -1 zur\u00fcck. Hierbei sind zwei Sachen zu beachten: Erstens sollten wir solche \"Codierungen\" von R\u00fcckgabewerten vermeiden. Die aufrufende Methode muss ja \"wissen\", dass ein negativer R\u00fcckgabewert bedeutet, dass das Element gar nicht im Array enthalten ist. Auf der anderen Seite m\u00fcssen wir aber ein int zur\u00fcckgeben. Im Gegensatz zur getMaximum() -Methode oben, gibt es hier jedoch zumindest eine \"L\u00f6sung\" f\u00fcr das Problem, dass das Element nicht enthalten ist. Trotzdem sollte man auf jeden Fall zun\u00e4chst contains() aufrufen und nur, wenn contains() ein true zur\u00fcckliefert, dann die getIndex() -Methode. Zweitens ist die -1 eine sogenannte magic number . Wir sollten ihr einen Namen geben. Wir betrachten die Methode zun\u00e4chst ohne einen Namen f\u00fcr die -1 : 1 2 3 4 5 6 7 8 9 10 11 12 public static int getIndex ( int [] a , int element ) { int indexAtElement = - 1 ; for ( int index = 0 ; index < a . length ; index ++ ) { if ( a [ index ]== element ) { indexAtElement = index ; } } return indexAtElement ; } Wir durchlaufen das Array und sobald wir das element \"finden\" (Zeile 6 ), merken wir uns den aktuellen Index (Zeile 8 ). Am Ende wird der gemerkte Index zur\u00fcckgegeben (Zeile 11 ). Wenn Zeile 8 nie ausgef\u00fchrt wurde, dann wird der initiale Wert von indexAtElement zur\u00fcckgegeben, n\u00e4mlich -1 . Diese -1 ist eine sogenannte magic number . Man kennt die Bedeutung dieses Wertes nicht. Es ist deshalb besser, daf\u00fcr einen Namen einzuf\u00fchren - als Konstante (zu Konstanten siehe hier ). 1 2 3 4 5 6 7 8 9 10 11 12 13 public static int getIndex ( int [] a , int element ) { final int NOT_FOUND = - 1 ; int indexAtElement = NOT_FOUND ; for ( int index = 0 ; index < a . length ; index ++ ) { if ( a [ index ]== element ) { indexAtElement = index ; } } return indexAtElement ; } Eine Konstante ist eine Variable, die genau einmal einen Wert zugewiesen bekommt (initailisiert wird) und deren Wert nie wieder \u00fcberschrieben werden kann. Die Namen von Konstanten schreiben wir durchgehend GROSS. Angenommen, das element kommt mehrmals im Array a vor. Wird der erste Index des Auftretens von element im Array zur\u00fcckgegeben oder der letzte Index? Wie k\u00f6nnte man das \u00e4ndern? Der letzte. Man k\u00f6nnte beim ersten Finden des Elementes die Schleife sofort verlassen (aber nicht break; verwenden!)","title":"Suche in unsortierten Arrays"},{"location":"arrays/#suche-in-sortierten-arrays","text":"In sortierten Arrays sucht es sich etwas schneller nach einem element . Daf\u00fcr gibt es zwei Gr\u00fcnde: einerseits kann eine sequentielle Suche (also das Durchlaufen des Arrays) schneller abgebrochen werden, falls das Element nicht im Array enthalten ist, denn sobald man einen Wert im Array erreicht, der gr\u00f6\u00dfer ist, als der gesuchte Wert, kann das element ja gar nicht mehr vorkommen (falls das Array aufsteigend sortiert ist) andererseits kann man Algorithmen anwenden, die den Suchraum schnell einschr\u00e4nken, eine sogenannte bin\u00e4re Suche . Wir betrachten zun\u00e4chst die sequentielle Suche. Angenommen, wir haben folgendes aufsteigend sortiertes Array: [ 0 , 2 , 2 , 3 , 4 , 4 , 5 , 7 , 8 , 9 , 11 , 11 , 11 , 14 , 16 , 16 , 18 , 18 , 18 , 19 ] und angenommen, wir wollen pr\u00fcfen, ob die 10 im Array enthalten ist. In einem unsortierten Array m\u00fcssten wir das gesamte Array durchlaufen, um zu merken, dass die 10 nicht enthalten ist. Hier, bei dem sortierten Array, merken wir das schon, wenn wir die erste 11 gefunden haben, denn danach kann die 10 nicht mehr kommen. Die contains() -Methode kann also ein weiteres Abbruchkriterium der Suche enthalten: public static boolean containsSorted ( int [] aSorted , int element ) { boolean found = false ; boolean greater = false ; for ( int index = 0 ; index < aSorted . length && ! found && ! greater ; index ++ ) { if ( aSorted [ index ]== element ) { found = true ; } if ( aSorted [ index ]> element ) { greater = true ; } } return found ; } Im Vergleich zur contains() -Methode f\u00fcr unsortierte Arrays haben wir einen weiteren \"Schalter\" hinzugef\u00fcgt, greater . Damit haben wir auch die Bedingung in der for -Schleife erweitert ( && !greater ). Sollten wir das element noch nicht gefunden haben, der Wert aSorted[index] aber gr\u00f6\u00dfer als element sein (Zeile 11 ), setzen wir greater auf true und die Schleife wird verlassen. Funktioniert die contains() -Methode, die wir f\u00fcr unsortierte Arrays implementiert haben, auch f\u00fcr sortierte Arrays? Ja, wir nutzen nur die M\u00f6glichkeit des fr\u00fcheren Abbruchs der Suche nicht aus. Schreiben Sie eine Methode getIndexSorted(int[] aSorted, int element) , die den Index von element in a zur\u00fcckgibt (und sonst -1 ). Genau wie getIndex() f\u00fcr unsortierte Arrays, aber auch hier nutzen Sie die fr\u00fchere Abbruchm\u00f6glichkeit der Suche aus. public static int getIndexSorted ( int [] aSorted , int element ) { final int NOT_FOUND = - 1 ; boolean greater = false ; int indexAtElement = NOT_FOUND ; for ( int index = 0 ; index < aSorted . length && ! greater ; index ++ ) { if ( aSorted [ index ]== element ) { indexAtElement = index ; } if ( aSorted [ index ]> element ) { greater = true ; } } return indexAtElement ; } Bis jetzt sind wir immer sequenziell durch das Array durchgelaufen, also von vorne nach hinten, beginnend mit dem Index 0 bis wir bei array.length angekommen waren. In sortierten Arrays k\u00f6nnen wir das Prinzip \u00e4ndern: Wir fangen einfach in der Mitte des Arrays an und wenn der Wert, den wir suchen, kleiner ist, als der Wert in der Mitte, dann suchen wir links weiter und sonst suchen wir rechts weiter. Dann gehen wir mit der linken bzw. rechten H\u00e4lft egenau so vor usw. Diese Suche nennt sich bin\u00e4re Suche ( binary search ), in jedem Schritt wird der (verbliebene) Suchraum halbiert. Angenommen, wir suchen in dem folgenden Array die 25 : wir ermitteln zun\u00e4chst den Index, der in der Mitte des Arrays ist ( mid ). Dieser ergibt sich aus dem Mittelwert von lo (das ist der kleinste Index, der ist am Anfang 0 ) und hi (das ist der gr\u00f6\u00dfte Index, der ist am Anfang 14 , da unser Beispiel-Array die L\u00e4nge 15 hat). Unserer Index in der Mitte ist also mid=7 . Wir greifen \u00fcber diesen Index mid auf den Wert in dem Array zu; der Wert ist 34 . 34 ist gr\u00f6\u00dfer als die gesuchte 25 \u2192 wir suchen also in dem linken Teil des Arrays weiter. Wir ermitteln den gr\u00f6\u00dften Index hi in diesem Teil (der ist um 1 kleiner als mid davor, also 6 ). Der Wert von lo bleibt 0 . Der neue Wert von mid ist 3 . Wir greifen \u00fcber diesen Index mid auf den Wert in dem Array zu; der Wert ist 16 . 16 ist kleiner als die gesuchte 25 \u2192 wir suchen also in dem rechten Teil des Arrays weiter. Wir ermitteln den gr\u00f6\u00dften Index lo in diesem Teil (der ist um 1 gr\u00f6\u00dfer als mid davor, also 4 ). Der Wert von hi bleibt 6 . Der neue Wert von mid ist 5 . Wir greifen \u00fcber diesen Index mid auf den Wert in dem Array zu; der Wert ist 25 . Wir haben das Element gefunden. Ehe Sie sich die Implementierung der bin\u00e4ren Suche anschauen, sollten Sie in dem Beispiel aus dem Bild noch die 41 suchen. Achten Sie insbesondere darauf, wie sich die Werte von lo , mid und high in jedem Suchschritt \u00e4ndern. wir beginnen mit lo=0 , hi=14 und also mid=7 . Der Wert im Index 7 ist 34 und somit kleiner als die gesuchte 41 \u2192 wir suchen rechts weiter lo=8 , hi=14 und also mid=11 . Der Wert im Index 11 ist 46 und somit gr\u00f6\u00dfer als die gesuchte 41 \u2192 wir suchen links weiter lo=8 , hi=10 und also mid=9 . Der Wert im Index 9 ist 41 \u2192 gefunden Ehe Sie sich die Implementierung der bin\u00e4ren Suche anschauen, sollten Sie in dem Beispiel aus dem Bild noch die 42 suchen. Wann stellen Sie fest, dass die 42 nicht im Array enthalten ist? wir beginnen mit lo=0 , hi=14 und also mid=7 . Der Wert im Index 7 ist 34 und somit kleiner als die gesuchte 42 \u2192 wir suchen rechts weiter lo=8 , hi=14 und also mid=11 . Der Wert im Index 11 ist 46 und somit gr\u00f6\u00dfer als die gesuchte 42 \u2192 wir suchen links weiter lo=8 , hi=10 und also mid=9 . Der Wert im Index 9 ist 41 und somit kleiner als die gesuchte 42 \u2192 wir suchen rechts weiter lo=10 , hi=10 und also mid=10 . Der Wert im Index 10 ist 46 \u2192 nicht gefunden ( hi und lo haben den gleichen Wert \u2192 zu Ende) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public static boolean containsBinarySearch ( int [] aSorted , int element ) { boolean found = false ; int lo = 0 ; int hi = aSorted . length - 1 ; while ( lo <= hi && ! found ) { int mid = ( hi + lo ) / 2 ; if ( element == aSorted [ mid ] ) // gefunden { found = true ; } else // nicht gefunden { if ( element < aSorted [ mid ] ) // links weitersuchen { hi = mid - 1 ; } else // element > aSorted[mid] rechts weitersuchen { lo = mid + 1 ; } } } return found ; } in Zeile 4 wir die lo -Variable mit dem Index-Wert 0 initialisiert (kleinster Index), in Zeile 5 wir die hi -Variable mit dem Index-Wert aSorted.length-1 initialisiert (gr\u00f6\u00dfter Index), in Zeile 6 steht die Bedingung, wie lange die Suche fortgesetzt werden soll: solange das Element noch nicht gefunden wurde ( !found ) oder solange der kleinere Index lo kleiner (gleich) hi ist; falls element nicht gefunden wurde in Zeile 8 steht die Berechnung des mittleren Index mid . Beachten Sie, dass es sich um eine Integer-Division handelt. Es k\u00f6nnte also auch sein, dass die Summe von lo und hi ungerade ist, aber selbst dann ist mid eine ganze positive Zahl wenn das element gefunden wird (Bedingung in Zeile 9 ist true ), dann wird found auf true gesetzt und die while -Schleife wird verlassen wenn links weiter gesucht wird (Bedingung in Zeile 15 ist true ), dann wird hi neu gesetzt und die Schleifenbedingung erneut gepr\u00fcft wenn rechts weiter gesucht wird (Bedingung in Zeile 15 ist false ), dann wird lo neu gesetzt und die Schleifenbedingung erneut gepr\u00fcft zur\u00fcckgegeben (Zeile 25 ) wird true , wenn das element gefunden wurde (Zeilen 9-12 oder false , wenn es nicht gefunden wurde - initialer Wert von found ) Implementieren Sie eine getIndexBinarySearch() -Methode unter Verwendung des Prinzips der bin\u00e4ren Suche! public static int getIndexBinarySearch ( int [] aSorted , int element ) { boolean found = false ; final int NOT_FOUND = - 1 ; int indexAtElement = NOT_FOUND ; int lo = 0 ; int hi = aSorted . length - 1 ; while ( lo <= hi && ! found ) { int mid = ( hi + lo ) / 2 ; if ( element == aSorted [ mid ] ) // gefunden { found = true ; indexAtElement = mid ; } else // nicht gefunden { if ( element < aSorted [ mid ] ) // links weitersuchen { hi = mid - 1 ; } else // element > aSorted[mid] rechts weitersuchen { lo = mid + 1 ; } } } return indexAtElement ; } Nur zur Info : Mithilfe der bin\u00e4ren Suche ist die Suche nach einem Element in einem sortierten Array enorm beschleunigt. Unter der Komplexit\u00e4t eines Algorithmus wird der Bedarf des Algorithmus an den zur Verf\u00fcgung stehenden Ressourcen Laufzeit (wie schnell?) \u2192 sogenannte Zeitkomplexit\u00e4t Speicherplatz (wie viel Speicherplatz n\u00f6tig?) \u2192 sogenannte Speicherkomplexit\u00e4t verstanden. Die Komplexit\u00e4t eines Algorithmus in Abh\u00e4ngigkeit von der Gr\u00f6\u00dfe n der von ihm bearbeiteten Daten ausgedr\u00fcckt. Daf\u00fcr hat sich die Landau-Notation durchgesetzt. Diese beschreibt mit O(n) sogenannte Komplexit\u00e4tsklassen . Beispielsweise wird die Verkettung von zwei Arrays der L\u00e4nge n und m mit der Komplexit\u00e4tsklasse O(n+m) angegeben (maximale Zeit- und Speicherkomplexit\u00e4t), w\u00e4hrend die Komplexit\u00e4tsklasse der sequentiellen Suche in unsortierten und sortierten Arrays O(n) ist und die bin\u00e4re Suche in sortierten Arrays O(log n) . Wir messen im Folgenden einmal den Zeitverbrauch der Methoden getIndex() , getIndexSorted() und getIndexBinarySearch() unter Verweung der Klassen Instant und Duration aus dem Paket java.time : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int [] test = createAndFillArray ( 100000000 , 10000000 ); Arrays . sort ( test ); Instant start = Instant . now (); int index = getIndex ( test , 80000000 ); Instant finish = Instant . now (); long duration = Duration . between ( start , finish ). toMillis (); System . out . println ( \"index : \" + index + \" duration : \" + duration ); start = Instant . now (); index = getIndexSorted ( test , 80000000 ); finish = Instant . now (); duration = Duration . between ( start , finish ). toMillis (); System . out . println ( \"index : \" + index + \" duration : \" + duration ); start = Instant . now (); index = getIndexBinarySearch ( test , 80000000 ); finish = Instant . now (); duration = Duration . between ( start , finish ). toMillis (); System . out . println ( \"index : \" + index + \" duration : \" + duration ); Zeile 1 : Wir erstellen uns mithilfe der Methode createAndFillArray() ein Array mit 100 Millionen Eintr\u00e4gen. Zeile 2 : Unter Verwendung der Klasse Arrays (aus dem java.util -Paket) wird dieses Array sortiert (die Klasse kennen wir noch nicht). Zeile 3 : Mithilfe der Instant -Klasse (aus java.time ) und deren Methode now() ermitteln wir die aktuelle Zeit und speichern sie in der Variablen start (vom Typ Instant ); die Klasse kennen wir noch nicht Zeile 4 : Wir verwenden die Methode getIndex() , um das Element mit dem Wert 8.000.000 im Array test zu suchen Zeile 5 : Mithilfe Instant.now() ermitteln wir erneut die aktuelle Zeit und speichern sie in der Variablen finish Zeile 6 : wir berechnen die Differenz zwischen finish und start in Millisekunden und speichern sie in der Variablen duration vom Typ long (zur Differenzberechnung verwenden wir die Klassae Duration aus dem java.time -Paket; die Klasse kennen wir noch nicht) Zeile 7 : wir geben die Index und die Dauer der Ausf\u00fchrung aus Zeile 10 : wir wiederholen alles mit der getIndexSorted() -Methode Zeile 16 : wir wiederholen alles mit der getIndexBinarySearch() -Methode Es erfolgt folgende Ausgabe (Element wurde in diesem Fall nicht gefunden): index : -1 duration : 47 index : -1 duration : 94 index : -1 duration : 0 getIndexBinarySearch() verbraucht also (fast) keine Zeit. Es \u00fcberrrascht vielleicht, dass getIndexSorted() doppelt so viel Zeit verbraucht, wie getIndex() . Das liegt aber daran, dass in getIndex() einerseits die Bedingung der for -Schleife nur eine Pr\u00fcfung enth\u00e4lt, w\u00e4hrend es in getIndexSorted() drei Teilbedingungen sind, die verkn\u00fcpft werden m\u00fcssen und es au\u00dferdem in getIndex() innerhalb der for -Schleife nur eine Bedingung zur Pr\u00fcfung gibt, w\u00e4hrend es in getIndexSorted() zwei sind. Da das gesuchte Element mit dem Wert 8 Mio relativ weit hinten im Array liegen w\u00fcrde (der Bereich der Zufallszahlen ist [0 ... 9999999] Zufallszahlen in den 100 Mio Eintr\u00e4gen des Arrays), ist der Vorteil der Suche im sortierten Array hier zu gering. W\u00fcrden wir z.B. stattdessen nach der Zahl 100000 suchen, w\u00e4re das Ergebnis so: index : 1000579 duration : 53 index : 1000579 duration : 4 index : 1000575 duration : 0","title":"Suche in sortierten Arrays"},{"location":"arrays/#einfugen-in-arrays","text":"Hier geht es darum, dass wir ein Element in ein Array einf\u00fcgen wollen. Wir unterscheiden wieder zwischen dem Einf\u00fcgen in ein unsortiertes und dem Einf\u00fcgen in ein sortiertes Array. Wir betrachten zun\u00e4chst das EInf\u00fcgen in ein unsortiertes Array.","title":"Einf\u00fcgen in Arrays"},{"location":"arrays/#einfugen-in-ein-unsortiertes-array","text":"Angenommen, wir haben folgendes int -Array a : und wir wollen ein weiteres Element mit dem Wert 13 einf\u00fcgen. Man k\u00f6nnte auf die Idee kommen, dass die Elemente mit dem Index 10 bis 14 daf\u00fcr zur Verf\u00fcgung stehen, da diese mit dem Standartwert f\u00fcr int , der 0 belegt sind. Aber woher sollen wir wissen, dass dies gar keine \"richtigen\" Werte sind? Da das Array ein unsortiertes int -Array ist, k\u00f6nnen Nullen an allen Stellen vorkommen. Bei dem Einf\u00fcgen in ein unsortiertes Array handelt es sich eigentlich um ein Anh\u00e4ngen ( append ) des neuen Elementes an das alte Array. Wir ben\u00f6tigen dazu ein neues Array, das um 1 l\u00e4nger ist als das urspr\u00fcngliche Array. Wir gehen also wie folgt vor: wir erzeugen ein neues Array b , das um 1 l\u00e4nger ist als das Array a wir kopieren alle Werte aus a nach b wir speichern in das letzte Element von b den neuen Wert element Eine m\u00f6gliche Implementierung daf\u00fcr sieht so aus: 1 2 3 4 5 6 7 8 9 10 11 public static int [] append ( int [] a , int element ) { int [] b = new int [ a . length + 1 ] ; for ( int index = 0 ; index < a . length ; index ++ ) { b [ index ]= a [ index ] ; } b [ b . length - 1 ] = element ; return b ; } in Zeile 3 wird das neue Array b erzeugt, das um 1 \u00e4nger ist als a in den Zeilen 4-7 werden alle Werte aus a nach b kopiert in Zeile 9 wird dem letzten Element von b der Wert element zugewiesen Es geschieht also folgendes: Wir merken uns also: das Einf\u00fcgen in ein unsortiertes Array ist in Wirklichkeit ein Anh\u00e4ngen des Elementes an ein unsortiertes Array. Dazu muss ein neues Array erzeugt werden, das um 1 l\u00e4nger ist als das Array, an das angeh\u00e4ngt werden soll.","title":"Einf\u00fcgen in ein unsortiertes Array"},{"location":"arrays/#einfugen-in-ein-sortiertes-array","text":"Das Einf\u00fcgen in ein sortiertes Array ist deutlich komplizierter, denn das einzuf\u00fcgende Element muss korrekt, d.h. an die richtige Stelle entsprechend der Sortierung, eingef\u00fcgt werden. Angenommen, wir haben folgende Ausgangsposition: Das einzuf\u00fcgende Element mit dem Wert 13 muss zwischen die beiden Elemente mit den Werten 12 und 14 eingef\u00fcgt werden. Wir gehen dabei wie folgt vor: wir erzeugen ein neues Array b , das um 1 l\u00e4nger ist als a wir kopieren alle Werte aus a nach b solange die Werte kleiner sind als das einzuf\u00fcgende Element wenn wir auf das erste Element in a sto\u00dfen, das gr\u00f6\u00dfer ist als das einzuf\u00fcgende Element, f\u00fcgen wir das Element ein danach kopieren wir die restlichen Werte aus a nach b Wir setzen obigen Algorithmus in folgender Methode um: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public static int [] insertIntoSortedArray ( int [] a , int element ) { int [] b = new int [ a . length + 1 ] ; int indexB = 0 , indexA = 0 ; while ( indexA < a . length && a [ indexA ]< element ) { b [ indexB ++]= a [ indexA ++] ; } b [ indexB ++] = element ; // from now on indexB = indexA+1 while ( indexB < b . length ) { b [ indexB ++]= a [ indexA ++] ; } return b ; } in Zeile 3 wird das Array b erzeugt, welches um 1 l\u00e4nger ist als a in Zeilen 5-8 kopieren wir alle Werte aus a nach b , die kleiner sind als unser element in Zeile 10 wird element in b eingef\u00fcgt in Zeilen 12-15 kopieren wir die restlichen Werte aus a nach b Beachten Sie: in der Anweisung b[indexB++]=a[indexA++]; passieren mehrere Sachen auf einmal: einerseits b[indexB]=a[indexA]; und au\u00dferdem noch indexB++; und indexA++ ; nach der Anweisung b[indexB++] = element; ist indexB um 1 gr\u00f6\u00dfer als indexA (was ja auch gut ist, siehe im Bild das \"rote\" Kopieren) Spielen Sie den Fall durch, dass eine 0 in das Beispiel-Array aus der Abbildung eingef\u00fcgt werden soll! Dann wird die erste while -Schleife gar nicht betreten, da die (Teil-)Bedingung a[indexA]<element gleich false ist Spielen Sie den Fall durch, dass eine 27 in das Beispiel-Array aus der Abbildung eingef\u00fcgt werden soll! Dann wird die zweite while -Schleife gar nicht betreten, da die Bedingung indexB<b.length gleich false ist Die Bedingung der ersten while -Schleife lautet indexA<a.length && a[indexA]<element . K\u00f6nnte man das auch umdrehen und a[indexA]<element && indexA<a.length schreiben? Nein, das k\u00f6nnte zu einem Fehler f\u00fchren. Der Operator && hat (im Gegensatz zum Operator & ) die Eigenschaft, dass die zweite Teilbedingung (also a[indexA]<element ) gar nicht mehr gepr\u00fcft wird, wenn die erste bereits false ist. Angenommen, die Teilbedingung indexA<a.length ist false , dann ist indexA==a.length . Dann k\u00f6nnen wir aber nicht mehr mit a[indexA] auf ein Element in a zugreifen, da der Index a.length nicht existiert. Wir w\u00fcrden eine ArrayIndexOutOfBoundsException geworfen bekommen. F\u00fcr den Fall also, dass das neu einzuf\u00fcgende Element ganz an das Ende des neuen Arrays b kommt, muss die Bedingung genau in dieser Reihenfolge formuliert werden. Success Wir kennen jetzt Arrays. Wir k\u00f6nnen sie erzeugen, wir k\u00f6nnen sie miteinander verbinden. Wir k\u00f6nnen Elemente darin suchen, sowohl in sortierten als auch in unsortierten Arrays. Wir k\u00f6nnen Elemente einf\u00fcgen. Bitte beachten Sie, dass die Elemente eines Arrays von jedem beliebigen Typ sein k\u00f6nnen, auch Referenztypen. Jetzt lernen wir noch, wie wir Arrays sortieren k\u00f6nnen und werden uns sp\u00e4ter nochmal mit Arrays besch\u00e4ftigen, deren Elemente von Referenztypen sind und somit Objekte beinhalten. ganz genau geben wir die Referenz auf das copy -Array zur\u00fcck, aber dazu sp\u00e4ter \u21a9","title":"Einf\u00fcgen in ein sortiertes Array"},{"location":"aufgaben/","text":"Aufgaben \u00b6 Hier finden Sie die Aufgaben. Die Abgabefristen der einzelnen Aufgaben stehen hier . Beachten Sie die nachfolgenden Hinweise zum Hochladen der Aufgaben. Hinweise zur Abgabe der Aufgaben \u00b6 Die Aufgaben laden Sie in Moodle unter dem Reiter \"Aufgaben\" hoch. Dort ist f\u00fcr jede Aufgabe eine Moodle-Aufgabe erstellt. Beachten Sie, dass ein Hochladen nach Ablauf der Abgabefrist nicht mehr m\u00f6glich ist. Achten Sie darauf, dass Sie die Quelldateien (also die .java -Dateien aus dem src -Verzeichnis) hochladen. Ihre Klassen erstellen Sie immer in einem package aufgaben.aufgabeX . Das hei\u00dft, Aufgabe1 ist im package aufgaben.aufgabe1 , Aufgabe2 im package aufgaben.aufgabe2 usw. In Ihrem workspace gibt es dann einen Ordner f\u00fcr Ihr Java-Projekt, z.B. WS20 (je nachdem, wie Sie Ihr Java-Projekt genannt haben) und darin befindet sich ein bin - und ein src -Ordner. In dem src -Ordner befindet sich dann ein Ordner aufgaben und darin ein Ordner aufgaben1 (f\u00fcr Aufgabe1). Darin befindet sich Ihre .java -Datei, die Sie hochladen sollen. Angenommen, Sie haben Ihre Klasse Aufgabe1 genannt, dann hei\u00dft die Klasse also Aufgabe1.java . Sie folgen also dem Pfad workspace \u2192 Java-Projekt (z.B. WS20 ) \u2192 src \u2192 aufgaben \u2192 aufgabe X . Wenn Ihre L\u00f6sung aus mehreren Klassen (mehreren .java -Dateien) besteht, k\u00f6nnen Sie entweder die Dateien einzeln hochladen oder Sie zippen Ihre Dateien (am besten dann den aufgabeX -Ordner und laden das .zip -File hoch. In Ihrer L\u00f6sung (Ihrer/n Klasse/n) f\u00fcgen Sie direkt oberhalb Ihrer Klassendefinition einen JavaDoc-Kommentar ein ( /** ... */ ). Dieser enth\u00e4lt ein @author -Tag. dahinter schreiben Sie Ihren Namen. Das sieht dann z.B. so aus: package aufgaben.aufgabe1 ; /** * * @author J\u00f6rn Freiheit * * Diese Klasse gibt auf die Konsole ein Rhombus (eine Raute) aus. * Der Rhombus ist entweder gefuellt oder ungefuellt. * */ public class Aufgabe1 { // hier Ihre Implementierung } Sie k\u00f6nnen Ihre Aufgaben zu zweit l\u00f6sen. Tragen Sie dann hinter das @author -Tag beide Namen ein und laden Sie bitte beide die L\u00f6sung in Moodle hoch! Aufgaben \u00b6 Aufgabe1 - Rhombus Erstellen Sie eine Klasse Aufgabe1 mit main() -Methode im package aufgaben.aufgabe1 Implementieren Sie eine Methode public static void printRhombus(int upperHalf, boolean filled){} Ist der Parameterwert von filled true , dann soll ein Rhombus (eine Raute) wie folgt auf die Konsole ausgegeben werden: * *** ***** ******* ********* *********** ********* ******* ***** *** * Ist der Parameterwert von filled false , dann soll der Rhombus ungef\u00fcllt sein, also so: * * * * * * * * * * * * * * * * * * * * der Wert f\u00fcr upperHalf gibt die H\u00f6he einer H\u00e4lfte des Rhombus an. Die Gesamth\u00f6he des Rhombus berechnet sich aus ` int height = 2 * upperHalf + 1 ; In unserem oben gezeigten Beispiel ist der Wert von upperHalf 5 und die Gesamth\u00f6he des Rhombus 11 . Die obere Ausgabe ist also durch die Anweisung printRhombus(5, true); und die untere durch die Anweisung printRhombus(5, false); entstanden. Die Berechnung der H\u00f6he aus dem Parameterwert upperHalf hat die Vorteile, dass die H\u00f6he dadurch immer eine ungerade Zahl ist (was notwendig ist) und dass Sie den Wert upperHalf gut verwenden k\u00f6nnen (was ebenfalls notwendig ist, wie Sie merken werden) Tipp: : Schreiben Sie sich zwei weitere Methoden public static void printRhombusFilled(int upperHalf){} und public static void printRhombusUnfilled(int upperHalf){} , die Sie entsprechend des Wertes von filled aufrufen. In der einen Methode erstellen Sie die ausgef\u00fcllte Raute und in der anderen die ungef\u00fcllte. Dann wird Ihr Programm nicht zu un\u00fcbersichtlich. Fangen Sie am besten mit der ausgef\u00fcllten an, die ist etwas leichter. Das Programm soll f\u00fcr beliebige (nicht so gro\u00dfe - max. Wert 100 ) positive Zahlen (also > 0 ) von upperHalf funktionieren. Insbesondere sind die Tests f\u00fcr upperhalf == 1 interssant. Laden Sie Ihre L\u00f6sung bis Sonntag, den 22.11.2020 um 24.00 Uhr in Moodle hoch Viel Spa\u00df und viel Erfolg! Eine m\u00f6gliche L\u00f6sung f\u00fcr Aufgabe 1 package aufgaben.aufgabe1 ; public class Aufgabe1 { public static void printRhombus ( int upperHalf , boolean filled ) { if ( filled ) { printRhombusFilled ( upperHalf ); } else { printRhombusUnfilled ( upperHalf ); } } /* * 0: upperHalf LZ * * 1: upperHalf-1 LZ * * 2: upperHalf-2 LZ * * ... */ public static void printRhombusFilled ( int upperHalf ) { int height = 2 * upperHalf + 1 ; for ( int row = 0 ; row < height ; row ++ ) { /* System.out.printf(\"row : %3d (height-row) : %3d (upperHalf - row) : %3d \", row, (height-row), (upperHalf - row)); */ if ( row <= upperHalf ) { for ( int spaces = 0 ; spaces < ( upperHalf - row ); spaces ++ ) { System . out . print ( \" \" ); } for ( int stars = 0 ; stars < ( row * 2 + 1 ); stars ++ ) { System . out . print ( \"*\" ); } System . out . println (); } else // row > upperHalf { for ( int spaces = 0 ; spaces < ( row - upperHalf ); spaces ++ ) { System . out . print ( \" \" ); } for ( int stars = 0 ; stars < ( height - row ) * 2 - 1 ; stars ++ ) { System . out . print ( \"*\" ); } System . out . println (); } } } public static void printRhombusUnfilled ( int upperHalf ) { int height = 2 * upperHalf + 1 ; for ( int row = 0 ; row < height ; row ++ ) { if ( row <= upperHalf ) { for ( int spaces = 0 ; spaces < ( upperHalf - row ); spaces ++ ) { System . out . print ( \" \" ); } System . out . print ( \"*\" ); for ( int spaces = 0 ; spaces < ( row - 1 ) * 2 + 1 ; spaces ++ ) { System . out . print ( \" \" ); } if ( row == 0 ) { System . out . println (); } else { System . out . println ( \"*\" ); } } else // row > upperHalf { for ( int spaces = 0 ; spaces < ( row - upperHalf ); spaces ++ ) { System . out . print ( \" \" ); } System . out . print ( \"*\" ); for ( int spaces = 0 ; spaces < ( height - row - 1 ) * 2 - 1 ; spaces ++ ) { System . out . print ( \" \" ); } if ( row == ( height - 1 )) { System . out . println (); } else { System . out . println ( \"*\" ); } } } } public static void main ( String [] args ) { printRhombus ( 6 , true ); System . out . println (); printRhombus ( 1 , false ); } } Video zu Aufgabe 1 - sorry f\u00fcr die L\u00fcfterger\u00e4usche!!! nervig! Aufgabe 2 - \u03c0 kodieren Die Zahl \u03c0 ist eine irrationale Zahl, d.h. sie kann nicht als Bruch dargestellt werden. Au\u00dferdem ist sie nicht periodisch, d.h. es gibt keine immer wiederkehrende Folge von Ziffern im Nachkommabereich. Die Zahl \u03c0 hat unendlich viele Nachkommastellen und da sie nicht periodisch ist, kommen alle m\u00f6glichen Ziffernfolge in \u03c0 vor. Beispielsweise kommt die Ziffernfolge 123456 allein in den ersten 200 Millionen Nachkommastellen 208 Mal vor. Angenommen, wir \u201ecodieren\u201c \u03c0 und weisen einer Ziffer einen Buchstaben zu, z.B. Dann erg\u00e4be z.B. die Ziffernfolge 45923078 codiert das Wort \u201eCOMPUTER\u201c. Dieses Wort \u201eerscheint\u201c unter dieser Codierung an folgender Stelle: 3.14159265358979323846264338327950288419716939937510582097494 45923078 164062862089986280348253421170679 Ihre Aufgabe: Suchen Sie die 4-stellige Ziffernfolge, die am h\u00e4ufigsten in (den ersten 100 000 Nachkommastellen von) \u03c0 vorkommt. Hier der String, der alle diese Nachkommastellen enth\u00e4lt (kopieren Sie diese Deklaration und Initialisierung in Ihr Programm - wahrscheinlich am besten in main() ): Variable String pi String pi = \"3\" + \"141592653589793238462643383279502884197169399375105820974944592307816406286\" + \"208998628034825342117067982148086513282306647093844609550582231725359408128481\" + \"117450284102701938521105559644622948954930381964428810975665933446128475648233\" + \"786783165271201909145648566923460348610454326648213393607260249141273724587006\" + \"606315588174881520920962829254091715364367892590360011330530548820466521384146\" + \"951941511609433057270365759591953092186117381932611793105118548074462379962749\" + \"567351885752724891227938183011949129833673362440656643086021394946395224737190\" + \"702179860943702770539217176293176752384674818467669405132000568127145263560827\" + \"785771342757789609173637178721468440901224953430146549585371050792279689258923\" + \"542019956112129021960864034418159813629774771309960518707211349999998372978049\" + \"951059731732816096318595024459455346908302642522308253344685035261931188171010\" + \"003137838752886587533208381420617177669147303598253490428755468731159562863882\" + \"353787593751957781857780532171226806613001927876611195909216420198938095257201\" + \"065485863278865936153381827968230301952035301852968995773622599413891249721775\" + \"283479131515574857242454150695950829533116861727855889075098381754637464939319\" + \"255060400927701671139009848824012858361603563707660104710181942955596198946767\" + \"837449448255379774726847104047534646208046684259069491293313677028989152104752\" + \"162056966024058038150193511253382430035587640247496473263914199272604269922796\" + \"782354781636009341721641219924586315030286182974555706749838505494588586926995\" + \"690927210797509302955321165344987202755960236480665499119881834797753566369807\" + \"426542527862551818417574672890977772793800081647060016145249192173217214772350\" + \"141441973568548161361157352552133475741849468438523323907394143334547762416862\" + \"518983569485562099219222184272550254256887671790494601653466804988627232791786\" + \"085784383827967976681454100953883786360950680064225125205117392984896084128488\" + \"626945604241965285022210661186306744278622039194945047123713786960956364371917\" + \"287467764657573962413890865832645995813390478027590099465764078951269468398352\" + \"595709825822620522489407726719478268482601476990902640136394437455305068203496\" + \"252451749399651431429809190659250937221696461515709858387410597885959772975498\" + \"930161753928468138268683868942774155991855925245953959431049972524680845987273\" + \"644695848653836736222626099124608051243884390451244136549762780797715691435997\" + \"700129616089441694868555848406353422072225828488648158456028506016842739452267\" + \"467678895252138522549954666727823986456596116354886230577456498035593634568174\" + \"324112515076069479451096596094025228879710893145669136867228748940560101503308\" + \"617928680920874760917824938589009714909675985261365549781893129784821682998948\" + \"722658804857564014270477555132379641451523746234364542858444795265867821051141\" + \"354735739523113427166102135969536231442952484937187110145765403590279934403742\" + \"007310578539062198387447808478489683321445713868751943506430218453191048481005\" + \"370614680674919278191197939952061419663428754440643745123718192179998391015919\" + \"561814675142691239748940907186494231961567945208095146550225231603881930142093\" + \"762137855956638937787083039069792077346722182562599661501421503068038447734549\" + \"202605414665925201497442850732518666002132434088190710486331734649651453905796\" + \"268561005508106658796998163574736384052571459102897064140110971206280439039759\" + \"515677157700420337869936007230558763176359421873125147120532928191826186125867\" + \"321579198414848829164470609575270695722091756711672291098169091528017350671274\" + \"858322287183520935396572512108357915136988209144421006751033467110314126711136\" + \"990865851639831501970165151168517143765761835155650884909989859982387345528331\" + \"635507647918535893226185489632132933089857064204675259070915481416549859461637\" + \"180270981994309924488957571282890592323326097299712084433573265489382391193259\" + \"746366730583604142813883032038249037589852437441702913276561809377344403070746\" + \"921120191302033038019762110110044929321516084244485963766983895228684783123552\" + \"658213144957685726243344189303968642624341077322697802807318915441101044682325\" + \"271620105265227211166039666557309254711055785376346682065310989652691862056476\" + \"931257058635662018558100729360659876486117910453348850346113657686753249441668\" + \"039626579787718556084552965412665408530614344431858676975145661406800700237877\" + \"659134401712749470420562230538994561314071127000407854733269939081454664645880\" + \"797270826683063432858785698305235808933065757406795457163775254202114955761581\" + \"400250126228594130216471550979259230990796547376125517656751357517829666454779\" + \"174501129961489030463994713296210734043751895735961458901938971311179042978285\" + \"647503203198691514028708085990480109412147221317947647772622414254854540332157\" + \"185306142288137585043063321751829798662237172159160771669254748738986654949450\" + \"114654062843366393790039769265672146385306736096571209180763832716641627488880\" + \"078692560290228472104031721186082041900042296617119637792133757511495950156604\" + \"963186294726547364252308177036751590673502350728354056704038674351362222477158\" + \"915049530984448933309634087807693259939780541934144737744184263129860809988868\" + \"741326047215695162396586457302163159819319516735381297416772947867242292465436\" + \"680098067692823828068996400482435403701416314965897940924323789690706977942236\" + \"250822168895738379862300159377647165122893578601588161755782973523344604281512\" + \"627203734314653197777416031990665541876397929334419521541341899485444734567383\" + \"162499341913181480927777103863877343177207545654532207770921201905166096280490\" + \"926360197598828161332316663652861932668633606273567630354477628035045077723554\" + \"710585954870279081435624014517180624643626794561275318134078330336254232783944\" + \"975382437205835311477119926063813346776879695970309833913077109870408591337464\" + \"144282277263465947047458784778720192771528073176790770715721344473060570073349\" + \"243693113835049316312840425121925651798069411352801314701304781643788518529092\" + \"854520116583934196562134914341595625865865570552690496520985803385072242648293\" + \"972858478316305777756068887644624824685792603953527734803048029005876075825104\" + \"747091643961362676044925627420420832085661190625454337213153595845068772460290\" + \"161876679524061634252257719542916299193064553779914037340432875262888963995879\" + \"475729174642635745525407909145135711136941091193932519107602082520261879853188\" + \"770584297259167781314969900901921169717372784768472686084900337702424291651300\" + \"500516832336435038951702989392233451722013812806965011784408745196012122859937\" + \"162313017114448464090389064495444006198690754851602632750529834918740786680881\" + \"833851022833450850486082503930213321971551843063545500766828294930413776552793\" + \"975175461395398468339363830474611996653858153842056853386218672523340283087112\" + \"328278921250771262946322956398989893582116745627010218356462201349671518819097\" + \"303811980049734072396103685406643193950979019069963955245300545058068550195673\" + \"022921913933918568034490398205955100226353536192041994745538593810234395544959\" + \"778377902374216172711172364343543947822181852862408514006660443325888569867054\" + \"315470696574745855033232334210730154594051655379068662733379958511562578432298\" + \"827372319898757141595781119635833005940873068121602876496286744604774649159950\" + \"549737425626901049037781986835938146574126804925648798556145372347867330390468\" + \"838343634655379498641927056387293174872332083760112302991136793862708943879936\" + \"201629515413371424892830722012690147546684765357616477379467520049075715552781\" + \"965362132392640616013635815590742202020318727760527721900556148425551879253034\" + \"351398442532234157623361064250639049750086562710953591946589751413103482276930\" + \"624743536325691607815478181152843667957061108615331504452127473924544945423682\" + \"886061340841486377670096120715124914043027253860764823634143346235189757664521\" + \"641376796903149501910857598442391986291642193994907236234646844117394032659184\" + \"044378051333894525742399508296591228508555821572503107125701266830240292952522\" + \"011872676756220415420516184163484756516999811614101002996078386909291603028840\" + \"026910414079288621507842451670908700069928212066041837180653556725253256753286\" + \"129104248776182582976515795984703562226293486003415872298053498965022629174878\" + \"820273420922224533985626476691490556284250391275771028402799806636582548892648\" + \"802545661017296702664076559042909945681506526530537182941270336931378517860904\" + \"070866711496558343434769338578171138645587367812301458768712660348913909562009\" + \"939361031029161615288138437909904231747336394804575931493140529763475748119356\" + \"709110137751721008031559024853090669203767192203322909433467685142214477379393\" + \"751703443661991040337511173547191855046449026365512816228824462575916333039107\" + \"225383742182140883508657391771509682887478265699599574490661758344137522397096\" + \"834080053559849175417381883999446974867626551658276584835884531427756879002909\" + \"517028352971634456212964043523117600665101241200659755851276178583829204197484\" + \"423608007193045761893234922927965019875187212726750798125547095890455635792122\" + \"103334669749923563025494780249011419521238281530911407907386025152274299581807\" + \"247162591668545133312394804947079119153267343028244186041426363954800044800267\" + \"049624820179289647669758318327131425170296923488962766844032326092752496035799\" + \"646925650493681836090032380929345958897069536534940603402166544375589004563288\" + \"225054525564056448246515187547119621844396582533754388569094113031509526179378\" + \"002974120766514793942590298969594699556576121865619673378623625612521632086286\" + \"922210327488921865436480229678070576561514463204692790682120738837781423356282\" + \"360896320806822246801224826117718589638140918390367367222088832151375560037279\" + \"839400415297002878307667094447456013455641725437090697939612257142989467154357\" + \"846878861444581231459357198492252847160504922124247014121478057345510500801908\" + \"699603302763478708108175450119307141223390866393833952942578690507643100638351\" + \"983438934159613185434754649556978103829309716465143840700707360411237359984345\" + \"225161050702705623526601276484830840761183013052793205427462865403603674532865\" + \"105706587488225698157936789766974220575059683440869735020141020672358502007245\" + \"225632651341055924019027421624843914035998953539459094407046912091409387001264\" + \"560016237428802109276457931065792295524988727584610126483699989225695968815920\" + \"560010165525637567856672279661988578279484885583439751874454551296563443480396\" + \"642055798293680435220277098429423253302257634180703947699415979159453006975214\" + \"829336655566156787364005366656416547321704390352132954352916941459904160875320\" + \"186837937023488868947915107163785290234529244077365949563051007421087142613497\" + \"459561513849871375704710178795731042296906667021449863746459528082436944578977\" + \"233004876476524133907592043401963403911473202338071509522201068256342747164602\" + \"433544005152126693249341967397704159568375355516673027390074972973635496453328\" + \"886984406119649616277344951827369558822075735517665158985519098666539354948106\" + \"887320685990754079234240230092590070173196036225475647894064754834664776041146\" + \"323390565134330684495397907090302346046147096169688688501408347040546074295869\" + \"913829668246818571031887906528703665083243197440477185567893482308943106828702\" + \"722809736248093996270607472645539925399442808113736943388729406307926159599546\" + \"262462970706259484556903471197299640908941805953439325123623550813494900436427\" + \"852713831591256898929519642728757394691427253436694153236100453730488198551706\" + \"594121735246258954873016760029886592578662856124966552353382942878542534048308\" + \"330701653722856355915253478445981831341129001999205981352205117336585640782648\" + \"494276441137639386692480311836445369858917544264739988228462184490087776977631\" + \"279572267265556259628254276531830013407092233436577916012809317940171859859993\" + \"384923549564005709955856113498025249906698423301735035804408116855265311709957\" + \"089942732870925848789443646005041089226691783525870785951298344172953519537885\" + \"534573742608590290817651557803905946408735061232261120093731080485485263572282\" + \"576820341605048466277504500312620080079980492548534694146977516493270950493463\" + \"938243222718851597405470214828971117779237612257887347718819682546298126868581\" + \"705074027255026332904497627789442362167411918626943965067151577958675648239939\" + \"176042601763387045499017614364120469218237076488783419689686118155815873606293\" + \"860381017121585527266830082383404656475880405138080163363887421637140643549556\" + \"186896411228214075330265510042410489678352858829024367090488711819090949453314\" + \"421828766181031007354770549815968077200947469613436092861484941785017180779306\" + \"810854690009445899527942439813921350558642219648349151263901280383200109773868\" + \"066287792397180146134324457264009737425700735921003154150893679300816998053652\" + \"027600727749674584002836240534603726341655425902760183484030681138185510597970\" + \"566400750942608788573579603732451414678670368809880609716425849759513806930944\" + \"940151542222194329130217391253835591503100333032511174915696917450271494331515\" + \"588540392216409722910112903552181576282328318234254832611191280092825256190205\" + \"263016391147724733148573910777587442538761174657867116941477642144111126358355\" + \"387136101102326798775641024682403226483464176636980663785768134920453022408197\" + \"278564719839630878154322116691224641591177673225326433568614618654522268126887\" + \"268445968442416107854016768142080885028005414361314623082102594173756238994207\" + \"571362751674573189189456283525704413354375857534269869947254703165661399199968\" + \"262824727064133622217892390317608542894373393561889165125042440400895271983787\" + \"386480584726895462438823437517885201439560057104811949884239060613695734231559\" + \"079670346149143447886360410318235073650277859089757827273130504889398900992391\" + \"350337325085598265586708924261242947367019390772713070686917092646254842324074\" + \"855036608013604668951184009366860954632500214585293095000090715105823626729326\" + \"453738210493872499669933942468551648326113414611068026744663733437534076429402\" + \"668297386522093570162638464852851490362932019919968828517183953669134522244470\" + \"804592396602817156551565666111359823112250628905854914509715755390024393153519\" + \"090210711945730024388017661503527086260253788179751947806101371500448991721002\" + \"220133501310601639154158957803711779277522597874289191791552241718958536168059\" + \"474123419339842021874564925644346239253195313510331147639491199507285843065836\" + \"193536932969928983791494193940608572486396883690326556436421664425760791471086\" + \"998431573374964883529276932822076294728238153740996154559879825989109371712621\" + \"828302584811238901196822142945766758071865380650648702613389282299497257453033\" + \"283896381843944770779402284359883410035838542389735424395647555684095224844554\" + \"139239410001620769363684677641301781965937997155746854194633489374843912974239\" + \"143365936041003523437770658886778113949861647874714079326385873862473288964564\" + \"359877466763847946650407411182565837887845485814896296127399841344272608606187\" + \"245545236064315371011274680977870446409475828034876975894832824123929296058294\" + \"861919667091895808983320121031843034012849511620353428014412761728583024355983\" + \"003204202451207287253558119584014918096925339507577840006746552603144616705082\" + \"768277222353419110263416315714740612385042584598841990761128725805911393568960\" + \"143166828317632356732541707342081733223046298799280490851409479036887868789493\" + \"054695570307261900950207643349335910602454508645362893545686295853131533718386\" + \"826561786227363716975774183023986006591481616404944965011732131389574706208847\" + \"480236537103115089842799275442685327797431139514357417221975979935968525228574\" + \"526379628961269157235798662057340837576687388426640599099350500081337543245463\" + \"596750484423528487470144354541957625847356421619813407346854111766883118654489\" + \"377697956651727966232671481033864391375186594673002443450054499539974237232871\" + \"249483470604406347160632583064982979551010954183623503030945309733583446283947\" + \"630477564501500850757894954893139394489921612552559770143685894358587752637962\" + \"559708167764380012543650237141278346792610199558522471722017772370041780841942\" + \"394872540680155603599839054898572354674564239058585021671903139526294455439131\" + \"663134530893906204678438778505423939052473136201294769187497519101147231528932\" + \"677253391814660730008902776896311481090220972452075916729700785058071718638105\" + \"496797310016787085069420709223290807038326345345203802786099055690013413718236\" + \"837099194951648960075504934126787643674638490206396401976668559233565463913836\" + \"318574569814719621084108096188460545603903845534372914144651347494078488442377\" + \"217515433426030669883176833100113310869042193903108014378433415137092435301367\" + \"763108491351615642269847507430329716746964066653152703532546711266752246055119\" + \"958183196376370761799191920357958200759560530234626775794393630746305690108011\" + \"494271410093913691381072581378135789400559950018354251184172136055727522103526\" + \"803735726527922417373605751127887218190844900617801388971077082293100279766593\" + \"583875890939568814856026322439372656247277603789081445883785501970284377936240\" + \"782505270487581647032458129087839523245323789602984166922548964971560698119218\" + \"658492677040395648127810217991321741630581055459880130048456299765112124153637\" + \"451500563507012781592671424134210330156616535602473380784302865525722275304999\" + \"883701534879300806260180962381516136690334111138653851091936739383522934588832\" + \"255088706450753947395204396807906708680644509698654880168287434378612645381583\" + \"428075306184548590379821799459968115441974253634439960290251001588827216474500\" + \"682070419376158454712318346007262933955054823955713725684023226821301247679452\" + \"264482091023564775272308208106351889915269288910845557112660396503439789627825\" + \"001611015323516051965590421184494990778999200732947690586857787872098290135295\" + \"661397888486050978608595701773129815531495168146717695976099421003618355913877\" + \"781769845875810446628399880600616229848616935337386578773598336161338413385368\" + \"421197893890018529569196780455448285848370117096721253533875862158231013310387\" + \"766827211572694951817958975469399264219791552338576623167627547570354699414892\" + \"904130186386119439196283887054367774322427680913236544948536676800000106526248\" + \"547305586159899914017076983854831887501429389089950685453076511680333732226517\" + \"566220752695179144225280816517166776672793035485154204023817460892328391703275\" + \"425750867655117859395002793389592057668278967764453184040418554010435134838953\" + \"120132637836928358082719378312654961745997056745071833206503455664403449045362\" + \"756001125018433560736122276594927839370647842645676338818807565612168960504161\" + \"139039063960162022153684941092605387688714837989559999112099164646441191856827\" + \"700457424343402167227644558933012778158686952506949936461017568506016714535431\" + \"581480105458860564550133203758645485840324029871709348091055621167154684847780\" + \"394475697980426318099175642280987399876697323769573701580806822904599212366168\" + \"902596273043067931653114940176473769387351409336183321614280214976339918983548\" + \"487562529875242387307755955595546519639440182184099841248982623673771467226061\" + \"633643296406335728107078875816404381485018841143188598827694490119321296827158\" + \"884133869434682859006664080631407775772570563072940049294030242049841656547973\" + \"670548558044586572022763784046682337985282710578431975354179501134727362577408\" + \"021347682604502285157979579764746702284099956160156910890384582450267926594205\" + \"550395879229818526480070683765041836562094555434613513415257006597488191634135\" + \"955671964965403218727160264859304903978748958906612725079482827693895352175362\" + \"185079629778514618843271922322381015874445052866523802253284389137527384589238\" + \"442253547265309817157844783421582232702069028723233005386216347988509469547200\" + \"479523112015043293226628272763217790884008786148022147537657810581970222630971\" + \"749507212724847947816957296142365859578209083073323356034846531873029302665964\" + \"501371837542889755797144992465403868179921389346924474198509733462679332107268\" + \"687076806263991936196504409954216762784091466985692571507431574079380532392523\" + \"947755744159184582156251819215523370960748332923492103451462643744980559610330\" + \"799414534778457469999212859999939961228161521931488876938802228108300198601654\" + \"941654261696858678837260958774567618250727599295089318052187292461086763995891\" + \"614585505839727420980909781729323930106766386824040111304024700735085782872462\" + \"713494636853181546969046696869392547251941399291465242385776255004748529547681\" + \"479546700705034799958886769501612497228204030399546327883069597624936151010243\" + \"655535223069061294938859901573466102371223547891129254769617600504797492806072\" + \"126803922691102777226102544149221576504508120677173571202718024296810620377657\" + \"883716690910941807448781404907551782038565390991047759414132154328440625030180\" + \"275716965082096427348414695726397884256008453121406593580904127113592004197598\" + \"513625479616063228873618136737324450607924411763997597461938358457491598809766\" + \"744709300654634242346063423747466608043170126005205592849369594143408146852981\" + \"505394717890045183575515412522359059068726487863575254191128887737176637486027\" + \"660634960353679470269232297186832771739323619200777452212624751869833495151019\" + \"864269887847171939664976907082521742336566272592844062043021411371992278526998\" + \"469884770232382384005565551788908766136013047709843861168705231055314916251728\" + \"373272867600724817298763756981633541507460883866364069347043720668865127568826\" + \"614973078865701568501691864748854167915459650723428773069985371390430026653078\" + \"398776385032381821553559732353068604301067576083890862704984188859513809103042\" + \"359578249514398859011318583584066747237029714978508414585308578133915627076035\" + \"639076394731145549583226694570249413983163433237897595568085683629725386791327\" + \"505554252449194358912840504522695381217913191451350099384631177401797151228378\" + \"546011603595540286440590249646693070776905548102885020808580087811577381719174\" + \"177601733073855475800605601433774329901272867725304318251975791679296996504146\" + \"070664571258883469797964293162296552016879730003564630457930884032748077181155\" + \"533090988702550520768046303460865816539487695196004408482065967379473168086415\" + \"645650530049881616490578831154345485052660069823093157776500378070466126470602\" + \"145750579327096204782561524714591896522360839664562410519551052235723973951288\" + \"181640597859142791481654263289200428160913693777372229998332708208296995573772\" + \"737566761552711392258805520189887620114168005468736558063347160373429170390798\" + \"639652296131280178267971728982293607028806908776866059325274637840539769184808\" + \"204102194471971386925608416245112398062011318454124478205011079876071715568315\" + \"407886543904121087303240201068534194723047666672174986986854707678120512473679\" + \"247919315085644477537985379973223445612278584329684664751333657369238720146472\" + \"367942787004250325558992688434959287612400755875694641370562514001179713316620\" + \"715371543600687647731867558714878398908107429530941060596944315847753970094398\" + \"839491443235366853920994687964506653398573888786614762944341401049888993160051\" + \"207678103588611660202961193639682134960750111649832785635316145168457695687109\" + \"002999769841263266502347716728657378579085746646077228341540311441529418804782\" + \"543876177079043000156698677679576090996693607559496515273634981189641304331166\" + \"277471233881740603731743970540670310967676574869535878967003192586625941051053\" + \"358438465602339179674926784476370847497833365557900738419147319886271352595462\" + \"518160434225372996286326749682405806029642114638643686422472488728343417044157\" + \"348248183330164056695966886676956349141632842641497453334999948000266998758881\" + \"593507357815195889900539512085351035726137364034367534714104836017546488300407\" + \"846416745216737190483109676711344349481926268111073994825060739495073503169019\" + \"731852119552635632584339099822498624067031076831844660729124874754031617969941\" + \"139738776589986855417031884778867592902607004321266617919223520938227878880988\" + \"633599116081923535557046463491132085918979613279131975649097600013996234445535\" + \"014346426860464495862476909434704829329414041114654092398834443515913320107739\" + \"441118407410768498106634724104823935827401944935665161088463125678529776973468\" + \"430306146241803585293315973458303845541033701091676776374276210213701354854450\" + \"926307190114731848574923318167207213727935567952844392548156091372812840633303\" + \"937356242001604566455741458816605216660873874804724339121295587776390696903707\" + \"882852775389405246075849623157436917113176134783882719416860662572103685132156\" + \"647800147675231039357860689611125996028183930954870905907386135191459181951029\" + \"732787557104972901148717189718004696169777001791391961379141716270701895846921\" + \"434369676292745910994006008498356842520191559370370101104974733949387788598941\" + \"743303178534870760322198297057975119144051099423588303454635349234982688362404\" + \"332726741554030161950568065418093940998202060999414021689090070821330723089662\" + \"119775530665918814119157783627292746156185710372172471009521423696483086410259\" + \"288745799932237495519122195190342445230753513380685680735446499512720317448719\" + \"540397610730806026990625807602029273145525207807991418429063884437349968145827\" + \"337207266391767020118300464819000241308350884658415214899127610651374153943565\" + \"721139032857491876909441370209051703148777346165287984823533829726013611098451\" + \"484182380812054099612527458088109948697221612852489742555551607637167505489617\" + \"301680961380381191436114399210638005083214098760459930932485102516829446726066\" + \"613815174571255975495358023998314698220361338082849935670557552471290274539776\" + \"214049318201465800802156653606776550878380430413431059180460680083459113664083\" + \"488740800574127258670479225831912741573908091438313845642415094084913391809684\" + \"025116399193685322555733896695374902662092326131885589158083245557194845387562\" + \"878612885900410600607374650140262782402734696252821717494158233174923968353013\" + \"617865367376064216677813773995100658952887742766263684183068019080460984980946\" + \"976366733566228291513235278880615776827815958866918023894033307644191240341202\" + \"231636857786035727694154177882643523813190502808701857504704631293335375728538\" + \"660588890458311145077394293520199432197117164223500564404297989208159430716701\" + \"985746927384865383343614579463417592257389858800169801475742054299580124295810\" + \"545651083104629728293758416116253256251657249807849209989799062003593650993472\" + \"158296517413579849104711166079158743698654122234834188772292944633517865385673\" + \"196255985202607294767407261676714557364981210567771689348491766077170527718760\" + \"119990814411305864557791052568430481144026193840232247093924980293355073184589\" + \"035539713308844617410795916251171486487446861124760542867343670904667846867027\" + \"409188101424971114965781772427934707021668829561087779440504843752844337510882\" + \"826477197854000650970403302186255614733211777117441335028160884035178145254196\" + \"432030957601869464908868154528562134698835544456024955666843660292219512483091\" + \"060537720198021831010327041783866544718126039719068846237085751808003532704718\" + \"565949947612424811099928867915896904956394762460842406593094862150769031498702\" + \"067353384834955083636601784877106080980426924713241000946401437360326564518456\" + \"679245666955100150229833079849607994988249706172367449361226222961790814311414\" + \"660941234159359309585407913908720832273354957208075716517187659944985693795623\" + \"875551617575438091780528029464200447215396280746360211329425591600257073562812\" + \"638733106005891065245708024474937543184149401482119996276453106800663118382376\" + \"163966318093144467129861552759820145141027560068929750246304017351489194576360\" + \"789352855505317331416457050499644389093630843874484783961684051845273288403234\" + \"520247056851646571647713932377551729479512613239822960239454857975458651745878\" + \"771331813875295980941217422730035229650808917770506825924882232215493804837145\" + \"478164721397682096332050830564792048208592047549985732038887639160199524091893\" + \"894557676874973085695595801065952650303626615975066222508406742889826590751063\" + \"756356996821151094966974458054728869363102036782325018232370845979011154847208\" + \"761821247781326633041207621658731297081123075815982124863980721240786887811450\" + \"165582513617890307086087019897588980745664395515741536319319198107057533663373\" + \"803827215279884935039748001589051942087971130805123393322190346624991716915094\" + \"854140187106035460379464337900589095772118080446574396280618671786101715674096\" + \"766208029576657705129120990794430463289294730615951043090222143937184956063405\" + \"618934251305726829146578329334052463502892917547087256484260034962961165413823\" + \"007731332729830500160256724014185152041890701154288579920812198449315699905918\" + \"201181973350012618772803681248199587707020753240636125931343859554254778196114\" + \"293516356122349666152261473539967405158499860355295332924575238881013620234762\" + \"466905581643896786309762736550472434864307121849437348530060638764456627218666\" + \"170123812771562137974614986132874411771455244470899714452288566294244023018479\" + \"120547849857452163469644897389206240194351831008828348024924908540307786387516\" + \"591130287395878709810077271827187452901397283661484214287170553179654307650453\" + \"432460053636147261818096997693348626407743519992868632383508875668359509726557\" + \"481543194019557685043724800102041374983187225967738715495839971844490727914196\" + \"584593008394263702087563539821696205532480321226749891140267852859967340524203\" + \"109179789990571882194939132075343170798002373659098537552023891164346718558290\" + \"685371189795262623449248339249634244971465684659124891855662958932990903523923\" + \"333364743520370770101084388003290759834217018554228386161721041760301164591878\" + \"053936744747205998502358289183369292233732399948043710841965947316265482574809\" + \"948250999183300697656936715968936449334886474421350084070066088359723503953234\" + \"017958255703601693699098867113210979889707051728075585519126993067309925070407\" + \"024556850778679069476612629808225163313639952117098452809263037592242674257559\" + \"989289278370474445218936320348941552104459726188380030067761793138139916205806\" + \"270165102445886924764924689192461212531027573139084047000714356136231699237169\" + \"484813255420091453041037135453296620639210547982439212517254013231490274058589\" + \"206321758949434548906846399313757091034633271415316223280552297297953801880162\" + \"859073572955416278867649827418616421878988574107164906919185116281528548679417\" + \"363890665388576422915834250067361245384916067413734017357277995634104332688356\" + \"950781493137800736235418007061918026732855119194267609122103598746924117283749\" + \"312616339500123959924050845437569850795704622266461900010350049018303415354584\" + \"283376437811198855631877779253720116671853954183598443830520376281944076159410\" + \"682071697030228515225057312609304689842343315273213136121658280807521263154773\" + \"060442377475350595228717440266638914881717308643611138906942027908814311944879\" + \"941715404210341219084709408025402393294294549387864023051292711909751353600092\" + \"197110541209668311151632870542302847007312065803262641711616595761327235156666\" + \"253667271899853419989523688483099930275741991646384142707798870887422927705389\" + \"122717248632202889842512528721782603050099451082478357290569198855546788607946\" + \"280537122704246654319214528176074148240382783582971930101788834567416781139895\" + \"475044833931468963076339665722672704339321674542182455706252479721997866854279\" + \"897799233957905758189062252547358220523642485078340711014498047872669199018643\" + \"882293230538231855973286978092225352959101734140733488476100556401824239219269\" + \"506208318381454698392366461363989101210217709597670490830508185470419466437131\" + \"229969235889538493013635657618610606222870559942337163102127845744646398973818\" + \"856674626087948201864748767272722206267646533809980196688368099415907577685263\" + \"986514625333631245053640261056960551318381317426118442018908885319635698696279\" + \"503673842431301133175330532980201668881748134298868158557781034323175306478498\" + \"321062971842518438553442762012823457071698853051832617964117857960888815032960\" + \"229070561447622091509473903594664691623539680920139457817589108893199211226007\" + \"392814916948161527384273626429809823406320024402449589445612916704950823581248\" + \"739179964864113348032475777521970893277226234948601504665268143987705161531702\" + \"669692970492831628550421289814670619533197026950721437823047687528028735412616\" + \"639170824592517001071418085480063692325946201900227808740985977192180515853214\" + \"739265325155903541020928466592529991435379182531454529059841581763705892790690\" + \"989691116438118780943537152133226144362531449012745477269573939348154691631162\" + \"492887357471882407150399500944673195431619385548520766573882513963916357672315\" + \"100555603726339486720820780865373494244011579966750736071115935133195919712094\" + \"896471755302453136477094209463569698222667377520994516845064362382421185353488\" + \"798939567318780660610788544000550827657030558744854180577889171920788142335113\" + \"866292966717964346876007704799953788338787034871802184243734211227394025571769\" + \"081960309201824018842705704609262256417837526526335832424066125331152942345796\" + \"556950250681001831090041124537901533296615697052237921032570693705109083078947\" + \"999900499939532215362274847660361367769797856738658467093667958858378879562594\" + \"646489137665219958828693380183601193236857855855819555604215625088365020332202\" + \"451376215820461810670519533065306060650105488716724537794283133887163139559690\" + \"583208341689847606560711834713621812324622725884199028614208728495687963932546\" + \"428534307530110528571382964370999035694888528519040295604734613113826387889755\" + \"178856042499874831638280404684861893818959054203988987265069762020199554841265\" + \"000539442820393012748163815853039643992547020167275932857436666164411096256633\" + \"730540921951967514832873480895747777527834422109107311135182804603634719818565\" + \"557295714474768255285786334934285842311874944000322969069775831590385803935352\" + \"135886007960034209754739229673331064939560181223781285458431760556173386112673\" + \"478074585067606304822940965304111830667108189303110887172816751957967534718853\" + \"722930961614320400638132246584111115775835858113501856904781536893813771847281\" + \"475199835050478129771859908470762197460588742325699582889253504193795826061621\" + \"184236876851141831606831586799460165205774052942305360178031335726326705479033\" + \"840125730591233960188013782542192709476733719198728738524805742124892118347087\" + \"662966720727232565056512933312605950577772754247124164831283298207236175057467\" + \"387012820957554430596839555568686118839713552208445285264008125202766555767749\" + \"596962661260456524568408613923826576858338469849977872670655519185446869846947\" + \"849573462260629421962455708537127277652309895545019303773216664918257815467729\" + \"200521266714346320963789185232321501897612603437368406719419303774688099929687\" + \"758244104787812326625318184596045385354383911449677531286426092521153767325886\" + \"672260404252349108702695809964759580579466397341906401003636190404203311357933\" + \"654242630356145700901124480089002080147805660371015412232889146572239314507607\" + \"167064355682743774396578906797268743847307634645167756210309860409271709095128\" + \"086309029738504452718289274968921210667008164858339553773591913695015316201890\" + \"888748421079870689911480466927065094076204650277252865072890532854856143316081\" + \"269300569378541786109696920253886503457718317668688592368148847527649846882194\" + \"973972970773718718840041432312763650481453112285099002074240925585925292610302\" + \"106736815434701525234878635164397623586041919412969769040526483234700991115424\" + \"260127343802208933109668636789869497799400126016422760926082349304118064382913\" + \"834735467972539926233879158299848645927173405922562074910530853153718291168163\" + \"721939518870095778818158685046450769934394098743351443162633031724774748689791\" + \"820923948083314397084067308407958935810896656477585990556376952523265361442478\" + \"023082681183103773588708924061303133647737101162821461466167940409051861526036\" + \"009252194721889091810733587196414214447865489952858234394705007983038853886083\" + \"103571930600277119455802191194289992272235345870756624692617766317885514435021\" + \"828702668561066500353105021631820601760921798468493686316129372795187307897263\" + \"735371715025637873357977180818487845886650433582437700414771041493492743845758\" + \"710715973155943942641257027096512510811554824793940359768118811728247215825010\" + \"949609662539339538092219559191818855267806214992317276316321833989693807561685\" + \"591175299845013206712939240414459386239880938124045219148483164621014738918251\" + \"010909677386906640415897361047643650006807710565671848628149637111883219244566\" + \"394581449148616550049567698269030891118568798692947051352481609174324301538368\" + \"470729289898284602223730145265567989862776796809146979837826876431159883210904\" + \"371561129976652153963546442086919756737000573876497843768628768179249746943842\" + \"746525631632300555130417422734164645512781278457777245752038654375428282567141\" + \"288583454443513256205446424101103795546419058116862305964476958705407214198521\" + \"210673433241075676757581845699069304604752277016700568454396923404171108988899\" + \"341635058515788735343081552081177207188037910404698306957868547393765643363197\" + \"978680367187307969392423632144845035477631567025539006542311792015346497792906\" + \"624150832885839529054263768766896880503331722780018588506973623240389470047189\" + \"761934734430843744375992503417880797223585913424581314404984770173236169471976\" + \"571535319775499716278566311904691260918259124989036765417697990362375528652637\" + \"573376352696934435440047306719886890196814742876779086697968852250163694985673\" + \"021752313252926537589641517147955953878427849986645630287883196209983049451987\" + \"439636907068276265748581043911223261879405994155406327013198989570376110532360\" + \"629867480377915376751158304320849872092028092975264981256916342500052290887264\" + \"692528466610466539217148208013050229805263783642695973370705392278915351056888\" + \"393811324975707133102950443034671598944878684711643832805069250776627450012200\" + \"352620370946602341464899839025258883014867816219677519458316771876275720050543\" + \"979441245990077115205154619930509838698254284640725554092740313257163264079293\" + \"418334214709041254253352324802193227707535554679587163835875018159338717423606\" + \"155117101312352563348582036514614187004920570437201826173319471570086757853933\" + \"607862273955818579758725874410254207710547536129404746010009409544495966288148\" + \"691590389907186598056361713769222729076419775517772010427649694961105622059250\" + \"242021770426962215495872645398922769766031052498085575947163107587013320886146\" + \"326641259114863388122028444069416948826152957762532501987035987067438046982194\" + \"205638125583343642194923227593722128905642094308235254408411086454536940496927\" + \"149400331978286131818618881111840825786592875742638445005994422956858646048103\" + \"301538891149948693543603022181094346676400002236255057363129462629609619876056\" + \"425996394613869233083719626595473923462413459779574852464783798079569319865081\" + \"597767535055391899115133525229873611277918274854200868953965835942196333150286\" + \"956119201229888988700607999279541118826902307891310760361763477948943203210277\" + \"335941690865007193280401716384064498787175375678118532132840821657110754952829\" + \"497493621460821558320568723218557406516109627487437509809223021160998263303391\" + \"546949464449100451528092508974507489676032409076898365294065792019831526541065\" + \"813682379198409064571246894847020935776119313998024681340520039478194986620262\" + \"400890215016616381353838151503773502296607462795291038406868556907015751662419\" + \"298724448271942933100485482445458071889763300323252582158128032746796200281476\" + \"243182862217105435289834820827345168018613171959332471107466222850871066611770\" + \"346535283957762599774467218571581612641114327179434788599089280848669491413909\" + \"771673690027775850268664654056595039486784111079011610400857274456293842549416\" + \"759460548711723594642910585090995021495879311219613590831588262068233215615308\" + \"683373083817327932819698387508708348388046388478441884003184712697454370937329\" + \"836240287519792080232187874488287284372737801782700805878241074935751488997891\" + \"173974612932035108143270325140903048746226294234432757126008664250833318768865\" + \"075642927160552528954492153765175149219636718104943531785838345386525565664065\" + \"725136357506435323650893679043170259787817719031486796384082881020946149007971\" + \"513771709906195496964007086766710233004867263147551053723175711432231741141168\" + \"062286420638890621019235522354671166213749969326932173704310598722503945657492\" + \"461697826097025335947502091383667377289443869640002811034402608471289900074680\" + \"776484408871134135250336787731679770937277868216611786534423173226463784769787\" + \"514433209534000165069213054647689098505020301504488083426184520873053097318949\" + \"291642532293361243151430657826407028389840984160295030924189712097160164926561\" + \"341343342229882790992178604267981245728534580133826099587717811310216734025656\" + \"274400729683406619848067661580502169183372368039902793160642043681207990031626\" + \"444914619021945822969099212278855394878353830564686488165556229431567312827439\" + \"082645061162894280350166133669782405177015521962652272545585073864058529983037\" + \"918035043287670380925216790757120406123759632768567484507915114731344000183257\" + \"034492090971243580944790046249431345502890068064870429353403743603262582053579\" + \"011839564908935434510134296961754524957396062149028872893279252069653538639644\" + \"322538832752249960598697475988232991626354597332444516375533437749292899058117\" + \"578635555562693742691094711700216541171821975051983178713710605106379555858890\" + \"556885288798908475091576463907469361988150781468526213325247383765119299015610\" + \"918977792200870579339646382749068069876916819749236562422608715417610043060890\" + \"437797667851966189140414492527048088197149880154205778700652159400928977760133\" + \"075684796699295543365613984773806039436889588764605498387147896848280538470173\" + \"087111776115966350503997934386933911978988710915654170913308260764740630571141\" + \"109883938809548143782847452883836807941888434266622207043872288741394780101772\" + \"139228191199236540551639589347426395382482960903690028835932774585506080131798\" + \"840716244656399794827578365019551422155133928197822698427863839167971509126241\" + \"054872570092407004548848569295044811073808799654748156891393538094347455697212\" + \"891982717702076661360248958146811913361412125878389557735719498631721084439890\" + \"142394849665925173138817160266326193106536653504147307080441493916936326237376\" + \"777709585031325599009576273195730864804246770121232702053374266705314244820816\" + \"813030639737873664248367253983748769098060218278578621651273856351329014890350\" + \"988327061725893257536399397905572917516009761545904477169226580631511102803843\" + \"601737474215247608515209901615858231257159073342173657626714239047827958728150\" + \"509563309280266845893764964977023297364131906098274063353108979246424213458374\" + \"090116939196425045912881340349881063540088759682005440836438651661788055760895\" + \"689672753153808194207733259791727843762566118431989102500749182908647514979400\" + \"316070384554946538594602745244746681231468794344161099333890899263841184742525\" + \"704457251745932573898956518571657596148126602031079762825416559050604247911401\" + \"695790033835657486925280074302562341949828646791447632277400552946090394017753\" + \"633565547193100017543004750471914489984104001586794617924161001645471655133707\" + \"407395026044276953855383439755054887109978520540117516974758134492607943368954\" + \"378322117245068734423198987884412854206474280973562580706698310697993526069339\" + \"213568588139121480735472846322778490808700246777630360555123238665629517885371\" + \"967303463470122293958160679250915321748903084088651606111901149844341235012464\" + \"692802880599613428351188471544977127847336176628506216977871774382436256571177\" + \"945006447771837022199910669502165675764404499794076503799995484500271066598781\" + \"360380231412683690578319046079276529727769404361302305178708054651154246939526\" + \"512710105292707030667302444712597393995051462840476743136373997825918454117641\" + \"332790646063658415292701903027601733947486696034869497654175242930604072700505\" + \"903950314852292139257559484507886797792525393176515641619716844352436979444735\" + \"596426063339105512682606159572621703669850647328126672452198906054988028078288\" + \"142979633669674412480598219214633956574572210229867759974673812606936706913408\" + \"155941201611596019023775352555630060624798326124988128819293734347686268921923\" + \"977783391073310658825681377717232831532908252509273304785072497713944833389255\" + \"208117560845296659055394096556854170600117985729381399825831929367910039184409\" + \"928657560599359891000296986446097471471847010153128376263114677420914557404181\" + \"590880006494323785583930853082830547607679952435739163122188605754967383224319\" + \"565065546085288120190236364471270374863442172725787950342848631294491631847534\" + \"753143504139209610879605773098720135248407505763719925365047090858251393686346\" + \"386336804289176710760211115982887553994012007601394703366179371539630613986365\" + \"549221374159790511908358829009765664730073387931467891318146510931676157582135\" + \"142486044229244530411316065270097433008849903467540551864067734260358340960860\" + \"553374736276093565885310976099423834738222208729246449768456057956251676557408\" + \"841032173134562773585605235823638953203853402484227337163912397321599544082842\" + \"166663602329654569470357718487344203422770665383738750616921276801576618109542\" + \"009770836360436111059240911788954033802142652394892968643980892611463541457153\" + \"519434285072135345301831587562827573389826889852355779929572764522939156747756\" + \"667605108788764845349363606827805056462281359888587925994094644604170520447004\" + \"631513797543173718775603981596264750141090665886616218003826698996196558058720\" + \"863972117699521946678985701179833244060181157565807428418291061519391763005919\" + \"431443460515404771057005433900018245311773371895585760360718286050635647997900\" + \"413976180895536366960316219311325022385179167205518065926351803625121457592623\" + \"836934822266589557699466049193811248660909979812857182349400661555219611220720\" + \"309227764620099931524427358948871057662389469388944649509396033045434084210246\" + \"240104872332875008174917987554387938738143989423801176270083719605309438394006\" + \"375611645856094312951759771393539607432279248922126704580818331376416581826956\" + \"210587289244774003594700926866265965142205063007859200248829186083974373235384\" + \"908396432614700053242354064704208949921025040472678105908364400746638002087012\" + \"666420945718170294675227854007450855237772089058168391844659282941701828823301\" + \"497155423523591177481862859296760504820386434310877956289292540563894662194826\" + \"871104282816389397571175778691543016505860296521745958198887868040811032843273\" + \"986719862130620555985526603640504628215230615459447448990883908199973874745296\" + \"981077620148713400012253552224669540931521311533791579802697955571050850747387\" + \"475075806876537644578252443263804614304288923593485296105826938210349800040524\" + \"840708440356116781717051281337880570564345061611933042444079826037795119854869\" + \"455915205196009304127100727784930155503889536033826192934379708187432094991415\" + \"959339636811062755729527800425486306005452383915106899891357882001941178653568\" + \"214911852820785213012551851849371150342215954224451190020739353962740020811046\" + \"553020793286725474054365271759589350071633607632161472581540764205302004534018\" + \"357233829266191530835409512022632916505442612361919705161383935732669376015691\" + \"442994494374485680977569630312958871916112929468188493633864739274760122696415\" + \"884890096571708616059814720446742866420876533479985822209061980217321161423041\" + \"947775499073873856794118982466091309169177227420723336763503267834058630193019\" + \"324299639720444517928812285447821195353089891012534297552472763573022628138209\" + \"180743974867145359077863353016082155991131414420509144729353502223081719366350\" + \"934686585865631485557586244781862010871188976065296989926932817870557643514338\" + \"206014107732926106343152533718224338526352021773544071528189813769875515757454\" + \"693972715048846979361950047772097056179391382898984532742622728864710888327017\" + \"372325881824465843624958059256033810521560620615571329915608489206434030339526\" + \"226345145428367869828807425142256745180618414956468611163540497189768215422772\" + \"247947403357152743681940989205011365340012384671429655186734415374161504256325\" + \"671343024765512521921803578016924032669954174608759240920700466934039651017813\" + \"485783569444076047023254075555776472845075182689041829396611331016013111907739\" + \"863246277821902365066037404160672496249013743321724645409741299557052914243820\" + \"807609836482346597388669134991978401310801558134397919485283043673901248208244\" + \"481412809544377389832005986490915950532285791457688496257866588599917986752055\" + \"455809900455646117875524937012455321717019428288461740273664997847550829422802\" + \"023290122163010230977215156944642790980219082668986883426307160920791408519769\" + \"523555348865774342527753119724743087304361951139611908003025587838764420608504\" + \"473063129927788894272918972716989057592524467966018970748296094919064876469370\" + \"275077386643239191904225429023531892337729316673608699622803255718530891928440\" + \"380507103006477684786324319100022392978525537237556621364474009676053943983823\" + \"576460699246526008909062410590421545392790441152958034533450025624410100635953\" + \"003959886446616959562635187806068851372346270799732723313469397145628554261546\" + \"765063246567662027924520858134771760852169134094652030767339184114750414016892\" + \"412131982688156866456148538028753933116023229255561894104299533564009578649534\" + \"093511526645402441877594931693056044868642086275720117231952640502309977456764\" + \"783848897346431721598062678767183800524769688408498918508614900343240347674268\" + \"624595239589035858213500645099817824463608731775437885967767291952611121385919\" + \"472545140030118050343787527766440276261894101757687268042817662386068047788524\" + \"288743025914524707395054652513533945959878961977891104189029294381856720507096\" + \"460626354173294464957661265195349570186001541262396228641389779673332907056737\" + \"696215649818450684226369036784955597002607986799626101903933126376855696876702\" + \"929537116252800554310078640872893922571451248113577862766490242516199027747109\" + \"033593330930494838059785662884478744146984149906712376478958226329490467981208\" + \"998485716357108783119184863025450162092980582920833481363840542172005612198935\" + \"366937133673339246441612522319694347120641737549121635700857369439730597970971\" + \"972666664226743111776217640306868131035189911227133972403688700099686292254646\" + \"500638528862039380050477827691283560337254825579391298525150682996910775425764\" + \"748832534141213280062671709400909822352965795799780301828242849022147074811112\" + \"401860761341515038756983091865278065889668236252393784527263453042041880250844\" + \"236319038331838455052236799235775292910692504326144695010986108889991465855188\" + \"187358252816430252093928525807796973762084563748211443398816271003170315133440\" + \"230952635192958868069082135585368016100021374085115448491268584126869589917414\" + \"913382057849280069825519574020181810564129725083607035685105533178784082900004\" + \"155251186577945396331753853209214972052660783126028196116485809868458752512999\" + \"740409279768317663991465538610893758795221497173172813151793290443112181587102\" + \"351874075722210012376872194474720934931232410706508061856237252673254073332487\" + \"575448296757345001932190219911996079798937338367324257610393898534927877747398\" + \"050808001554476406105352220232540944356771879456543040673589649101761077594836\" + \"454082348613025471847648518957583667439979150851285802060782055446299172320202\" + \"822291488695939972997429747115537185892423849385585859540743810488262464878805\" + \"330427146301194158989632879267832732245610385219701113046658710050008328517731\" + \"177648973523092666123458887310288351562644602367199664455472760831011878838915\" + \"114934093934475007302585581475619088139875235781233134227986650352272536717123\" + \"075686104500454897036007956982762639234410714658489578024140815840522953693749\" + \"971066559489445924628661996355635065262340533943914211127181069105229002465742\" + \"360413009369188925586578466846121567955425660541600507127664176605687427420032\" + \"957716064344860620123982169827172319782681662824993871499544913730205184366907\" + \"672357740005393266262276032365975171892590180110429038427418550789488743883270\" + \"306328327996300720069801224436511639408692222074532024462412115580435454206421\" + \"512158505689615735641431306888344318528085397592773443365538418834030351782294\" + \"625370201578215737326552318576355409895403323638231921989217117744946940367829\" + \"618592080340386757583411151882417743914507736638407188048935825686854201164503\" + \"135763335550944031923672034865101056104987272647213198654343545040913185951314\" + \"518127643731043897250700498198705217627249406521461995923214231443977654670835\" + \"171474936798618655279171582408065106379950018429593879915835017158075988378496\" + \"225739851212981032637937621832245659423668537679911314010804313973233544909082\" + \"491049914332584329882103398469814171575601082970658306521134707680368069532297\" + \"199059990445120908727577622535104090239288877942463048328031913271049547859918\" + \"019696783532146444118926063152661816744319355081708187547705080265402529410921\" + \"826485821385752668815558411319856002213515888721036569608751506318753300294211\" + \"868222189377554602722729129050429225978771066787384000061677215463844129237119\" + \"352182849982435092089180168557279815642185819119749098573057033266764646072875\" + \"743056537260276898237325974508447964954564803077159815395582777913937360171742\" + \"299602735310276871944944491793978514463159731443535185049141394155732938204854\" + \"212350817391254974981930871439661513294204591938010623142177419918406018034794\" + \"988769105155790555480695387854006645337598186284641990522045280330626369562649\" + \"091082762711590385699505124652999606285544383833032763859980079292284665950355\" + \"121124528408751622906026201185777531374794936205549640107300134885315073548735\" + \"390560290893352640071327473262196031177343394367338575912450814933573691166454\" + \"128178817145402305475066713651825828489809951213919399563324133655677709800308\" + \"191027204099714868741813466700609405102146269028044915964654533010775469541308\" + \"871416531254481306119240782118869005602778182423502269618934435254763357353648\" + \"561936325441775661398170393063287216690572225974520919291726219984440964615826\" + \"945638023950283712168644656178523556516412771282691868861557271620147493405227\" + \"694659571219831494338162211400693630743044417328478610177774383797703723179525\" + \"543410722344551255558999864618387676490397246116795901810003509892864120419516\" + \"355110876320426761297982652942588295114127584126273279079880755975185157684126\" + \"474220947972184330935297266521001566251455299474512763155091763673025946213293\" + \"019040283795424632325855030109670692272022707486341900543830265068121414213505\" + \"715417505750863990767394633514620908288893493837643939925690060406731142209331\" + \"219593620298297235116325938677224147791162957278075239505625158160313335938231\" + \"150051862689053065836812998810866326327198061127154885879809348791291370749823\" + \"057592909186293919501472119758606727009254771802575033773079939713453953264619\" + \"526999659638565491759045833358579910201271320458390320085387888163363768518208\" + \"372788513117522776960978796214237216254521459128183179821604411131167140691482\" + \"717098101545778193920231156387195080502467972579249760577262591332855972637121\" + \"120190572077140914864507409492671803581515757151405039761096384675556929897038\" + \"354731410022380258346876735012977541327953206097115450648421218593649099791776\" + \"687477448188287063231551586503289816422828823274686610659273219790716238464215\" + \"348985247621678905026099804526648392954235728734397768049577409144953839157556\" + \"548545905897649519851380100795801078375994577529919670054760225255203445398871\" + \"253878017196071816407812484784725791240782454436168234523957068951427226975043\" + \"187363326301110305342333582160933319121880660826834142891041517324721605335584\" + \"999322454873077882290525232423486153152097693846104258284971496347534183756200\" + \"301491570327968530186863157248840152663983568956363465743532178349319982554211\" + \"730846774529708583950761645822963032442432823773745051702856069806788952176819\" + \"815671078163340526675953942492628075696832610749532339053622309080708145591983\" + \"735537774874202903901814293731152933464446815121294509759653430628421531944572\" + \"711861490001765055817709530246887526325011970520947615941676872778447200019278\" + \"913725184162285778379228443908430118112149636642465903363419454065718354477191\" + \"244662125939265662030688852005559912123536371822692253178145879259375044144893\" + \"398160865790087616502463519704582889548179375668104647461410514249887025213993\" + \"687050937230544773411264135489280684105910771667782123833281026218558775131272\" + \"117934444820144042574508306394473836379390628300897330624138061458941422769474\" + \"793166571762318247216835067807648757342049155762821758397297513447899069658953\" + \"254894033561561316740327647246921250575911625152965456854463349811431767025729\" + \"566184477548746937846423373723898192066204851189437886822480727935202250179654\" + \"534375727416391079197295295081294292220534771730418447791567399173841831171036\" + \"252439571615271466900581470000263301045264354786590329073320546833887207873544\" + \"476264792529769017091200787418373673508771337697768349634425241994995138831507\" + \"487753743384945825976556099655595431804092017849718468549737069621208852437701\" + \"385375768141663272241263442398215294164537800049250726276515078908507126599703\" + \"670872669276430837722968598516912230503746274431085293430527307886528397733524\" + \"601746352770320593817912539691562106363762588293757137384075440646896478310070\" + \"458061344673127159119460843593582598778283526653115106504162329532904777217408\" + \"355934972375855213804830509000964667608830154061282430874064559443185341375522\" + \"016630581211103345312074508682433943215904359443031243122747138584203039010607\" + \"094031523555617276799416002039397509989762933532585557562480899669182986422267\" + \"750236019325797472674257821111973470940235745722227121252685238429587427350156\" + \"366009318804549333898974157149054418255973808087156528143010267046028431681923\" + \"039253529779576586241439270154974087927313105163611913757700892956482332364829\" + \"826302460797587576774537716010249080462430185652416175665560016085912153455626\" + \"760219268998285537787258314514408265458348440947846317877737479465358016996077\" + \"940556870119232860804113090462935087182712593466871276669487389982459852778649\" + \"956916546402945893506496433580982476596516514209098675520380830920323048734270\" + \"346828875160407154665383461961122301375945157925269674364253192739003603860823\" + \"645076269882749761872357547676288995075211480485252795084503395857083813047693\" + \"788132112367428131948795022806632017002246033198967197064916374117585485187848\" + \"401205484467258885140156272501982171906696081262778548596481836962141072171421\" + \"498636191877475450965030895709947093433785698167446582826791194061195603784539\" + \"785583924076127634410576675102430755981455278616781594965706255975507430652108\" + \"530159790807334373607943286675789053348366955548680391343372015649883422089339\" + \"997164147974693869690548008919306713805717150585730714881564992071408675825960\" + \"287605645978242377024246980532805663278704192676846711626687946348695046450742\" + \"021937394525926266861355294062478136120620263649819999949840514386828525895634\" + \"226432870766329930489172340072547176418868535137233266787792173834754148002280\" + \"339299735793615241275582956927683723123479898944627433045456679006203242051639\" + \"628258844308543830720149567210646053323853720314324211260742448584509458049408\" + \"182092763914000854042202355626021856434899414543995041098059181794888262805206\" + \"644108631900168856815516922948620301073889718100770929059048074909242714101893\" + \"354281842999598816966099383696164438152887721408526808875748829325873580990567\" + \"075581701794916190611400190855374488272620093668560447559655747648567400817738\" + \"170330738030547697360978654385938218722058390234444350886749986650604064587434\" + \"600533182743629617786251808189314436325120510709469081358644051922951293245007\" + \"883339878842933934243512634336520438581291283434529730865290978330067126179813\" + \"031679438553572629699874035957045845223085639009891317947594875212639707837594\" + \"486113945196028675121056163897600888009274611586080020780334159145179707303683\" + \"519697776607637378533301202412011204698860920933908536577322239241244905153278\" + \"095095586645947763448226998607481329730263097502881210351772312446509534965369\" + \"309001863776409409434983731325132186208021480992268550294845466181471555744470\" + \"966953017769043427203189277060471778452793916047228153437980353967986142437095\" + \"668322149146543801459382927739339603275404800955223181666738035718393275707714\" + \"204672383862461780397629237713120958078936384144792980258806552212926209362393\" + \"063731349664018661951081158347117331202580586672763999276357907806381881306915\" + \"636627412543125958993611964762610140556350339952314032311381965623632719896183\" + \"725484533370206256346422395276694356837676136871196292181875457608161705303159\" + \"072882870071231366630872275491866139577373054606599743781098764980241401124214\" + \"277366808275139095931340415582626678951084677611866595766016599817808941498575\" + \"497628438785610026379654317831363402513581416115190209649913354873313111502270\" + \"068193013592959597164019719605362503355847998096348871803911161281359596856547\" + \"886832585643789617315976200241962155289629790481982219946226948713746244472909\" + \"345647002853769495885959160678928249105441251599630078136836749020937491573289\" + \"627002865682934443134234735123929825916673950342599586897069726733258273590312\" + \"128874666045146148785034614282776599160809039865257571726308183349444182019353\" + \"338507129234577437557934406217871133006310600332405399169368260374617663856575\" + \"887758020122936635327026710068126182517291460820254189288593524449107013820621\" + \"155382779356529691457650204864328286555793470720963480737269214118689546732276\" + \"775133569019015372366903686538916129168888787640752549349424973342718117889275\" + \"993159671935475898809792452526236365903632007085444078454479734829180208204492\" + \"667063442043755532505052752283377888704080403353192340768563010934777212563908\" + \"864041310107381785333831603813528082811904083256440184205374679299262203769871\" + \"801806112262449090924264198582086175117711378905160914038157500336642415609521\" + \"632819712233502316742260056794128140621721964184270578432895980288233505982820\" + \"819666624903585778994033315227481777695284368163008853176969478369058067106482\" + \"808359804669884109813515865490693331952239436328792399053481098783027450017206\" + \"543369906611778455436468772363184446476806914282800455107468664539280539940910\" + \"875493916609573161971503316696830992946634914279878084225722069714887558063748\" + \"030886299511847318712477729191007022758889348693945628951580296537215040960310\" + \"776128983126358996489341024703603664505868728758905140684123812424738638542790\" + \"828273382797332688550493587430316027474906312957234974261122151741715313361862\" + \"241091386950068883589896234927631731647834007746088665559873338211382992877691\" + \"149549218419208777160606847287467368188616750722101726110383067178785669481294\" + \"878504894306308616994879870316051588410828235127415353851336589533294862949449\" + \"506186851477910580469603906937266267038651290520113781085861618888694795760741\" + \"358553458515176805197333443349523012039577073962377131603024288720053732099825\" + \"300897761897312981788194467173116064723147624845755192873278282512718244680782\" + \"421521646956781929409823892628494376024885227900362021938669648221562809360537\" + \"317804086372726842669642192994681921490870170753336109479138180406328738759384\" + \"826953558307739576144799727000347288018278528138950321798634521611106660883931\" + \"405322694490545552786789441757920244002145078019209980446138254780585804844241\" + \"640477503153605490659143007815837243012313751156228401583864427089071828481675\" + \"752712384678245953433444962201009607105137060846180118754312072549133499424761\" + \"711563332140893460915656155060031738421870157022610310191660388706466143889773\" + \"631878094071152752817468957640158104701696524755774089164456867771715850058326\" + \"994340167720215676772406812836656526412298243946513319735919970940327593850266\" + \"955747023181320324371642058614103360652453693916005064495306016126782264894243\" + \"739716671766123104897503188573216555498834212180284691252908610148552781527762\" + \"562375045637576949773433684601560772703550962904939248708840628106794362241870\" + \"474700836884267102255830240359984164595112248527263363264511401739524808619463\" + \"584078375355688562231711552094722306543709260679735100056554938122457548372854\" + \"571179739361575616764169289580525729752233855861138832217110736226581621884244\" + \"317885748879810902665379342666421699091405653643224930133486798815488662866505\" + \"234699723557473842483059042367714327879231642240387776433019260019228477831383\" + \"763253612102533693581262408686669973827597736568222790721583247888864236934639\" + \"616436330873013981421143030600873066616480367898409133592629340230432497492688\" + \"783164360268101130957071614191283068657732353263965367739031766136131596555358\" + \"499939860056515592193675997771793301974468814837110320650369319289452140265091\" + \"546518430993655349333718342529843367991593941746622390038952767381333061774762\" + \"957494386871697845376721949350659087571191772087547710718993796089477451265475\" + \"750187119487073873678589020061737332107569330221632062843206567119209695058576\" + \"117396163232621770894542621460985841023781321581772760222273813349541048100307\" + \"327510779994899197796388353073444345753297591426376840544226478421606312276964\" + \"696715647399904371590332390656072664411643860540483884716191210900870101913072\" + \"607104411414324197679682854788552477947648180295973604943970047959604029274629\" + \"920357209976195014034831538094771460105633344699882082212058728151072918297121\" + \"191787642488035467231691654185225672923442918712816323259696541354858957713320\" + \"833991128877591722611527337901034136208561457799239877832508355073019981845902\" + \"595835598926055329967377049172245493532968330000223018151722657578752405883224\" + \"908582128008974790932610076257877042865600699617621217684547899644070506624171\" + \"021332748679623743022915535820078014116534806564748823061500339206898379476625\" + \"503654982280532966286211793062843017049240230198571997894883689718304380518217\" + \"441914766042975243725168343541121703863137941142209529588579806015293875275379\" + \"903093887168357209576071522190027937929278630363726876582268124199338480816602\" + \"160372215471014300737753779269906958712128928801905203160128586182549441335382\" + \"078488346531163265040764242839087012101519423196165226842200371123046430067344\" + \"206474771802135307012409886035339915266792387110170622186588357378121093517977\" + \"560442563469499978725112544085452227481091487430725986960204027594117894258128\" + \"188215995235965897918114407765335432175759525553615812800116384672031934650729\" + \"680799079396371496177431211940202129757312516525376801735910155733815377200195\" + \"244454362007184847566341540744232862106099761324348754884743453966598133871746\" + \"609302053507027195298394327142537115576660002578442303107342955153394506048622\" + \"276496668762407932435319299263925373107689213535257232108088981933916866827894\" + \"828117047262450194840970097576092098372409007471797334078814182519584259809624\" + \"174761013825264395513525931188504563626418830033853965243599741693132289471987\" + \"830842760040136807470390409723847394583489618653979059411859931035616843686921\" + \"948538205578039577388136067954990008512325944252972448666676683464140218991594\" + \"456530942344065066785194841776677947047204195882204329538032631053749488312218\" + \"039127967844610013972675389219511911783658766252808369005324900459741094706877\" + \"291232821430463533728351995364827432583311914445901780960778288358373011185754\" + \"365995898272453192531058811502630754257149394302445393187017992360816661130542\" + \"625399583389794297160207033876781503301028012009599725222228080142357109476035\" + \"192554443492998676781789104555906301595380976187592035893734197896235893112598\" + \"390259831026719330418921510968915622506965911982832345550305908173073519550372\" + \"166587028805399213857603703537710517802128012956684198414036287272562321442875\" + \"430221090947272107347413497551419073704331827662617727599688882602722524713368\" + \"335345281669277959132886138176634985772893690096574956228710302436259077241221\" + \"909430087175569262575806570991201665962243608024287002454736203639484125595488\" + \"172727247365346778364720191830399871762703751572464992228946793232269361917764\" + \"161461879561395669956778306829031658969943076733350823499079062410020250613405\" + \"734430069574547468217569044165154063658468046369262127421107539904218871612761\" + \"778701425886482577522388918459952337629237791558574454947736129552595222657863\" + \"646211837759847370034797140820699414558071908021359073226923310083175951065901\" + \"912129479540860364075735875020589020870457967000705526250581142066390745921527\" + \"330940682364944159089100922029668052332526619891131184201629163107689408472356\" + \"436680818216865721968826835840278550078280404345371018365109695178233574303050\" + \"485265373807353107418591770561039739506264035544227515610110726177937063472380\" + \"499066692216197119425912044508464174638358993823994651739550900085947999013602\" + \"667426149429006646711506717542217703877450767356374215478290591101261915755587\" + \"023895700140511782264698994491790830179547587676016809410013583761357859135692\" + \"445564776446417866711539195135769610486492249008344671548638305447791433009768\" + \"048687834818467273375843689272431044740680768527862558516509208826381323362314\" + \"873333671476452045087662761495038994950480956046098960432912335834885999029452\" + \"640028499428087862403981181488476730121675416110662999555366819312328742570206\" + \"373835202008686369131173346973174121915363324674532563087134730279217495622701\" + \"468732586789173455837996435135880095935087755635624881049385299900767513551352\" + \"779241242927748856588856651324730251471021057535251651181485090275047684551825\" + \"209633189906852761443513821366215236889057878669943228881602837748203550601602\" + \"989400911971385017987168363374413927597364401700701476370665570350433812111357\" + \"641501845182141361982349515960106475271257593518530433287553778305750956742544\" + \"268471221961870917856078393614451138333564910325640573389866717812397223751931\" + \"643061701385953947436784339267098671245221118969084023632741149660124348309892\" + \"994173803058841716661307304006758838043211155537944060549772170594282151488616\" + \"567277124090338772774562909711013488518437411869565544974573684521806698291104\" + \"505800429988795389902780438359628240942186055628778842880212755388480372864001\" + \"944161425749990427200959520465417059810498996750451193647117277222043610261407\" + \"975080968697517660023718774834801612031023468056711264476612374762785219024120\" + \"256994353471622666089367521983311181351114650385489502512065577263614547360442\" + \"685949807439693233129712737715734709971395229118265348515558713733662912024271\" + \"430250376326950135091161295299378586468130722648600827088133353819370368259886\" + \"789332123832705329762585738279009782646054559855513183668884462826513379849166\" + \"783940976135376625179825824966345877195012438404035914084920973375464247448817\" + \"618407002356958017741017769692507781489338667255789856458985105689196092439884\" + \"156928069698335224022563457049731224526935419383700484318335719651662672157552\" + \"419340193309901831930919658292096965624766768365964701959575473934551433741370\" + \"876151732367720422738567427917069820454995309591887243493952409444167899884631\" + \"984550485239366297207977745281439941825678945779571255242682608994086331737153\" + \"889626288962940211210888442737656862452761213037101730078513571540453304150795\" + \"944777614359743780374243664697324713841049212431413890357909241603640631403814\" + \"983148190525172093710396402680899483257229795456404270175772290417323479607361\" + \"878788991331830584306939482596131871381642346721873084513387721908697510494284\" + \"376932502498165667381626061594176825250999374167288395174406693254965340310145\" + \"222531618900923537648637848288134420987004809622717122640748957193900291857330\" + \"746010436072919094576799461492929042798168772942648772995285843464777538690695\" + \"014898413392454039414468026362540211861431703125111757764282991464453340892097\" + \"696169909837265236176874560589470496817013697490952307208268288789073019001825\" + \"342580534342170592871393173799314241085264739094828459641809361413847583113613\" + \"057610846236683723769591349261582451622155213487924414504175684806412063652017\" + \"038633012953277769902311864802006755690568229501635493199230591424639621702532\" + \"974757311409422018019936803502649563695586642590676268568737211033915679383989\" + \"576556519317788300024161353956243777784080174881937309502069990089089932808839\" + \"743036773659552489130015663329407790713961546453408879151030065132193448667324\" + \"827590794680787981942501958262232039513125201410996053126069655540424867054998\" + \"678692302174698900954785072567297879476988883109348746442640071818316033165551\" + \"153427615562240547447337804924621495213325852769884733626918264917433898782478\" + \"927846891882805466998230368993978341374758702580571634941356843392939606819206\" + \"177333179173820856243643363535986349449689078106401967407443658366707158692452\" + \"118299789380407713750129085864657890577142683358276897855471768718442772612050\" + \"926648610205153564284063236848180728794071712796682006072755955590404023317874\" + \"944734645476062818954151213916291844429765106694796935401686601005519607768733\" + \"539651161493093757096855455938151378956903925101495326562814701199832699220006\" + \"639287537471313523642158926512620407288771657835840521964605410543544364216656\" + \"224456504299901025658692727914275293117208279393775132610605288123537345106837\" + \"293989358087124386938593438917571337630072031976081660446468393772580690923729\" + \"752348670291691042636926209019960520412102407764819031601408586355842760953708\" + \"655816427399534934654631450404019952853725200495780525465625115410925243799132\" + \"626271360909940290226206283675213230506518393405745011209934146491843332364656\" + \"937172591448932415900624202061288573292613359680872650004562828455757459659212\" + \"053034131011182750130696150983551563200431078460190656549380654252522916199181\" + \"995960275232770224985573882489988270746593635576858256051806896428537685077201\" + \"222034792099393617926820659014216561592530673794456894907085326356819683186177\" + \"226824991147261573203580764629811624401331673789278868922903259334986179702199\" + \"498192573961767307583441709855922217017182571277753449150820527843090461946083\" + \"521740200583867284970941102326695392144546106621500641067474020700918991195137\" + \"646690448126725369153716229079138540393756007783515337416774794210038400230895\" + \"185099454877903934612222086506016050035177626483161115332558770507354127924990\" + \"985937347378708119425305512143697974991495186053592040383023571635272763087469\" + \"321962219006426088618367610334600225547747781364101269190656968649501268837629\" + \"690723396127628722304114181361006026404403003599698891994582739762411461374480\" + \"405969706257676472376606554161857469052722923822827518679915698339074767114610\" + \"302277660602006124687647772881909679161335401988140275799217416767879923160396\" + \"356949285151363364721954061117176738737255572852294005436178517650230754469386\" + \"930787349911035218253292972604455321079788771144989887091151123725060423875373\" + \"484125708606406905205845212275453384800820530245045651766951857691320004281675\" + \"805492481178051983264603244579282973012910531838563682120621553128866856495651\" + \"261389226136706409395333457052698695969235035309422454386527867767302754040270\" + \"224638448355323991475136344104405009233036127149608135549053153902100229959575\" + \"658370538126196568314428605795669662215472169562087001372776853696084070483332\" + \"513279311223250714863020695124539500373572334680709465648308920980153487870563\" + \"349109236605755405086411152144148143463043727327104502776866195310785832333485\" + \"784029716092521532609255893265560067212435946425506599677177038844539618163287\" + \"961446081778927217183690888012677820743010642252463480745430047649288555340906\" + \"218515365435547412547615276977266776977277705831580141218568801170502836527554\" + \"321480348800444297999806215790456416195721278450892848980642649742709057912906\" + \"921780729876947797511244730599140605062994689428093103421641662993561482813099\" + \"887074529271604843363081840412646963792584309418544221635908457614607855856247\" + \"381493142707826621518554160387020687698046174740080832434366538235455510944949\" + \"843109349475994467267366535251766270677219418319197719637801570216993367508376\" + \"005716345464367177672338758864340564487156696432104128259564534984138841289042\" + \"068204700761559691684303899934836679354254921032811336318472259230555438305820\" + \"694167562999201337317548912203723034907268106853445403599356182357631283776764\" + \"063101312533521214199461186935083317658785204711236433122676512996417132521751\" + \"355326186768194233879036546890800182713528358488844411176123410117991870923650\" + \"718485785622102110400977699445312179502247957806950653296594038398736990724079\" + \"767904082679400761872954783596349279390457697366164340535979221928587057495748\" + \"169669406233427261973351813662606373598257555249650980726012366828360592834185\" + \"584802695841377255897088378994291054980033111388460340193916612218669605849157\" + \"148573356828614950001909759112521880039641976216355937574371801148055944229873\" + \"041819680808564726571354761283162920044988031540210553059707666636274932830891\" + \"688093235929008178741198573831719261672883491840242972129043496552694272640255\" + \"964146352591434840067586769035038232057293413298159353304444649682944136732344\" + \"215838076169483121933311981906109614295220153617029857510559432646146850545268\" + \"497576480780800922133581137819774927176854507553832876887447459159373116247060\" + \"109124460982942484128752022446259447763874949199784044682925736096853454984326\" + \"653686284448936570411181779380644161653122360021491876876946739840751717630751\" + \"684985635920148689294310594020245796962292456664488196757629434953532638217161\" + \"339575779076637076456957025973880043841580589433613710655185998760075492418721\" + \"171488929522173772114608115434498266547987258005667472405112200738345927157572\" + \"771521858994694811794064446639943237004429114074721818022482583773601734668530\" + \"074498556471542003612359339731291445859152288740871950870863221883728826282288\" + \"463184371726190330577714765156414382230679184738603914768310814135827575585364\" + \"359772165002827780371342286968878734979509603110889919614338666406845069742078\" + \"770028050936720338723262963785603865321643234881555755701846908907464787912243\" + \"637555666867806761054495501726079114293083128576125448194444947324481909379536\" + \"900820638463167822506480953181040657025432760438570350592281891987806586541218\" + \"429921727372095510324225107971807783304260908679427342895573555925272380551144\" + \"043800123904168771644518022649168164192740110645162243110170005669112173318942\" + \"340054795968466980429801736257040673328212996215368488140410219446342464622074\" + \"557564396045298531307140908460849965376780379320189914086581466217531933766597\" + \"011433060862500982956691763884605676297293146491149370462446935198403953444913\" + \"514119366793330193661766365255514917498230798707228086085962611266050428929696\" + \"653565251668888557211227680277274370891738963977225756489053340103885593112567\" + \"999151658902501648696142720700591605616615970245198905183296927893555030393468\" + \"121976158218398048396056252309146263844738629603984892438618729850777592879272\" + \"206855480721049781765328621018747676689724884113956034948037672703631692100735\" + \"083407386526168450748249644859742813493648037242611670426687083192504099761531\" + \"907685577032742178501000644198412420739640013960360158381056592841368457411910\" + \"273642027416372348821452410134771652960312840865841978795111651152982781462037\" + \"913985500639996032659124852530849369031313010079997719136223086601109992914287\" + \"124938854161203802041134018888721969347790449752745428807280350930582875442075\" + \"513481666092787935356652125562013998824962847872621443236285367650259145046837\" + \"763528258765213915648097214192967554938437558260025316853635673137926247587804\" + \"944594418342917275698837622626184636545274349766241113845130548144983631178978\" + \"448973207671950878415861887969295581973325069995140260151167552975057543781024\" + \"223895792578656212843273120220071673057406928686936393018676595825132649914595\" + \"026091706934751940897535746401683081179884645247361895605647942635807056256328\" + \"118926966302647953595109712765913623318086692153578860781275991053717140220450\" + \"618607537486630635059148391646765672320571451688617079098469593223672494673758\" + \"309960704258922048155079913275208858378111768521426933478692189524062265792104\" + \"362034885292626798401395321645879115157905046057971083898337186403802441751134\" + \"722647254701079479399695355466961972676325522991465493349966323418595145036098\" + \"034409221220671256769872342794070885707047429317332918852389672197135392449242\" + \"617864118863779096281448691786946817759171715066911148002075943201206196963779\" + \"510322708902956608556222545260261046073613136886900928172106819861855378098201\" + \"847115416363032626569928342415502360097804641710852553761272890533504550613568\" + \"414377585442967797701466029438768722511536380119175815402812081825560648541078\" + \"793359892106442724489861896162941341800129513068363860929410008313667337215300\" + \"835269623573717533073865333820484219030818644918409372394403340524490955455801\" + \"640646076158101030176748847501766190869294609876920169120218168829104087070956\" + \"095147041692114702741339005225334083481287035303102391969997859741390859360543\" + \"359969707560446013424245368249609877258131102473279856207212657249900346829388\" + \"687230489556225320446360263985422525841646432427161141981780248259556354490721\" + \"922658386366266375083594431487763515614571074552801615967704844271419443518327\" + \"569840755267792641126176525061596523545718795667317091331935876162825592078308\" + \"018520689015150471334038610031005591481785211038475454293338918844412051794396\" + \"997019411269511952656491959418997541839323464742429070271887522353439367363366\" + \"320030723274703740712398256202466265197409019976245205619855762576000870817308\" + \"328834438183107005451449354588542267857855191537229237955549433341017442016960\" + \"009069641561273229777022121795186837635908225512881647002199234886404395915301\" + \"846400471432118636062252701154112228380277853891109849020134274101412155976996\" + \"543887719748537643115822983853312307175113296190455900793806427669581901484262\" + \"799122179294798734890186847167650382732855205908298452980625925035212845192592\" + \"798659350613296194679625237397256558415785374456755899803240549218696288849033\" + \"256085145534439166022625777551291620077279685262938793753045418108072928589198\" + \"971538179734349618723292761474785019261145041327487324297058340847111233374627\" + \"461727462658241532427105932250625530231473875925172478732288149145591560503633\" + \"457542423377916037495250249302235148196138116256391141561032684495807250827343\" + \"176594405409826976526934457986347970974312449827193311386387315963636121862349\" + \"726140955607992062831699942007205481152535339394607685001990988655386143349578\" + \"165008996164907967814290114838764568217491407562376761845377514403147541120676\" + \"016072646055685925779932207033733339891636950434669069482843662998003741452762\" + \"771654762382554617088318981086880684785370553648046935095881802536052974079353\" + \"867651119507937328208314626896007107517552061443378411454995013643244632819334\" + \"638905093654571450690086448344018042836339051357815727397333453728426337217406\" + \"577577107983051755572103679597690188995849413019599957301790124019390868135658\" + \"553966194137179448763207986880037160730322054742357226689680188212342439188598\" + \"416897227765219403249322731479366923400484897605903795809469604175427961378255\" + \"378122394764614783292697654516229028170110043784603875654415173943396004891531\" + \"881757665050095169740241564477129365661425394936888423051740012992055685428985\" + \"389794266995677702708914651373689220610441548166215680421983847673087178759027\" + \"920917590069527345668202651337311151800018143412096260165862982107666352336177\" + \"400783778342370915264406305407180784335806107296110555002041513169637304684921\" + \"335683726540030750982908936461204789111475303704989395283345782408281738644132\" + \"271000296831194020332345642082647327623383029463937899837583655455991934086623\" + \"509096796113400486702712317652666371077872511186035403755448741869351973365662\" + \"177235922939677646325156202348757011379571209623772343137021203100496515211197\" + \"601317641940820343734851285260291333491512508311980285017785571072537314913921\" + \"570910513096505988599993156086365547740355189816673353588004821466509974143376\" + \"118277772335191074121757284159258087259131507460602563490377726337391446137703\" + \"802131834744730111303267029691733504770163210661622783002726928336558401179141\" + \"944780874825336071440329625228577500980859960904093631263562132816207145340610\" + \"422411208301000858726425211226248014264751942618432585338675387405474349107271\" + \"004975428115946601713612259044015899160022982780179603519408004651353475269877\" + \"760952783998436808690898919783969353217998013913544255271791022539701081063214\" + \"304851137829149851138196914304349750018998068164441212327332830719282436240673\" + \"319655469267785119315277511344646890550424811336143498460484905125834568326644\" + \"152848971397237604032821266025351669391408204994732048602162775979177123475109\" + \"750240307893575993771509502175169355582707253391189233407022383207758580213717\" + \"477837877839101523413209848942345961369234049799827930414446316270721479611745\" + \"697571968123929191374098292580556195520743424329598289898052923336641541925636\" + \"738068949420147124134052507220406179435525255522500874879008656831454283516775\" + \"054229480327478304405643858159195266675828292970522612762871104013480178722480\" + \"178968405240792436058274246744307672164527031345135416764966890127478680101029\" + \"513386269864974821211862904033769156857624069929637249309720162870720018983542\" + \"369036414927023696193854737248032985504511208919287982987446786412915941753167\" + \"560253343531062674525450711418148323988060729714023472552071349079839898235526\" + \"872395090936566787899238371257897624875599044322889538837731734894112275707141\" + \"095979004791930104674075041143538178246463079598955563899188477378134134707024\" + \"674736211204898622699188851745625173251934135203811586335012391305444191007362\" + \"844756751416105041097350585276204448919097890198431548528053398577784431393388\" + \"399431044446566924455088594631408175122033139068159659251054685801313383815217\" + \"641821043342978882611963044311138879625874609022613090084997543039577124323061\" + \"690626291940392143974027089477766370248815549932245882597902063125743691094639\" + \"325280624164247686849545532493801763937161563684785982371590238542126584061536\" + \"722860713170267474013114526106376538339031592194346981760535838031061288785205\" + \"154693363924108846763200956708971836749057816308515813816196688222204757043759\" + \"061433804072585386208356517699842677452319582418268369827016023741493836349662\" + \"935157685406139734274647089968561817016055110488097155485911861718966802597354\" + \"170542398513556001872033507906094642127114399319604652742405088222535977348151\" + \"913543857125325854049394601086579379805862014336607882521971780902581737087091\" + \"646045272797715350991034073642502038638671822052287969445838765294795104866071\" + \"739022932745542678566977686593992341683412227466301506215532050265534146099524\" + \"935605085492175654913483095890653617569381763747364418337897422970070354520666\" + \"317092960759198962773242309025239744386101426309868773391388251868431650102796\" + \"491149773758288891345034114886594867021549210108432808078342808941729800898329\" + \"753694064496990312539986391958160146899522088066228540841486427478628197554662\" + \"927881462160717138188018084057208471586890683691939338186427845453795671927239\" + \"797236465166759201105799566396259853551276355876814021340982901629687342985079\" + \"247184605687482833138125916196247615690287590107273310329914062386460833337863\" + \"825792630239159000355760903247728133888733917809696660146961503175422675112599\" + \"331552967421333630022296490648093458200818106180210022766458040027821333675857\" + \"301901137175467276305904435313131903609248909724642792845554991349000518029570\" + \"708291905255678188991389962513866231938005361134622429461024895407240485712325\" + \"662888893172211643294781619055486805494344103409068071608802822795968695013364\" + \"381426825217047287086301013730115523686141690837567574763723976318575703810944\" + \"339056456446852418302814810799837691851212720193504404180460472162693944578837\" + \"709010597469321972055811407877598977207200968938224930323683051586265728111463\" + \"799698313751793762321511125234973430524062210524423435373290565516340666950616\" + \"589287821870775679417608071297378133518711793165003315552382248773065344417945\" + \"341539520242444970341012087407218810938826816751204229940494817944947273289477\" + \"011157413944122845552182842492224065875268917227278060711675404697300803703961\" + \"878779669488255561467438439257011582954666135867867189766129731126720007297155\" + \"361302750355616781776544228744211472988161480270524380681765357327557860250584\" + \"708401320883793281600876908130049249147368251703538221961903901499952349538710\" + \"599735114347829233949918793660869230137559636853237380670359114424326856151210\" + \"940425958263930167801712866923928323105765885171402021119695706479981403150563\" + \"304514156441462316376380990440281625691757648914256971416359843931743327023781\" + \"233693804301289262637538266779503416933432360750024817574180875038847509493945\" + \"489620974048544263563716499594992098088429479036366629752600324385635294584472\" + \"894454716620929749549661687741412088213047702281611645604400723635158114972973\" + \"921896673738264720472264222124201656015028497130633279581430251601369482556701\" + \"478093579088965713492615816134690180696508955631012121849180584792272069187169\" + \"631633004485802010286065785859126997463766174146393415956953955420331462802651\" + \"895116793807457331575984608617370268786760294367778050024467339133243166988035\" + \"407323238828184750105164133118953703648842269027047805274249060349208295475505\" + \"400345716018407257453693814553117535421072655783561549987444748042732345788006\" + \"187314934156604635297977945507535930479568720931672453654720838168585560604380\" + \"197703076424608348987610134570939487700294617579206195254925575710903852517148\" + \"852526567104534981341980339064152987634369542025608027761442191431892139390883\" + \"454313176968510184010384447234894886952098194353190650655535461733581404554483\" + \"788475252625394966586999205841765278012534103389646981864243003414679138061902\" + \"805960785488801078970551694621522877309010446746249797999262712095168477956848\" + \"258334140226647721084336243759374161053673404195473896419789542533503630186140\" + \"095153476696147625565187382329246854735693580289601153679178730355315937836308\" + \"224861517777054157757656175935851201669294311113886358215966761883032610416465\" + \"171484697938542262168716140012237821377977413126897726671299202592201740877007\" + \"695628347393220108815935628628192856357189338495885060385315817976067947984087\" + \"836097596014973342057270460352179060564760328556927627349518220323614411258418\" + \"242624771201203577638889597431823282787131460805353357449429762179678903456816\" + \"988955351850447832561638070947695169908624710001974880920500952194363237871976\" + \"487033922381154036347548862684595615975519376541011501406700122692747439388858\" + \"994385973024541480106123590803627458528849356325158538438324249325266608758890\" + \"831870070910023737710657698505643392885433765834259675065371500533351448990829\" + \"388773735205145933304962653141514138612443793588507094468804548697535817021290\" + \"849078734780681436632332281941582734567135644317153796781805819585246484008403\" + \"290998194378171817730231700398973305049538735611626102399943325978012689343260\" + \"558471027876490107092344388463401173555686590358524491937018104162620850429925\" + \"869743581709813389404593447193749387762423240985283276226660494238512970945324\" + \"558625210360082928664972417491914198896612955807677097959479530601311915901177\" + \"394310420904907942444886851308684449370590902600612064942574471035354765785924\" + \"270813041061854621988183009063458818703875585627491158737542106466795134648758\" + \"677154383801852134828191581246259933516019893559516796893285220582479942103451\" + \"271587716334522299541883968044883552975336128683722593539007920166694133909116\" + \"875880398882886921600237325736158820716351627133281051818760210485218067552664\" + \"867390890090719513805862673512431221569163790227732870541084203784152568328871\" + \"804698795251307326634027851905941733892035854039567703561132935448258562828761\" + \"061069822972142096199350933131217118789107876687204454887608941017479864713788\" + \"246215395593333327556200943958043453791978228059039595992743691379377866494096\" + \"404877784174833643268402628293240626008190808180439091455635193685606304508914\" + \"228964521998779884934747772913279726602765840166789013649050874114212686196986\" + \"204412696528298108704547986155954533802120115564697997678573892018624359932677\" + \"768945406050821883822790983362716712449002676117849826437703300208184459000971\" + \"723520433199470824209877151444975101705564302954282181967000920251561584417420\" + \"593365814813490269311151709387226002645863056132560579256092733226557934628080\" + \"568344392137368840565043430739657406101777937014142461549307074136080544210029\" + \"560009566358897789926763051771878194370676149821756418659011616086540863539151\" + \"303920131680576903417259645369235080641744656235152392905040947995318407486215\" + \"121056183385456617665260639371365880252166622357613220194170137266496607325201\" + \"077194793126528276330241380516490717456596485374835466919452358031530196916048\" + \"099460681490403781982973236093008713576079862142542209641900436790547904993007\" + \"837242158195453541837112936865843055384271762803527912882112930835157565659994\" + \"474178843838156514843422985870424559243469329523282180350833372628379183021659\" + \"183618155421715744846577842013432998259456688455826617197901218084948033244878\" + \"725818377480552226815101137174536841787028027445244290547451823467491956418855\" + \"124442133778352142386597992598820328708510933838682990657199461490629025742768\" + \"603885051103263854454041918495886653854504057132362968106914681484786965916686\" + \"184275679846004186876229805556296304595322792305161672159196867584952363529893\" + \"578850774608153732145464298479231051167635774949462295256949766035947396243099\" + \"534331040499420967788382700271447849406903707324910644415169605325656058677875\" + \"741747211082743577431519406075798356362914332639781221894628744779811980722564\" + \"671466405485013100965678631488009030374933887536418316513498254669467331611812\" + \"336485439764932502617954935720430540218297487125110740401161140589991109306249\" + \"231281311634054926257135672181862893278613883371802853505650359195274140086951\" + \"092616754147679266803210923746708721360627833292238641361959412133927803611827\" + \"632410600474097111104814000362334271451448333464167546635469973149475664342365\" + \"949349684588455152415075637660508663282742479413606287604129064491382851945640\" + \"264315322585862404314183866959063324506300039221319264762596269151090445769530\" + \"144405461803785750303668621246227863975274666787012100339298487337501447560032\" + \"210062235802934377495503203701273846816306102657030087227546296679688089058712\" + \"767636106622572235222973920644309352432722810085997309513252863060110549791564\" + \"479184500461804676240892892568091293059296064235702106152464620502324896659398\" + \"732493396737695202399176089847457184353193664652912584806448019652016283879518\" + \"949933675924148562613699594530728725453246329152911012876377060557060953137752\" + \"775186792329213495524513308986796916512907384130216757323863757582008036357572\" + \"800275449032795307990079944254110872569318801466793559583467643286887696661009\" + \"739574996783659339784634695994895061049038364740950469522606385804675807306991\" + \"229047408987916687211714752764471160440195271816950828973353714853092893704638\" + \"442089329977112585684084660833993404568902678751600877546126798801546585652206\" + \"121095349079670736553970257619943137663996060606110640695933082817187642604357\" + \"342536175694378484849525010826648839515970049059838081210522111109194332395113\" + \"605144645983421079905808209371646452312770402316007213854372346126726099787038\" + \"565709199850759563461324846018840985019428768790226873455650051912154654406382\" + \"925385127631766392205093834520430077301702994036261543400132276391091298832786\" + \"392041230044555168405488980908077917463609243933491264116424009388074635660726\" + \"233669584276458369826873481588196105857183576746200965052606592926354829149904\" + \"576830721089324585707370166071739819448502884260396366074603118478622583105658\" + \"087087030556759586134170074540296568763477417643105175103673286924555858208237\" + \"203860178173940517513043799486882232004437804310317092103426167499800007301609\" + \"481458637448877852227307633049538394434538277060876076354209844500830624763025\" + \"357278103278346176697054428715531534001649707665719598504174819908720149087568\" + \"603778359199471934335277294728553792578768483230110185936580071729118696761765\" + \"505377503029303383070644891281141202550615089641100762382457448865518258105814\" + \"034532012475472326908754750707857765973254284445935304499207001453874894822655\" + \"644222369636554419422544133821222547749753549462482768053333698328415613869236\" + \"344335855386847111143049824839899180316545863828935379913053522283343013795337\" + \"295401625762322808113849949187614414132293376710656349252881452823950620902235\" + \"787668465011666009738275366040544694165342223905210831458584703552935221992827\" + \"276057482126606529138553034554974455147034493948686342945965843102419078592368\" + \"022456076393678416627051855517870290407355730462063969245330779578224594971042\" + \"018804300018388142900817303945050734278701312446686009277858181104091151172937\" + \"487362788787490746528556543474888683106411005102302087510776891878152562273525\" + \"155037953244485778727761700196485370355516765520911933934376286628461984402629\" + \"525218367852236747510880978150709897841308624588152266096355140187449583692691\" + \"779904712072649490573726428600521140358123107600669951853612486274675637589622\" + \"529911649606687650826173417848478933729505673900787861792535144062104536625064\" + \"046372881569823231750059626108092195521115085930295565496753886261297233991462\" + \"835847604862762702730973920200143224870758233735491524608560821032888297418390\" + \"647886992327369136004883743661522351705843770554521081551336126214291181561530\" + \"175888257359489250710887926212864139244330938379733386780613179523731526677382\" + \"085802470143352700924380326695174211950767088432634644274912755890774686358216\" + \"216604274131517021245858605623363149316464691394656249747174195835421860774871\" + \"105733845843368993964591374060338215935224359475162623918868530782282176398323\" + \"730618020424656047752794310479618972429953302979249748168405289379104494700459\" + \"086499187272734541350810198388186467360939257193051196864560185578245021823106\" + \"588943798652243205067737996619695547244058592241795300682045179537004347245176\" + \"289356677050849021310773662575169733552746230294303120359626095342357439724965\" + \"921101065781782610874531887480318743082357369919515634095716270099244492974910\" + \"548985151965866474014822510633536794973714251022934188258511737199449911509758\" + \"374613010550506419772153192935487537119163026203032858865852848019350922587577\" + \"559742527658401172134232364808402714335636754204637518255252494432965704386138\" + \"786590196573880286840189408767281671413703366173265012057865391578070308871426\" + \"151907500149257611292767519309672845397116021360630309054224396632067432358279\" + \"788933232440577919927848463333977773765590187057480682867834796562414610289950\" + \"848739969297075043275302997287229732793444298864641272534816060377970729829917\" + \"302929630869580199631241330493935049332541235507105446118259114111645453471032\" + \"988104784406778013807713146540009938630648126661433085820681139583831916954555\" + \"825942689576984142889374346708410794631893253910696395578070602124597489829356\" + \"461356078898347241997947856436204209461341238761319886535235831299686226894860\" + \"840845665560687695450127448663140505473535174687300980632278046891224682146080\" + \"672762770840240226615548502400895289165711761743902033758487784291128962324705\" + \"919187469104200584832614067733375102719565399469716251724831223063391932870798\" + \"380074848572651612343493327335666447335855643023528088392434827876088616494328\" + \"939916639921048830784777704804572849145630335326507002958890626591549850940797\" + \"276756712979501009822947622896189159144152003228387877348513097908101912926722\" + \"710377889805396415636236416915498576840839846886168437540706512103906250612810\" + \"766379904790887967477806973847317047525344215639038720123880632368803701794930\" + \"895490077633152306354837425681665336160664198003018828712376748189833024683637\" + \"148830925928337590227894258806008728603885916884973069394802051122176635913825\" + \"152427867009440694235512020156837777885182467002565170850924962374772681369428\" + \"435006293881442998790530105621737545918267997321773502936892806521002539626880\" + \"749809264345801165571588670044350397650532347828732736884086354000274067678382\" + \"196352222653929093980736739136408289872201777674716811819585613372158311905468\" + \"293608323697611345028175783020293484598292500089568263027126329586629214765314\" + \"223335179309338795135709534637718368409244442209631933129562030557551734006797\" + \"374061416210792363342380564685009203716715264255637185388957141641977238742261\" + \"059666739699717316816941543509528319355641770566862221521799115135563970714331\" + \"289365755384464832620120642433801695586269856102246064606933079384785881436740\" + \"700059976970364901927332882613532936311240365069865216063898725026723808740339\" + \"674439783025829689425689674186433613497947524552629142652284241924308338810358\" + \"005378702399954217211368655027534136221169314069466951318692810257479598560514\" + \"500502171591331775160995786555198188619321128211070944228724044248115340605589\" + \"595835581523201218460582056359269930347885113206862662758877144603599665610843\" + \"072569650056306448918759946659677284717153957361210818084154727314266174893313\" + \"417463266235422207260014601270120693463952056444554329166298666078308906811879\" + \"009081529506362678207561438881578135113469536630387841209234694286873083932043\" + \"233387277549680521030282154432472338884521534372725012858974769146080831440412\" + \"586818154004918777228786980185345453700652665564917091542952275670922221747411\" + \"206272065662298980603289167206874365494824610869736722554740481288924247185432\" + \"360575341167285075755205713115669795458488739874222813588798584078313506054829\" + \"055148278529489112190538319562422871948475940785939804790109419407067176443903\" + \"273071213588738504999363883820550168340277749607027684488028191222063688863681\" + \"104356952930065219552826152699127163727738841899328713056346468822739828876319\" + \"864570983630891778648708667618548568004767255267541474285102814580740315299219\" + \"781455775684368111018531749816701642664788409026268282444825802753209454991510\" + \"451851771654631180490456798571325752811791365627815811128881656228587603087597\" + \"496384943527567661216895926148503078536204527450775295063101248034180458405943\" + \"292607985443562009370809182152392037179067812199228049606973823874331262673030\" + \"679594396095495718957721791559730058869364684557667609245090608820221223571925\" + \"453671519183487258742391941089044411595993276004450655620646116465566548759424\" + \"736925233695599303035509581762617623184956190649483967300203776387436934399982\" + \"943020914707361894793269276244518656023955905370512897816345542332011497599489\" + \"627842432748378803270141867695262118097500640514975588965029300486760520801049\" + \"153788541390942453169171998762894127722112946456829486028149318156024967788794\" + \"981377721622935943781100444806079767242927624951078415344642915084276452000204\" + \"276947069804177583220909702029165734725158290463091035903784297757265172087724\" + \"474095226716630600546971638794317119687348468873818665675127929857501636341131\" + \"462753049901913564682380432997069577015078933772865803571279091376742080565549\" + \"362541\" ; Tipps: Schauen Sie sich dazu die Klasse String genauer an! \u00dcberlegen Sie sich, wie Sie am besten alle m\u00f6glichen Kombinationen aus 4-stelligen Zahlen als String erzeugen k\u00f6nnen (also \"0000\", \"0001\", \"0002\", ... \"9999\" ) Schreiben Sie sich eine Methode int nrOfOccurences(String sub, String str) , die die Anzahl des Vorkommens von sub in str z\u00e4hlt. Sie k\u00f6nnen diese Methode z.B. testen, indem Sie sub=\"0000\" setzen und str=pi \u2192 \"0000\" kommt 9 Mal in pi vor. Testen Sie auch sub=\"2541\" und str=pi , denn \"2541\" ist der allerletzte substring in unserem pi und kommt 8 Mal vor. Merken Sie sich das bisherige maximale Vorkommen eines bestimmten substrings in pi \u2192 Sie merken sich den String und wie oft er vorkam (wenn er h\u00e4ufiger vorkam als der, den Sie sich bis dahin als h\u00e4ufigstes Vorkommen gemerkt hatten). Am Ende haben Sie sich dann den String gemerkt, der am h\u00e4ufigsten vorkommt und auch die Anzahl der Vorkommen. Laden Sie Ihre L\u00f6sung bis Sonntag, den 29.11.2020 um 24.00 Uhr in Moodle hoch Viel Spa\u00df und viel Erfolg! Aufgabe 3 - Arrays ausgeben Wir geben Arrays in verschiedenen Arten auf der Konsole aus. Implementieren Sie eine Methode public static int[] createAndFillArray(int length, int fromInclusive, int toInclusive) . Diese Methode soll genau so sein, wie die createAndFillArray(int length, int bound) -Methode in Methoden mit Array als R\u00fcckgabe mit dem einzigen Unterschied, dass wir nicht den bound angeben (der sorgt ja daf\u00fcr, dass wir Zufallswerte aus dem Bereich [0, 1, ... , bound-1] erzeugen), sondern fromInclusive und toExclusive , so dass wir Zufallswerte aus dem Wertebereich [fromInclusive, ... , toInclusive] erzeugen. Siehe dazu auch nextInt(bound) . Implementieren Sie eine Methode public static void printArray(int[] a) so, dass sie ein int -Array in der Form [ 27, 30, 25, 26, 23, 20, 30, 30, 22, 21, 29, 29, 21, 20 ] (also Werte durch Komma getrennt in eckigen Klammern) ausgibt. Siehe dazu Ausgabe von Arrays . Rufen Sie in der main() die beiden Methoden wie folgt auf: int length = r . nextInt ( 10 ) + 10 ; int [] arr1 = createAndFillArray ( length , 20 , 30 ); System . out . printf ( \"%n%n%n----------- printArray -----------------%n%n%n\" ); printArray ( arr1 ); Implementieren Sie eine Methode public static void printTable(int[] a) . Diese gibt das Array a als Tabelle in folgender Form aus: | Index : | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | | ------------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | | Wert : | 27 | 30 | 25 | 26 | 23 | 20 | 30 | 30 | 22 | 21 | 29 | 29 | 21 | 20 | Rufen Sie in der main() die Methode printTable() wie folgt auf: System . out . printf ( \"%n%n%n----------- printTable -----------------%n%n%n\" ); printTable ( arr1 ); Implementieren Sie eine Methode public static void printHorizontal(int[] a) . Diese gibt das Array a in folgender Form aus: | 0 | *************************** | 1 | ****************************** | 2 | ************************* | 3 | ************************** | 4 | *********************** | 5 | ******************** | 6 | ****************************** | 7 | ****************************** | 8 | ********************** | 9 | ********************* | 10 | ***************************** | 11 | ***************************** | 12 | ********************* | 13 | ******************** | Das hei\u00dft, f\u00fcr jeden Wert im Array wird die entsprechende Anzahl von Sternen ausgegeben. Ganz links steht jeweils der Index, unter dem der Wert im Array gespeichert wird. Rufen Sie in der main() die Methode printTable() wie folgt auf: System . out . printf ( \"%n%n%n----------- printHorizontal ------------%n%n%n\" ); printHorizontal ( arr1 ); Wenn Sie das geschafft haben, dann haben Sie die Aufgabe erf\u00fcllt! Herzlichen Gl\u00fcckwunsch! Die folgende(n) Aufgabe(n) sind optional : Implementieren Sie eine Methode public static void printUpsideDown(int[] a) oder eine Methode public static void printVertical(int[] a) (beide gleicher Aufwand). Diese geben das Array a in folgender Form aus: ----------- printUpsideDown ------------ | 0 1 2 3 4 5 6 7 8 9 10 11 12 13 ----+---------------------------------------------------------------------- 1 | * * * * * * * * * * * * * * 2 | * * * * * * * * * * * * * * 3 | * * * * * * * * * * * * * * 4 | * * * * * * * * * * * * * * 5 | * * * * * * * * * * * * * * 6 | * * * * * * * * * * * * * * 7 | * * * * * * * * * * * * * * 8 | * * * * * * * * * * * * * * 9 | * * * * * * * * * * * * * * 10 | * * * * * * * * * * * * * * 11 | * * * * * * * * * * * * * * 12 | * * * * * * * * * * * * * * 13 | * * * * * * * * * * * * * * 14 | * * * * * * * * * * * * * * 15 | * * * * * * * * * * * * * * 16 | * * * * * * * * * * * * * * 17 | * * * * * * * * * * * * * * 18 | * * * * * * * * * * * * * * 19 | * * * * * * * * * * * * * * 20 | * * * * * * * * * * * * * * 21 | * * * * * * * * * * * * 22 | * * * * * * * * * * 23 | * * * * * * * * * 24 | * * * * * * * * 25 | * * * * * * * * 26 | * * * * * * * 27 | * * * * * * 28 | * * * * * 29 | * * * * * 30 | * * * ----------- printVertical -------------- 30 | * * * 29 | * * * * * 28 | * * * * * 27 | * * * * * * 26 | * * * * * * * 25 | * * * * * * * * 24 | * * * * * * * * 23 | * * * * * * * * * 22 | * * * * * * * * * * 21 | * * * * * * * * * * * * 20 | * * * * * * * * * * * * * * 19 | * * * * * * * * * * * * * * 18 | * * * * * * * * * * * * * * 17 | * * * * * * * * * * * * * * 16 | * * * * * * * * * * * * * * 15 | * * * * * * * * * * * * * * 14 | * * * * * * * * * * * * * * 13 | * * * * * * * * * * * * * * 12 | * * * * * * * * * * * * * * 11 | * * * * * * * * * * * * * * 10 | * * * * * * * * * * * * * * 9 | * * * * * * * * * * * * * * 8 | * * * * * * * * * * * * * * 7 | * * * * * * * * * * * * * * 6 | * * * * * * * * * * * * * * 5 | * * * * * * * * * * * * * * 4 | * * * * * * * * * * * * * * 3 | * * * * * * * * * * * * * * 2 | * * * * * * * * * * * * * * 1 | * * * * * * * * * * * * * * ----+---------------------------------------------------------------------- | 0 1 2 3 4 5 6 7 8 9 10 11 12 13 Rufen Sie in der main() die beiden Methoden (oder die, die Sie implememntiert haben) wie folgt auf: System . out . printf ( \"%n%n%n----------- printUpsideDown ------------%n%n%n\" ); printUpsideDown ( arr1 ); System . out . printf ( \"%n%n%n----------- printVertical --------------%n%n%n\" ); printVertical ( arr1 ); Tipps zum L\u00f6sen der Zusatzaufgabe: Sie m\u00fcssen zun\u00e4chst ermitteln, welcher der gr\u00f6\u00dfte Wert innerhalb des Arrays ist, denn dieser gibt Ihnen die Anzahl der Zeilen im Diagramm vor. Stellen Sie sich das Problem als eine Matrix aus Zeilen und Spalten vor. Die Spalten lassen sich auf den Index des Arrays mappen und die Zeilen auf die Werte im Array. Viel Spa\u00df und viel Erfolg!","title":"Aufgaben"},{"location":"aufgaben/#aufgaben","text":"Hier finden Sie die Aufgaben. Die Abgabefristen der einzelnen Aufgaben stehen hier . Beachten Sie die nachfolgenden Hinweise zum Hochladen der Aufgaben.","title":"Aufgaben"},{"location":"aufgaben/#hinweise-zur-abgabe-der-aufgaben","text":"Die Aufgaben laden Sie in Moodle unter dem Reiter \"Aufgaben\" hoch. Dort ist f\u00fcr jede Aufgabe eine Moodle-Aufgabe erstellt. Beachten Sie, dass ein Hochladen nach Ablauf der Abgabefrist nicht mehr m\u00f6glich ist. Achten Sie darauf, dass Sie die Quelldateien (also die .java -Dateien aus dem src -Verzeichnis) hochladen. Ihre Klassen erstellen Sie immer in einem package aufgaben.aufgabeX . Das hei\u00dft, Aufgabe1 ist im package aufgaben.aufgabe1 , Aufgabe2 im package aufgaben.aufgabe2 usw. In Ihrem workspace gibt es dann einen Ordner f\u00fcr Ihr Java-Projekt, z.B. WS20 (je nachdem, wie Sie Ihr Java-Projekt genannt haben) und darin befindet sich ein bin - und ein src -Ordner. In dem src -Ordner befindet sich dann ein Ordner aufgaben und darin ein Ordner aufgaben1 (f\u00fcr Aufgabe1). Darin befindet sich Ihre .java -Datei, die Sie hochladen sollen. Angenommen, Sie haben Ihre Klasse Aufgabe1 genannt, dann hei\u00dft die Klasse also Aufgabe1.java . Sie folgen also dem Pfad workspace \u2192 Java-Projekt (z.B. WS20 ) \u2192 src \u2192 aufgaben \u2192 aufgabe X . Wenn Ihre L\u00f6sung aus mehreren Klassen (mehreren .java -Dateien) besteht, k\u00f6nnen Sie entweder die Dateien einzeln hochladen oder Sie zippen Ihre Dateien (am besten dann den aufgabeX -Ordner und laden das .zip -File hoch. In Ihrer L\u00f6sung (Ihrer/n Klasse/n) f\u00fcgen Sie direkt oberhalb Ihrer Klassendefinition einen JavaDoc-Kommentar ein ( /** ... */ ). Dieser enth\u00e4lt ein @author -Tag. dahinter schreiben Sie Ihren Namen. Das sieht dann z.B. so aus: package aufgaben.aufgabe1 ; /** * * @author J\u00f6rn Freiheit * * Diese Klasse gibt auf die Konsole ein Rhombus (eine Raute) aus. * Der Rhombus ist entweder gefuellt oder ungefuellt. * */ public class Aufgabe1 { // hier Ihre Implementierung } Sie k\u00f6nnen Ihre Aufgaben zu zweit l\u00f6sen. Tragen Sie dann hinter das @author -Tag beide Namen ein und laden Sie bitte beide die L\u00f6sung in Moodle hoch!","title":"Hinweise zur Abgabe der Aufgaben"},{"location":"aufgaben/#aufgaben_1","text":"Aufgabe1 - Rhombus Erstellen Sie eine Klasse Aufgabe1 mit main() -Methode im package aufgaben.aufgabe1 Implementieren Sie eine Methode public static void printRhombus(int upperHalf, boolean filled){} Ist der Parameterwert von filled true , dann soll ein Rhombus (eine Raute) wie folgt auf die Konsole ausgegeben werden: * *** ***** ******* ********* *********** ********* ******* ***** *** * Ist der Parameterwert von filled false , dann soll der Rhombus ungef\u00fcllt sein, also so: * * * * * * * * * * * * * * * * * * * * der Wert f\u00fcr upperHalf gibt die H\u00f6he einer H\u00e4lfte des Rhombus an. Die Gesamth\u00f6he des Rhombus berechnet sich aus ` int height = 2 * upperHalf + 1 ; In unserem oben gezeigten Beispiel ist der Wert von upperHalf 5 und die Gesamth\u00f6he des Rhombus 11 . Die obere Ausgabe ist also durch die Anweisung printRhombus(5, true); und die untere durch die Anweisung printRhombus(5, false); entstanden. Die Berechnung der H\u00f6he aus dem Parameterwert upperHalf hat die Vorteile, dass die H\u00f6he dadurch immer eine ungerade Zahl ist (was notwendig ist) und dass Sie den Wert upperHalf gut verwenden k\u00f6nnen (was ebenfalls notwendig ist, wie Sie merken werden) Tipp: : Schreiben Sie sich zwei weitere Methoden public static void printRhombusFilled(int upperHalf){} und public static void printRhombusUnfilled(int upperHalf){} , die Sie entsprechend des Wertes von filled aufrufen. In der einen Methode erstellen Sie die ausgef\u00fcllte Raute und in der anderen die ungef\u00fcllte. Dann wird Ihr Programm nicht zu un\u00fcbersichtlich. Fangen Sie am besten mit der ausgef\u00fcllten an, die ist etwas leichter. Das Programm soll f\u00fcr beliebige (nicht so gro\u00dfe - max. Wert 100 ) positive Zahlen (also > 0 ) von upperHalf funktionieren. Insbesondere sind die Tests f\u00fcr upperhalf == 1 interssant. Laden Sie Ihre L\u00f6sung bis Sonntag, den 22.11.2020 um 24.00 Uhr in Moodle hoch Viel Spa\u00df und viel Erfolg! Eine m\u00f6gliche L\u00f6sung f\u00fcr Aufgabe 1 package aufgaben.aufgabe1 ; public class Aufgabe1 { public static void printRhombus ( int upperHalf , boolean filled ) { if ( filled ) { printRhombusFilled ( upperHalf ); } else { printRhombusUnfilled ( upperHalf ); } } /* * 0: upperHalf LZ * * 1: upperHalf-1 LZ * * 2: upperHalf-2 LZ * * ... */ public static void printRhombusFilled ( int upperHalf ) { int height = 2 * upperHalf + 1 ; for ( int row = 0 ; row < height ; row ++ ) { /* System.out.printf(\"row : %3d (height-row) : %3d (upperHalf - row) : %3d \", row, (height-row), (upperHalf - row)); */ if ( row <= upperHalf ) { for ( int spaces = 0 ; spaces < ( upperHalf - row ); spaces ++ ) { System . out . print ( \" \" ); } for ( int stars = 0 ; stars < ( row * 2 + 1 ); stars ++ ) { System . out . print ( \"*\" ); } System . out . println (); } else // row > upperHalf { for ( int spaces = 0 ; spaces < ( row - upperHalf ); spaces ++ ) { System . out . print ( \" \" ); } for ( int stars = 0 ; stars < ( height - row ) * 2 - 1 ; stars ++ ) { System . out . print ( \"*\" ); } System . out . println (); } } } public static void printRhombusUnfilled ( int upperHalf ) { int height = 2 * upperHalf + 1 ; for ( int row = 0 ; row < height ; row ++ ) { if ( row <= upperHalf ) { for ( int spaces = 0 ; spaces < ( upperHalf - row ); spaces ++ ) { System . out . print ( \" \" ); } System . out . print ( \"*\" ); for ( int spaces = 0 ; spaces < ( row - 1 ) * 2 + 1 ; spaces ++ ) { System . out . print ( \" \" ); } if ( row == 0 ) { System . out . println (); } else { System . out . println ( \"*\" ); } } else // row > upperHalf { for ( int spaces = 0 ; spaces < ( row - upperHalf ); spaces ++ ) { System . out . print ( \" \" ); } System . out . print ( \"*\" ); for ( int spaces = 0 ; spaces < ( height - row - 1 ) * 2 - 1 ; spaces ++ ) { System . out . print ( \" \" ); } if ( row == ( height - 1 )) { System . out . println (); } else { System . out . println ( \"*\" ); } } } } public static void main ( String [] args ) { printRhombus ( 6 , true ); System . out . println (); printRhombus ( 1 , false ); } } Video zu Aufgabe 1 - sorry f\u00fcr die L\u00fcfterger\u00e4usche!!! nervig! Aufgabe 2 - \u03c0 kodieren Die Zahl \u03c0 ist eine irrationale Zahl, d.h. sie kann nicht als Bruch dargestellt werden. Au\u00dferdem ist sie nicht periodisch, d.h. es gibt keine immer wiederkehrende Folge von Ziffern im Nachkommabereich. Die Zahl \u03c0 hat unendlich viele Nachkommastellen und da sie nicht periodisch ist, kommen alle m\u00f6glichen Ziffernfolge in \u03c0 vor. Beispielsweise kommt die Ziffernfolge 123456 allein in den ersten 200 Millionen Nachkommastellen 208 Mal vor. Angenommen, wir \u201ecodieren\u201c \u03c0 und weisen einer Ziffer einen Buchstaben zu, z.B. Dann erg\u00e4be z.B. die Ziffernfolge 45923078 codiert das Wort \u201eCOMPUTER\u201c. Dieses Wort \u201eerscheint\u201c unter dieser Codierung an folgender Stelle: 3.14159265358979323846264338327950288419716939937510582097494 45923078 164062862089986280348253421170679 Ihre Aufgabe: Suchen Sie die 4-stellige Ziffernfolge, die am h\u00e4ufigsten in (den ersten 100 000 Nachkommastellen von) \u03c0 vorkommt. Hier der String, der alle diese Nachkommastellen enth\u00e4lt (kopieren Sie diese Deklaration und Initialisierung in Ihr Programm - wahrscheinlich am besten in main() ): Variable String pi String pi = \"3\" + \"141592653589793238462643383279502884197169399375105820974944592307816406286\" + \"208998628034825342117067982148086513282306647093844609550582231725359408128481\" + \"117450284102701938521105559644622948954930381964428810975665933446128475648233\" + \"786783165271201909145648566923460348610454326648213393607260249141273724587006\" + \"606315588174881520920962829254091715364367892590360011330530548820466521384146\" + \"951941511609433057270365759591953092186117381932611793105118548074462379962749\" + \"567351885752724891227938183011949129833673362440656643086021394946395224737190\" + \"702179860943702770539217176293176752384674818467669405132000568127145263560827\" + \"785771342757789609173637178721468440901224953430146549585371050792279689258923\" + \"542019956112129021960864034418159813629774771309960518707211349999998372978049\" + \"951059731732816096318595024459455346908302642522308253344685035261931188171010\" + \"003137838752886587533208381420617177669147303598253490428755468731159562863882\" + \"353787593751957781857780532171226806613001927876611195909216420198938095257201\" + \"065485863278865936153381827968230301952035301852968995773622599413891249721775\" + \"283479131515574857242454150695950829533116861727855889075098381754637464939319\" + \"255060400927701671139009848824012858361603563707660104710181942955596198946767\" + \"837449448255379774726847104047534646208046684259069491293313677028989152104752\" + \"162056966024058038150193511253382430035587640247496473263914199272604269922796\" + \"782354781636009341721641219924586315030286182974555706749838505494588586926995\" + \"690927210797509302955321165344987202755960236480665499119881834797753566369807\" + \"426542527862551818417574672890977772793800081647060016145249192173217214772350\" + \"141441973568548161361157352552133475741849468438523323907394143334547762416862\" + \"518983569485562099219222184272550254256887671790494601653466804988627232791786\" + \"085784383827967976681454100953883786360950680064225125205117392984896084128488\" + \"626945604241965285022210661186306744278622039194945047123713786960956364371917\" + \"287467764657573962413890865832645995813390478027590099465764078951269468398352\" + \"595709825822620522489407726719478268482601476990902640136394437455305068203496\" + \"252451749399651431429809190659250937221696461515709858387410597885959772975498\" + \"930161753928468138268683868942774155991855925245953959431049972524680845987273\" + \"644695848653836736222626099124608051243884390451244136549762780797715691435997\" + \"700129616089441694868555848406353422072225828488648158456028506016842739452267\" + \"467678895252138522549954666727823986456596116354886230577456498035593634568174\" + \"324112515076069479451096596094025228879710893145669136867228748940560101503308\" + \"617928680920874760917824938589009714909675985261365549781893129784821682998948\" + \"722658804857564014270477555132379641451523746234364542858444795265867821051141\" + \"354735739523113427166102135969536231442952484937187110145765403590279934403742\" + \"007310578539062198387447808478489683321445713868751943506430218453191048481005\" + \"370614680674919278191197939952061419663428754440643745123718192179998391015919\" + \"561814675142691239748940907186494231961567945208095146550225231603881930142093\" + \"762137855956638937787083039069792077346722182562599661501421503068038447734549\" + \"202605414665925201497442850732518666002132434088190710486331734649651453905796\" + \"268561005508106658796998163574736384052571459102897064140110971206280439039759\" + \"515677157700420337869936007230558763176359421873125147120532928191826186125867\" + \"321579198414848829164470609575270695722091756711672291098169091528017350671274\" + \"858322287183520935396572512108357915136988209144421006751033467110314126711136\" + \"990865851639831501970165151168517143765761835155650884909989859982387345528331\" + \"635507647918535893226185489632132933089857064204675259070915481416549859461637\" + \"180270981994309924488957571282890592323326097299712084433573265489382391193259\" + \"746366730583604142813883032038249037589852437441702913276561809377344403070746\" + \"921120191302033038019762110110044929321516084244485963766983895228684783123552\" + \"658213144957685726243344189303968642624341077322697802807318915441101044682325\" + \"271620105265227211166039666557309254711055785376346682065310989652691862056476\" + \"931257058635662018558100729360659876486117910453348850346113657686753249441668\" + \"039626579787718556084552965412665408530614344431858676975145661406800700237877\" + \"659134401712749470420562230538994561314071127000407854733269939081454664645880\" + \"797270826683063432858785698305235808933065757406795457163775254202114955761581\" + \"400250126228594130216471550979259230990796547376125517656751357517829666454779\" + \"174501129961489030463994713296210734043751895735961458901938971311179042978285\" + \"647503203198691514028708085990480109412147221317947647772622414254854540332157\" + \"185306142288137585043063321751829798662237172159160771669254748738986654949450\" + \"114654062843366393790039769265672146385306736096571209180763832716641627488880\" + \"078692560290228472104031721186082041900042296617119637792133757511495950156604\" + \"963186294726547364252308177036751590673502350728354056704038674351362222477158\" + \"915049530984448933309634087807693259939780541934144737744184263129860809988868\" + \"741326047215695162396586457302163159819319516735381297416772947867242292465436\" + \"680098067692823828068996400482435403701416314965897940924323789690706977942236\" + \"250822168895738379862300159377647165122893578601588161755782973523344604281512\" + \"627203734314653197777416031990665541876397929334419521541341899485444734567383\" + \"162499341913181480927777103863877343177207545654532207770921201905166096280490\" + \"926360197598828161332316663652861932668633606273567630354477628035045077723554\" + \"710585954870279081435624014517180624643626794561275318134078330336254232783944\" + \"975382437205835311477119926063813346776879695970309833913077109870408591337464\" + \"144282277263465947047458784778720192771528073176790770715721344473060570073349\" + \"243693113835049316312840425121925651798069411352801314701304781643788518529092\" + \"854520116583934196562134914341595625865865570552690496520985803385072242648293\" + \"972858478316305777756068887644624824685792603953527734803048029005876075825104\" + \"747091643961362676044925627420420832085661190625454337213153595845068772460290\" + \"161876679524061634252257719542916299193064553779914037340432875262888963995879\" + \"475729174642635745525407909145135711136941091193932519107602082520261879853188\" + \"770584297259167781314969900901921169717372784768472686084900337702424291651300\" + \"500516832336435038951702989392233451722013812806965011784408745196012122859937\" + \"162313017114448464090389064495444006198690754851602632750529834918740786680881\" + \"833851022833450850486082503930213321971551843063545500766828294930413776552793\" + \"975175461395398468339363830474611996653858153842056853386218672523340283087112\" + \"328278921250771262946322956398989893582116745627010218356462201349671518819097\" + \"303811980049734072396103685406643193950979019069963955245300545058068550195673\" + \"022921913933918568034490398205955100226353536192041994745538593810234395544959\" + \"778377902374216172711172364343543947822181852862408514006660443325888569867054\" + \"315470696574745855033232334210730154594051655379068662733379958511562578432298\" + \"827372319898757141595781119635833005940873068121602876496286744604774649159950\" + \"549737425626901049037781986835938146574126804925648798556145372347867330390468\" + \"838343634655379498641927056387293174872332083760112302991136793862708943879936\" + \"201629515413371424892830722012690147546684765357616477379467520049075715552781\" + \"965362132392640616013635815590742202020318727760527721900556148425551879253034\" + \"351398442532234157623361064250639049750086562710953591946589751413103482276930\" + \"624743536325691607815478181152843667957061108615331504452127473924544945423682\" + \"886061340841486377670096120715124914043027253860764823634143346235189757664521\" + \"641376796903149501910857598442391986291642193994907236234646844117394032659184\" + \"044378051333894525742399508296591228508555821572503107125701266830240292952522\" + \"011872676756220415420516184163484756516999811614101002996078386909291603028840\" + \"026910414079288621507842451670908700069928212066041837180653556725253256753286\" + \"129104248776182582976515795984703562226293486003415872298053498965022629174878\" + \"820273420922224533985626476691490556284250391275771028402799806636582548892648\" + \"802545661017296702664076559042909945681506526530537182941270336931378517860904\" + \"070866711496558343434769338578171138645587367812301458768712660348913909562009\" + \"939361031029161615288138437909904231747336394804575931493140529763475748119356\" + \"709110137751721008031559024853090669203767192203322909433467685142214477379393\" + \"751703443661991040337511173547191855046449026365512816228824462575916333039107\" + \"225383742182140883508657391771509682887478265699599574490661758344137522397096\" + \"834080053559849175417381883999446974867626551658276584835884531427756879002909\" + \"517028352971634456212964043523117600665101241200659755851276178583829204197484\" + \"423608007193045761893234922927965019875187212726750798125547095890455635792122\" + \"103334669749923563025494780249011419521238281530911407907386025152274299581807\" + \"247162591668545133312394804947079119153267343028244186041426363954800044800267\" + \"049624820179289647669758318327131425170296923488962766844032326092752496035799\" + \"646925650493681836090032380929345958897069536534940603402166544375589004563288\" + \"225054525564056448246515187547119621844396582533754388569094113031509526179378\" + \"002974120766514793942590298969594699556576121865619673378623625612521632086286\" + \"922210327488921865436480229678070576561514463204692790682120738837781423356282\" + \"360896320806822246801224826117718589638140918390367367222088832151375560037279\" + \"839400415297002878307667094447456013455641725437090697939612257142989467154357\" + \"846878861444581231459357198492252847160504922124247014121478057345510500801908\" + \"699603302763478708108175450119307141223390866393833952942578690507643100638351\" + \"983438934159613185434754649556978103829309716465143840700707360411237359984345\" + \"225161050702705623526601276484830840761183013052793205427462865403603674532865\" + \"105706587488225698157936789766974220575059683440869735020141020672358502007245\" + \"225632651341055924019027421624843914035998953539459094407046912091409387001264\" + \"560016237428802109276457931065792295524988727584610126483699989225695968815920\" + \"560010165525637567856672279661988578279484885583439751874454551296563443480396\" + \"642055798293680435220277098429423253302257634180703947699415979159453006975214\" + \"829336655566156787364005366656416547321704390352132954352916941459904160875320\" + \"186837937023488868947915107163785290234529244077365949563051007421087142613497\" + \"459561513849871375704710178795731042296906667021449863746459528082436944578977\" + \"233004876476524133907592043401963403911473202338071509522201068256342747164602\" + \"433544005152126693249341967397704159568375355516673027390074972973635496453328\" + \"886984406119649616277344951827369558822075735517665158985519098666539354948106\" + \"887320685990754079234240230092590070173196036225475647894064754834664776041146\" + \"323390565134330684495397907090302346046147096169688688501408347040546074295869\" + \"913829668246818571031887906528703665083243197440477185567893482308943106828702\" + \"722809736248093996270607472645539925399442808113736943388729406307926159599546\" + \"262462970706259484556903471197299640908941805953439325123623550813494900436427\" + \"852713831591256898929519642728757394691427253436694153236100453730488198551706\" + \"594121735246258954873016760029886592578662856124966552353382942878542534048308\" + \"330701653722856355915253478445981831341129001999205981352205117336585640782648\" + \"494276441137639386692480311836445369858917544264739988228462184490087776977631\" + \"279572267265556259628254276531830013407092233436577916012809317940171859859993\" + \"384923549564005709955856113498025249906698423301735035804408116855265311709957\" + \"089942732870925848789443646005041089226691783525870785951298344172953519537885\" + \"534573742608590290817651557803905946408735061232261120093731080485485263572282\" + \"576820341605048466277504500312620080079980492548534694146977516493270950493463\" + \"938243222718851597405470214828971117779237612257887347718819682546298126868581\" + \"705074027255026332904497627789442362167411918626943965067151577958675648239939\" + \"176042601763387045499017614364120469218237076488783419689686118155815873606293\" + \"860381017121585527266830082383404656475880405138080163363887421637140643549556\" + \"186896411228214075330265510042410489678352858829024367090488711819090949453314\" + \"421828766181031007354770549815968077200947469613436092861484941785017180779306\" + \"810854690009445899527942439813921350558642219648349151263901280383200109773868\" + \"066287792397180146134324457264009737425700735921003154150893679300816998053652\" + \"027600727749674584002836240534603726341655425902760183484030681138185510597970\" + \"566400750942608788573579603732451414678670368809880609716425849759513806930944\" + \"940151542222194329130217391253835591503100333032511174915696917450271494331515\" + \"588540392216409722910112903552181576282328318234254832611191280092825256190205\" + \"263016391147724733148573910777587442538761174657867116941477642144111126358355\" + \"387136101102326798775641024682403226483464176636980663785768134920453022408197\" + \"278564719839630878154322116691224641591177673225326433568614618654522268126887\" + \"268445968442416107854016768142080885028005414361314623082102594173756238994207\" + \"571362751674573189189456283525704413354375857534269869947254703165661399199968\" + \"262824727064133622217892390317608542894373393561889165125042440400895271983787\" + \"386480584726895462438823437517885201439560057104811949884239060613695734231559\" + \"079670346149143447886360410318235073650277859089757827273130504889398900992391\" + \"350337325085598265586708924261242947367019390772713070686917092646254842324074\" + \"855036608013604668951184009366860954632500214585293095000090715105823626729326\" + \"453738210493872499669933942468551648326113414611068026744663733437534076429402\" + \"668297386522093570162638464852851490362932019919968828517183953669134522244470\" + \"804592396602817156551565666111359823112250628905854914509715755390024393153519\" + \"090210711945730024388017661503527086260253788179751947806101371500448991721002\" + \"220133501310601639154158957803711779277522597874289191791552241718958536168059\" + \"474123419339842021874564925644346239253195313510331147639491199507285843065836\" + \"193536932969928983791494193940608572486396883690326556436421664425760791471086\" + \"998431573374964883529276932822076294728238153740996154559879825989109371712621\" + \"828302584811238901196822142945766758071865380650648702613389282299497257453033\" + \"283896381843944770779402284359883410035838542389735424395647555684095224844554\" + \"139239410001620769363684677641301781965937997155746854194633489374843912974239\" + \"143365936041003523437770658886778113949861647874714079326385873862473288964564\" + \"359877466763847946650407411182565837887845485814896296127399841344272608606187\" + \"245545236064315371011274680977870446409475828034876975894832824123929296058294\" + \"861919667091895808983320121031843034012849511620353428014412761728583024355983\" + \"003204202451207287253558119584014918096925339507577840006746552603144616705082\" + \"768277222353419110263416315714740612385042584598841990761128725805911393568960\" + \"143166828317632356732541707342081733223046298799280490851409479036887868789493\" + \"054695570307261900950207643349335910602454508645362893545686295853131533718386\" + \"826561786227363716975774183023986006591481616404944965011732131389574706208847\" + \"480236537103115089842799275442685327797431139514357417221975979935968525228574\" + \"526379628961269157235798662057340837576687388426640599099350500081337543245463\" + \"596750484423528487470144354541957625847356421619813407346854111766883118654489\" + \"377697956651727966232671481033864391375186594673002443450054499539974237232871\" + \"249483470604406347160632583064982979551010954183623503030945309733583446283947\" + \"630477564501500850757894954893139394489921612552559770143685894358587752637962\" + \"559708167764380012543650237141278346792610199558522471722017772370041780841942\" + \"394872540680155603599839054898572354674564239058585021671903139526294455439131\" + \"663134530893906204678438778505423939052473136201294769187497519101147231528932\" + \"677253391814660730008902776896311481090220972452075916729700785058071718638105\" + \"496797310016787085069420709223290807038326345345203802786099055690013413718236\" + \"837099194951648960075504934126787643674638490206396401976668559233565463913836\" + \"318574569814719621084108096188460545603903845534372914144651347494078488442377\" + \"217515433426030669883176833100113310869042193903108014378433415137092435301367\" + \"763108491351615642269847507430329716746964066653152703532546711266752246055119\" + \"958183196376370761799191920357958200759560530234626775794393630746305690108011\" + \"494271410093913691381072581378135789400559950018354251184172136055727522103526\" + \"803735726527922417373605751127887218190844900617801388971077082293100279766593\" + \"583875890939568814856026322439372656247277603789081445883785501970284377936240\" + \"782505270487581647032458129087839523245323789602984166922548964971560698119218\" + \"658492677040395648127810217991321741630581055459880130048456299765112124153637\" + \"451500563507012781592671424134210330156616535602473380784302865525722275304999\" + \"883701534879300806260180962381516136690334111138653851091936739383522934588832\" + \"255088706450753947395204396807906708680644509698654880168287434378612645381583\" + \"428075306184548590379821799459968115441974253634439960290251001588827216474500\" + \"682070419376158454712318346007262933955054823955713725684023226821301247679452\" + \"264482091023564775272308208106351889915269288910845557112660396503439789627825\" + \"001611015323516051965590421184494990778999200732947690586857787872098290135295\" + \"661397888486050978608595701773129815531495168146717695976099421003618355913877\" + \"781769845875810446628399880600616229848616935337386578773598336161338413385368\" + \"421197893890018529569196780455448285848370117096721253533875862158231013310387\" + \"766827211572694951817958975469399264219791552338576623167627547570354699414892\" + \"904130186386119439196283887054367774322427680913236544948536676800000106526248\" + \"547305586159899914017076983854831887501429389089950685453076511680333732226517\" + \"566220752695179144225280816517166776672793035485154204023817460892328391703275\" + \"425750867655117859395002793389592057668278967764453184040418554010435134838953\" + \"120132637836928358082719378312654961745997056745071833206503455664403449045362\" + \"756001125018433560736122276594927839370647842645676338818807565612168960504161\" + \"139039063960162022153684941092605387688714837989559999112099164646441191856827\" + \"700457424343402167227644558933012778158686952506949936461017568506016714535431\" + \"581480105458860564550133203758645485840324029871709348091055621167154684847780\" + \"394475697980426318099175642280987399876697323769573701580806822904599212366168\" + \"902596273043067931653114940176473769387351409336183321614280214976339918983548\" + \"487562529875242387307755955595546519639440182184099841248982623673771467226061\" + \"633643296406335728107078875816404381485018841143188598827694490119321296827158\" + \"884133869434682859006664080631407775772570563072940049294030242049841656547973\" + \"670548558044586572022763784046682337985282710578431975354179501134727362577408\" + \"021347682604502285157979579764746702284099956160156910890384582450267926594205\" + \"550395879229818526480070683765041836562094555434613513415257006597488191634135\" + \"955671964965403218727160264859304903978748958906612725079482827693895352175362\" + \"185079629778514618843271922322381015874445052866523802253284389137527384589238\" + \"442253547265309817157844783421582232702069028723233005386216347988509469547200\" + \"479523112015043293226628272763217790884008786148022147537657810581970222630971\" + \"749507212724847947816957296142365859578209083073323356034846531873029302665964\" + \"501371837542889755797144992465403868179921389346924474198509733462679332107268\" + \"687076806263991936196504409954216762784091466985692571507431574079380532392523\" + \"947755744159184582156251819215523370960748332923492103451462643744980559610330\" + \"799414534778457469999212859999939961228161521931488876938802228108300198601654\" + \"941654261696858678837260958774567618250727599295089318052187292461086763995891\" + \"614585505839727420980909781729323930106766386824040111304024700735085782872462\" + \"713494636853181546969046696869392547251941399291465242385776255004748529547681\" + \"479546700705034799958886769501612497228204030399546327883069597624936151010243\" + \"655535223069061294938859901573466102371223547891129254769617600504797492806072\" + \"126803922691102777226102544149221576504508120677173571202718024296810620377657\" + \"883716690910941807448781404907551782038565390991047759414132154328440625030180\" + \"275716965082096427348414695726397884256008453121406593580904127113592004197598\" + \"513625479616063228873618136737324450607924411763997597461938358457491598809766\" + \"744709300654634242346063423747466608043170126005205592849369594143408146852981\" + \"505394717890045183575515412522359059068726487863575254191128887737176637486027\" + \"660634960353679470269232297186832771739323619200777452212624751869833495151019\" + \"864269887847171939664976907082521742336566272592844062043021411371992278526998\" + \"469884770232382384005565551788908766136013047709843861168705231055314916251728\" + \"373272867600724817298763756981633541507460883866364069347043720668865127568826\" + \"614973078865701568501691864748854167915459650723428773069985371390430026653078\" + \"398776385032381821553559732353068604301067576083890862704984188859513809103042\" + \"359578249514398859011318583584066747237029714978508414585308578133915627076035\" + \"639076394731145549583226694570249413983163433237897595568085683629725386791327\" + \"505554252449194358912840504522695381217913191451350099384631177401797151228378\" + \"546011603595540286440590249646693070776905548102885020808580087811577381719174\" + \"177601733073855475800605601433774329901272867725304318251975791679296996504146\" + \"070664571258883469797964293162296552016879730003564630457930884032748077181155\" + \"533090988702550520768046303460865816539487695196004408482065967379473168086415\" + \"645650530049881616490578831154345485052660069823093157776500378070466126470602\" + \"145750579327096204782561524714591896522360839664562410519551052235723973951288\" + \"181640597859142791481654263289200428160913693777372229998332708208296995573772\" + \"737566761552711392258805520189887620114168005468736558063347160373429170390798\" + \"639652296131280178267971728982293607028806908776866059325274637840539769184808\" + \"204102194471971386925608416245112398062011318454124478205011079876071715568315\" + \"407886543904121087303240201068534194723047666672174986986854707678120512473679\" + \"247919315085644477537985379973223445612278584329684664751333657369238720146472\" + \"367942787004250325558992688434959287612400755875694641370562514001179713316620\" + \"715371543600687647731867558714878398908107429530941060596944315847753970094398\" + \"839491443235366853920994687964506653398573888786614762944341401049888993160051\" + \"207678103588611660202961193639682134960750111649832785635316145168457695687109\" + \"002999769841263266502347716728657378579085746646077228341540311441529418804782\" + \"543876177079043000156698677679576090996693607559496515273634981189641304331166\" + \"277471233881740603731743970540670310967676574869535878967003192586625941051053\" + \"358438465602339179674926784476370847497833365557900738419147319886271352595462\" + \"518160434225372996286326749682405806029642114638643686422472488728343417044157\" + \"348248183330164056695966886676956349141632842641497453334999948000266998758881\" + \"593507357815195889900539512085351035726137364034367534714104836017546488300407\" + \"846416745216737190483109676711344349481926268111073994825060739495073503169019\" + \"731852119552635632584339099822498624067031076831844660729124874754031617969941\" + \"139738776589986855417031884778867592902607004321266617919223520938227878880988\" + \"633599116081923535557046463491132085918979613279131975649097600013996234445535\" + \"014346426860464495862476909434704829329414041114654092398834443515913320107739\" + \"441118407410768498106634724104823935827401944935665161088463125678529776973468\" + \"430306146241803585293315973458303845541033701091676776374276210213701354854450\" + \"926307190114731848574923318167207213727935567952844392548156091372812840633303\" + \"937356242001604566455741458816605216660873874804724339121295587776390696903707\" + \"882852775389405246075849623157436917113176134783882719416860662572103685132156\" + \"647800147675231039357860689611125996028183930954870905907386135191459181951029\" + \"732787557104972901148717189718004696169777001791391961379141716270701895846921\" + \"434369676292745910994006008498356842520191559370370101104974733949387788598941\" + \"743303178534870760322198297057975119144051099423588303454635349234982688362404\" + \"332726741554030161950568065418093940998202060999414021689090070821330723089662\" + \"119775530665918814119157783627292746156185710372172471009521423696483086410259\" + \"288745799932237495519122195190342445230753513380685680735446499512720317448719\" + \"540397610730806026990625807602029273145525207807991418429063884437349968145827\" + \"337207266391767020118300464819000241308350884658415214899127610651374153943565\" + \"721139032857491876909441370209051703148777346165287984823533829726013611098451\" + \"484182380812054099612527458088109948697221612852489742555551607637167505489617\" + \"301680961380381191436114399210638005083214098760459930932485102516829446726066\" + \"613815174571255975495358023998314698220361338082849935670557552471290274539776\" + \"214049318201465800802156653606776550878380430413431059180460680083459113664083\" + \"488740800574127258670479225831912741573908091438313845642415094084913391809684\" + \"025116399193685322555733896695374902662092326131885589158083245557194845387562\" + \"878612885900410600607374650140262782402734696252821717494158233174923968353013\" + \"617865367376064216677813773995100658952887742766263684183068019080460984980946\" + \"976366733566228291513235278880615776827815958866918023894033307644191240341202\" + \"231636857786035727694154177882643523813190502808701857504704631293335375728538\" + \"660588890458311145077394293520199432197117164223500564404297989208159430716701\" + \"985746927384865383343614579463417592257389858800169801475742054299580124295810\" + \"545651083104629728293758416116253256251657249807849209989799062003593650993472\" + \"158296517413579849104711166079158743698654122234834188772292944633517865385673\" + \"196255985202607294767407261676714557364981210567771689348491766077170527718760\" + \"119990814411305864557791052568430481144026193840232247093924980293355073184589\" + \"035539713308844617410795916251171486487446861124760542867343670904667846867027\" + \"409188101424971114965781772427934707021668829561087779440504843752844337510882\" + \"826477197854000650970403302186255614733211777117441335028160884035178145254196\" + \"432030957601869464908868154528562134698835544456024955666843660292219512483091\" + \"060537720198021831010327041783866544718126039719068846237085751808003532704718\" + \"565949947612424811099928867915896904956394762460842406593094862150769031498702\" + \"067353384834955083636601784877106080980426924713241000946401437360326564518456\" + \"679245666955100150229833079849607994988249706172367449361226222961790814311414\" + \"660941234159359309585407913908720832273354957208075716517187659944985693795623\" + \"875551617575438091780528029464200447215396280746360211329425591600257073562812\" + \"638733106005891065245708024474937543184149401482119996276453106800663118382376\" + \"163966318093144467129861552759820145141027560068929750246304017351489194576360\" + \"789352855505317331416457050499644389093630843874484783961684051845273288403234\" + \"520247056851646571647713932377551729479512613239822960239454857975458651745878\" + \"771331813875295980941217422730035229650808917770506825924882232215493804837145\" + \"478164721397682096332050830564792048208592047549985732038887639160199524091893\" + \"894557676874973085695595801065952650303626615975066222508406742889826590751063\" + \"756356996821151094966974458054728869363102036782325018232370845979011154847208\" + \"761821247781326633041207621658731297081123075815982124863980721240786887811450\" + \"165582513617890307086087019897588980745664395515741536319319198107057533663373\" + \"803827215279884935039748001589051942087971130805123393322190346624991716915094\" + \"854140187106035460379464337900589095772118080446574396280618671786101715674096\" + \"766208029576657705129120990794430463289294730615951043090222143937184956063405\" + \"618934251305726829146578329334052463502892917547087256484260034962961165413823\" + \"007731332729830500160256724014185152041890701154288579920812198449315699905918\" + \"201181973350012618772803681248199587707020753240636125931343859554254778196114\" + \"293516356122349666152261473539967405158499860355295332924575238881013620234762\" + \"466905581643896786309762736550472434864307121849437348530060638764456627218666\" + \"170123812771562137974614986132874411771455244470899714452288566294244023018479\" + \"120547849857452163469644897389206240194351831008828348024924908540307786387516\" + \"591130287395878709810077271827187452901397283661484214287170553179654307650453\" + \"432460053636147261818096997693348626407743519992868632383508875668359509726557\" + \"481543194019557685043724800102041374983187225967738715495839971844490727914196\" + \"584593008394263702087563539821696205532480321226749891140267852859967340524203\" + \"109179789990571882194939132075343170798002373659098537552023891164346718558290\" + \"685371189795262623449248339249634244971465684659124891855662958932990903523923\" + \"333364743520370770101084388003290759834217018554228386161721041760301164591878\" + \"053936744747205998502358289183369292233732399948043710841965947316265482574809\" + \"948250999183300697656936715968936449334886474421350084070066088359723503953234\" + \"017958255703601693699098867113210979889707051728075585519126993067309925070407\" + \"024556850778679069476612629808225163313639952117098452809263037592242674257559\" + \"989289278370474445218936320348941552104459726188380030067761793138139916205806\" + \"270165102445886924764924689192461212531027573139084047000714356136231699237169\" + \"484813255420091453041037135453296620639210547982439212517254013231490274058589\" + \"206321758949434548906846399313757091034633271415316223280552297297953801880162\" + \"859073572955416278867649827418616421878988574107164906919185116281528548679417\" + \"363890665388576422915834250067361245384916067413734017357277995634104332688356\" + \"950781493137800736235418007061918026732855119194267609122103598746924117283749\" + \"312616339500123959924050845437569850795704622266461900010350049018303415354584\" + \"283376437811198855631877779253720116671853954183598443830520376281944076159410\" + \"682071697030228515225057312609304689842343315273213136121658280807521263154773\" + \"060442377475350595228717440266638914881717308643611138906942027908814311944879\" + \"941715404210341219084709408025402393294294549387864023051292711909751353600092\" + \"197110541209668311151632870542302847007312065803262641711616595761327235156666\" + \"253667271899853419989523688483099930275741991646384142707798870887422927705389\" + \"122717248632202889842512528721782603050099451082478357290569198855546788607946\" + \"280537122704246654319214528176074148240382783582971930101788834567416781139895\" + \"475044833931468963076339665722672704339321674542182455706252479721997866854279\" + \"897799233957905758189062252547358220523642485078340711014498047872669199018643\" + \"882293230538231855973286978092225352959101734140733488476100556401824239219269\" + \"506208318381454698392366461363989101210217709597670490830508185470419466437131\" + \"229969235889538493013635657618610606222870559942337163102127845744646398973818\" + \"856674626087948201864748767272722206267646533809980196688368099415907577685263\" + \"986514625333631245053640261056960551318381317426118442018908885319635698696279\" + \"503673842431301133175330532980201668881748134298868158557781034323175306478498\" + \"321062971842518438553442762012823457071698853051832617964117857960888815032960\" + \"229070561447622091509473903594664691623539680920139457817589108893199211226007\" + \"392814916948161527384273626429809823406320024402449589445612916704950823581248\" + \"739179964864113348032475777521970893277226234948601504665268143987705161531702\" + \"669692970492831628550421289814670619533197026950721437823047687528028735412616\" + \"639170824592517001071418085480063692325946201900227808740985977192180515853214\" + \"739265325155903541020928466592529991435379182531454529059841581763705892790690\" + \"989691116438118780943537152133226144362531449012745477269573939348154691631162\" + \"492887357471882407150399500944673195431619385548520766573882513963916357672315\" + \"100555603726339486720820780865373494244011579966750736071115935133195919712094\" + \"896471755302453136477094209463569698222667377520994516845064362382421185353488\" + \"798939567318780660610788544000550827657030558744854180577889171920788142335113\" + \"866292966717964346876007704799953788338787034871802184243734211227394025571769\" + \"081960309201824018842705704609262256417837526526335832424066125331152942345796\" + \"556950250681001831090041124537901533296615697052237921032570693705109083078947\" + \"999900499939532215362274847660361367769797856738658467093667958858378879562594\" + \"646489137665219958828693380183601193236857855855819555604215625088365020332202\" + \"451376215820461810670519533065306060650105488716724537794283133887163139559690\" + \"583208341689847606560711834713621812324622725884199028614208728495687963932546\" + \"428534307530110528571382964370999035694888528519040295604734613113826387889755\" + \"178856042499874831638280404684861893818959054203988987265069762020199554841265\" + \"000539442820393012748163815853039643992547020167275932857436666164411096256633\" + \"730540921951967514832873480895747777527834422109107311135182804603634719818565\" + \"557295714474768255285786334934285842311874944000322969069775831590385803935352\" + \"135886007960034209754739229673331064939560181223781285458431760556173386112673\" + \"478074585067606304822940965304111830667108189303110887172816751957967534718853\" + \"722930961614320400638132246584111115775835858113501856904781536893813771847281\" + \"475199835050478129771859908470762197460588742325699582889253504193795826061621\" + \"184236876851141831606831586799460165205774052942305360178031335726326705479033\" + \"840125730591233960188013782542192709476733719198728738524805742124892118347087\" + \"662966720727232565056512933312605950577772754247124164831283298207236175057467\" + \"387012820957554430596839555568686118839713552208445285264008125202766555767749\" + \"596962661260456524568408613923826576858338469849977872670655519185446869846947\" + \"849573462260629421962455708537127277652309895545019303773216664918257815467729\" + \"200521266714346320963789185232321501897612603437368406719419303774688099929687\" + \"758244104787812326625318184596045385354383911449677531286426092521153767325886\" + \"672260404252349108702695809964759580579466397341906401003636190404203311357933\" + \"654242630356145700901124480089002080147805660371015412232889146572239314507607\" + \"167064355682743774396578906797268743847307634645167756210309860409271709095128\" + \"086309029738504452718289274968921210667008164858339553773591913695015316201890\" + \"888748421079870689911480466927065094076204650277252865072890532854856143316081\" + \"269300569378541786109696920253886503457718317668688592368148847527649846882194\" + \"973972970773718718840041432312763650481453112285099002074240925585925292610302\" + \"106736815434701525234878635164397623586041919412969769040526483234700991115424\" + \"260127343802208933109668636789869497799400126016422760926082349304118064382913\" + \"834735467972539926233879158299848645927173405922562074910530853153718291168163\" + \"721939518870095778818158685046450769934394098743351443162633031724774748689791\" + \"820923948083314397084067308407958935810896656477585990556376952523265361442478\" + \"023082681183103773588708924061303133647737101162821461466167940409051861526036\" + \"009252194721889091810733587196414214447865489952858234394705007983038853886083\" + \"103571930600277119455802191194289992272235345870756624692617766317885514435021\" + \"828702668561066500353105021631820601760921798468493686316129372795187307897263\" + \"735371715025637873357977180818487845886650433582437700414771041493492743845758\" + \"710715973155943942641257027096512510811554824793940359768118811728247215825010\" + \"949609662539339538092219559191818855267806214992317276316321833989693807561685\" + \"591175299845013206712939240414459386239880938124045219148483164621014738918251\" + \"010909677386906640415897361047643650006807710565671848628149637111883219244566\" + \"394581449148616550049567698269030891118568798692947051352481609174324301538368\" + \"470729289898284602223730145265567989862776796809146979837826876431159883210904\" + \"371561129976652153963546442086919756737000573876497843768628768179249746943842\" + \"746525631632300555130417422734164645512781278457777245752038654375428282567141\" + \"288583454443513256205446424101103795546419058116862305964476958705407214198521\" + \"210673433241075676757581845699069304604752277016700568454396923404171108988899\" + \"341635058515788735343081552081177207188037910404698306957868547393765643363197\" + \"978680367187307969392423632144845035477631567025539006542311792015346497792906\" + \"624150832885839529054263768766896880503331722780018588506973623240389470047189\" + \"761934734430843744375992503417880797223585913424581314404984770173236169471976\" + \"571535319775499716278566311904691260918259124989036765417697990362375528652637\" + \"573376352696934435440047306719886890196814742876779086697968852250163694985673\" + \"021752313252926537589641517147955953878427849986645630287883196209983049451987\" + \"439636907068276265748581043911223261879405994155406327013198989570376110532360\" + \"629867480377915376751158304320849872092028092975264981256916342500052290887264\" + \"692528466610466539217148208013050229805263783642695973370705392278915351056888\" + \"393811324975707133102950443034671598944878684711643832805069250776627450012200\" + \"352620370946602341464899839025258883014867816219677519458316771876275720050543\" + \"979441245990077115205154619930509838698254284640725554092740313257163264079293\" + \"418334214709041254253352324802193227707535554679587163835875018159338717423606\" + \"155117101312352563348582036514614187004920570437201826173319471570086757853933\" + \"607862273955818579758725874410254207710547536129404746010009409544495966288148\" + \"691590389907186598056361713769222729076419775517772010427649694961105622059250\" + \"242021770426962215495872645398922769766031052498085575947163107587013320886146\" + \"326641259114863388122028444069416948826152957762532501987035987067438046982194\" + \"205638125583343642194923227593722128905642094308235254408411086454536940496927\" + \"149400331978286131818618881111840825786592875742638445005994422956858646048103\" + \"301538891149948693543603022181094346676400002236255057363129462629609619876056\" + \"425996394613869233083719626595473923462413459779574852464783798079569319865081\" + \"597767535055391899115133525229873611277918274854200868953965835942196333150286\" + \"956119201229888988700607999279541118826902307891310760361763477948943203210277\" + \"335941690865007193280401716384064498787175375678118532132840821657110754952829\" + \"497493621460821558320568723218557406516109627487437509809223021160998263303391\" + \"546949464449100451528092508974507489676032409076898365294065792019831526541065\" + \"813682379198409064571246894847020935776119313998024681340520039478194986620262\" + \"400890215016616381353838151503773502296607462795291038406868556907015751662419\" + \"298724448271942933100485482445458071889763300323252582158128032746796200281476\" + \"243182862217105435289834820827345168018613171959332471107466222850871066611770\" + \"346535283957762599774467218571581612641114327179434788599089280848669491413909\" + \"771673690027775850268664654056595039486784111079011610400857274456293842549416\" + \"759460548711723594642910585090995021495879311219613590831588262068233215615308\" + \"683373083817327932819698387508708348388046388478441884003184712697454370937329\" + \"836240287519792080232187874488287284372737801782700805878241074935751488997891\" + \"173974612932035108143270325140903048746226294234432757126008664250833318768865\" + \"075642927160552528954492153765175149219636718104943531785838345386525565664065\" + \"725136357506435323650893679043170259787817719031486796384082881020946149007971\" + \"513771709906195496964007086766710233004867263147551053723175711432231741141168\" + \"062286420638890621019235522354671166213749969326932173704310598722503945657492\" + \"461697826097025335947502091383667377289443869640002811034402608471289900074680\" + \"776484408871134135250336787731679770937277868216611786534423173226463784769787\" + \"514433209534000165069213054647689098505020301504488083426184520873053097318949\" + \"291642532293361243151430657826407028389840984160295030924189712097160164926561\" + \"341343342229882790992178604267981245728534580133826099587717811310216734025656\" + \"274400729683406619848067661580502169183372368039902793160642043681207990031626\" + \"444914619021945822969099212278855394878353830564686488165556229431567312827439\" + \"082645061162894280350166133669782405177015521962652272545585073864058529983037\" + \"918035043287670380925216790757120406123759632768567484507915114731344000183257\" + \"034492090971243580944790046249431345502890068064870429353403743603262582053579\" + \"011839564908935434510134296961754524957396062149028872893279252069653538639644\" + \"322538832752249960598697475988232991626354597332444516375533437749292899058117\" + \"578635555562693742691094711700216541171821975051983178713710605106379555858890\" + \"556885288798908475091576463907469361988150781468526213325247383765119299015610\" + \"918977792200870579339646382749068069876916819749236562422608715417610043060890\" + \"437797667851966189140414492527048088197149880154205778700652159400928977760133\" + \"075684796699295543365613984773806039436889588764605498387147896848280538470173\" + \"087111776115966350503997934386933911978988710915654170913308260764740630571141\" + \"109883938809548143782847452883836807941888434266622207043872288741394780101772\" + \"139228191199236540551639589347426395382482960903690028835932774585506080131798\" + \"840716244656399794827578365019551422155133928197822698427863839167971509126241\" + \"054872570092407004548848569295044811073808799654748156891393538094347455697212\" + \"891982717702076661360248958146811913361412125878389557735719498631721084439890\" + \"142394849665925173138817160266326193106536653504147307080441493916936326237376\" + \"777709585031325599009576273195730864804246770121232702053374266705314244820816\" + \"813030639737873664248367253983748769098060218278578621651273856351329014890350\" + \"988327061725893257536399397905572917516009761545904477169226580631511102803843\" + \"601737474215247608515209901615858231257159073342173657626714239047827958728150\" + \"509563309280266845893764964977023297364131906098274063353108979246424213458374\" + \"090116939196425045912881340349881063540088759682005440836438651661788055760895\" + \"689672753153808194207733259791727843762566118431989102500749182908647514979400\" + \"316070384554946538594602745244746681231468794344161099333890899263841184742525\" + \"704457251745932573898956518571657596148126602031079762825416559050604247911401\" + \"695790033835657486925280074302562341949828646791447632277400552946090394017753\" + \"633565547193100017543004750471914489984104001586794617924161001645471655133707\" + \"407395026044276953855383439755054887109978520540117516974758134492607943368954\" + \"378322117245068734423198987884412854206474280973562580706698310697993526069339\" + \"213568588139121480735472846322778490808700246777630360555123238665629517885371\" + \"967303463470122293958160679250915321748903084088651606111901149844341235012464\" + \"692802880599613428351188471544977127847336176628506216977871774382436256571177\" + \"945006447771837022199910669502165675764404499794076503799995484500271066598781\" + \"360380231412683690578319046079276529727769404361302305178708054651154246939526\" + \"512710105292707030667302444712597393995051462840476743136373997825918454117641\" + \"332790646063658415292701903027601733947486696034869497654175242930604072700505\" + \"903950314852292139257559484507886797792525393176515641619716844352436979444735\" + \"596426063339105512682606159572621703669850647328126672452198906054988028078288\" + \"142979633669674412480598219214633956574572210229867759974673812606936706913408\" + \"155941201611596019023775352555630060624798326124988128819293734347686268921923\" + \"977783391073310658825681377717232831532908252509273304785072497713944833389255\" + \"208117560845296659055394096556854170600117985729381399825831929367910039184409\" + \"928657560599359891000296986446097471471847010153128376263114677420914557404181\" + \"590880006494323785583930853082830547607679952435739163122188605754967383224319\" + \"565065546085288120190236364471270374863442172725787950342848631294491631847534\" + \"753143504139209610879605773098720135248407505763719925365047090858251393686346\" + \"386336804289176710760211115982887553994012007601394703366179371539630613986365\" + \"549221374159790511908358829009765664730073387931467891318146510931676157582135\" + \"142486044229244530411316065270097433008849903467540551864067734260358340960860\" + \"553374736276093565885310976099423834738222208729246449768456057956251676557408\" + \"841032173134562773585605235823638953203853402484227337163912397321599544082842\" + \"166663602329654569470357718487344203422770665383738750616921276801576618109542\" + \"009770836360436111059240911788954033802142652394892968643980892611463541457153\" + \"519434285072135345301831587562827573389826889852355779929572764522939156747756\" + \"667605108788764845349363606827805056462281359888587925994094644604170520447004\" + \"631513797543173718775603981596264750141090665886616218003826698996196558058720\" + \"863972117699521946678985701179833244060181157565807428418291061519391763005919\" + \"431443460515404771057005433900018245311773371895585760360718286050635647997900\" + \"413976180895536366960316219311325022385179167205518065926351803625121457592623\" + \"836934822266589557699466049193811248660909979812857182349400661555219611220720\" + \"309227764620099931524427358948871057662389469388944649509396033045434084210246\" + \"240104872332875008174917987554387938738143989423801176270083719605309438394006\" + \"375611645856094312951759771393539607432279248922126704580818331376416581826956\" + \"210587289244774003594700926866265965142205063007859200248829186083974373235384\" + \"908396432614700053242354064704208949921025040472678105908364400746638002087012\" + \"666420945718170294675227854007450855237772089058168391844659282941701828823301\" + \"497155423523591177481862859296760504820386434310877956289292540563894662194826\" + \"871104282816389397571175778691543016505860296521745958198887868040811032843273\" + \"986719862130620555985526603640504628215230615459447448990883908199973874745296\" + \"981077620148713400012253552224669540931521311533791579802697955571050850747387\" + \"475075806876537644578252443263804614304288923593485296105826938210349800040524\" + \"840708440356116781717051281337880570564345061611933042444079826037795119854869\" + \"455915205196009304127100727784930155503889536033826192934379708187432094991415\" + \"959339636811062755729527800425486306005452383915106899891357882001941178653568\" + \"214911852820785213012551851849371150342215954224451190020739353962740020811046\" + \"553020793286725474054365271759589350071633607632161472581540764205302004534018\" + \"357233829266191530835409512022632916505442612361919705161383935732669376015691\" + \"442994494374485680977569630312958871916112929468188493633864739274760122696415\" + \"884890096571708616059814720446742866420876533479985822209061980217321161423041\" + \"947775499073873856794118982466091309169177227420723336763503267834058630193019\" + \"324299639720444517928812285447821195353089891012534297552472763573022628138209\" + \"180743974867145359077863353016082155991131414420509144729353502223081719366350\" + \"934686585865631485557586244781862010871188976065296989926932817870557643514338\" + \"206014107732926106343152533718224338526352021773544071528189813769875515757454\" + \"693972715048846979361950047772097056179391382898984532742622728864710888327017\" + \"372325881824465843624958059256033810521560620615571329915608489206434030339526\" + \"226345145428367869828807425142256745180618414956468611163540497189768215422772\" + \"247947403357152743681940989205011365340012384671429655186734415374161504256325\" + \"671343024765512521921803578016924032669954174608759240920700466934039651017813\" + \"485783569444076047023254075555776472845075182689041829396611331016013111907739\" + \"863246277821902365066037404160672496249013743321724645409741299557052914243820\" + \"807609836482346597388669134991978401310801558134397919485283043673901248208244\" + \"481412809544377389832005986490915950532285791457688496257866588599917986752055\" + \"455809900455646117875524937012455321717019428288461740273664997847550829422802\" + \"023290122163010230977215156944642790980219082668986883426307160920791408519769\" + \"523555348865774342527753119724743087304361951139611908003025587838764420608504\" + \"473063129927788894272918972716989057592524467966018970748296094919064876469370\" + \"275077386643239191904225429023531892337729316673608699622803255718530891928440\" + \"380507103006477684786324319100022392978525537237556621364474009676053943983823\" + \"576460699246526008909062410590421545392790441152958034533450025624410100635953\" + \"003959886446616959562635187806068851372346270799732723313469397145628554261546\" + \"765063246567662027924520858134771760852169134094652030767339184114750414016892\" + \"412131982688156866456148538028753933116023229255561894104299533564009578649534\" + \"093511526645402441877594931693056044868642086275720117231952640502309977456764\" + \"783848897346431721598062678767183800524769688408498918508614900343240347674268\" + \"624595239589035858213500645099817824463608731775437885967767291952611121385919\" + \"472545140030118050343787527766440276261894101757687268042817662386068047788524\" + \"288743025914524707395054652513533945959878961977891104189029294381856720507096\" + \"460626354173294464957661265195349570186001541262396228641389779673332907056737\" + \"696215649818450684226369036784955597002607986799626101903933126376855696876702\" + \"929537116252800554310078640872893922571451248113577862766490242516199027747109\" + \"033593330930494838059785662884478744146984149906712376478958226329490467981208\" + \"998485716357108783119184863025450162092980582920833481363840542172005612198935\" + \"366937133673339246441612522319694347120641737549121635700857369439730597970971\" + \"972666664226743111776217640306868131035189911227133972403688700099686292254646\" + \"500638528862039380050477827691283560337254825579391298525150682996910775425764\" + \"748832534141213280062671709400909822352965795799780301828242849022147074811112\" + \"401860761341515038756983091865278065889668236252393784527263453042041880250844\" + \"236319038331838455052236799235775292910692504326144695010986108889991465855188\" + \"187358252816430252093928525807796973762084563748211443398816271003170315133440\" + \"230952635192958868069082135585368016100021374085115448491268584126869589917414\" + \"913382057849280069825519574020181810564129725083607035685105533178784082900004\" + \"155251186577945396331753853209214972052660783126028196116485809868458752512999\" + \"740409279768317663991465538610893758795221497173172813151793290443112181587102\" + \"351874075722210012376872194474720934931232410706508061856237252673254073332487\" + \"575448296757345001932190219911996079798937338367324257610393898534927877747398\" + \"050808001554476406105352220232540944356771879456543040673589649101761077594836\" + \"454082348613025471847648518957583667439979150851285802060782055446299172320202\" + \"822291488695939972997429747115537185892423849385585859540743810488262464878805\" + \"330427146301194158989632879267832732245610385219701113046658710050008328517731\" + \"177648973523092666123458887310288351562644602367199664455472760831011878838915\" + \"114934093934475007302585581475619088139875235781233134227986650352272536717123\" + \"075686104500454897036007956982762639234410714658489578024140815840522953693749\" + \"971066559489445924628661996355635065262340533943914211127181069105229002465742\" + \"360413009369188925586578466846121567955425660541600507127664176605687427420032\" + \"957716064344860620123982169827172319782681662824993871499544913730205184366907\" + \"672357740005393266262276032365975171892590180110429038427418550789488743883270\" + \"306328327996300720069801224436511639408692222074532024462412115580435454206421\" + \"512158505689615735641431306888344318528085397592773443365538418834030351782294\" + \"625370201578215737326552318576355409895403323638231921989217117744946940367829\" + \"618592080340386757583411151882417743914507736638407188048935825686854201164503\" + \"135763335550944031923672034865101056104987272647213198654343545040913185951314\" + \"518127643731043897250700498198705217627249406521461995923214231443977654670835\" + \"171474936798618655279171582408065106379950018429593879915835017158075988378496\" + \"225739851212981032637937621832245659423668537679911314010804313973233544909082\" + \"491049914332584329882103398469814171575601082970658306521134707680368069532297\" + \"199059990445120908727577622535104090239288877942463048328031913271049547859918\" + \"019696783532146444118926063152661816744319355081708187547705080265402529410921\" + \"826485821385752668815558411319856002213515888721036569608751506318753300294211\" + \"868222189377554602722729129050429225978771066787384000061677215463844129237119\" + \"352182849982435092089180168557279815642185819119749098573057033266764646072875\" + \"743056537260276898237325974508447964954564803077159815395582777913937360171742\" + \"299602735310276871944944491793978514463159731443535185049141394155732938204854\" + \"212350817391254974981930871439661513294204591938010623142177419918406018034794\" + \"988769105155790555480695387854006645337598186284641990522045280330626369562649\" + \"091082762711590385699505124652999606285544383833032763859980079292284665950355\" + \"121124528408751622906026201185777531374794936205549640107300134885315073548735\" + \"390560290893352640071327473262196031177343394367338575912450814933573691166454\" + \"128178817145402305475066713651825828489809951213919399563324133655677709800308\" + \"191027204099714868741813466700609405102146269028044915964654533010775469541308\" + \"871416531254481306119240782118869005602778182423502269618934435254763357353648\" + \"561936325441775661398170393063287216690572225974520919291726219984440964615826\" + \"945638023950283712168644656178523556516412771282691868861557271620147493405227\" + \"694659571219831494338162211400693630743044417328478610177774383797703723179525\" + \"543410722344551255558999864618387676490397246116795901810003509892864120419516\" + \"355110876320426761297982652942588295114127584126273279079880755975185157684126\" + \"474220947972184330935297266521001566251455299474512763155091763673025946213293\" + \"019040283795424632325855030109670692272022707486341900543830265068121414213505\" + \"715417505750863990767394633514620908288893493837643939925690060406731142209331\" + \"219593620298297235116325938677224147791162957278075239505625158160313335938231\" + \"150051862689053065836812998810866326327198061127154885879809348791291370749823\" + \"057592909186293919501472119758606727009254771802575033773079939713453953264619\" + \"526999659638565491759045833358579910201271320458390320085387888163363768518208\" + \"372788513117522776960978796214237216254521459128183179821604411131167140691482\" + \"717098101545778193920231156387195080502467972579249760577262591332855972637121\" + \"120190572077140914864507409492671803581515757151405039761096384675556929897038\" + \"354731410022380258346876735012977541327953206097115450648421218593649099791776\" + \"687477448188287063231551586503289816422828823274686610659273219790716238464215\" + \"348985247621678905026099804526648392954235728734397768049577409144953839157556\" + \"548545905897649519851380100795801078375994577529919670054760225255203445398871\" + \"253878017196071816407812484784725791240782454436168234523957068951427226975043\" + \"187363326301110305342333582160933319121880660826834142891041517324721605335584\" + \"999322454873077882290525232423486153152097693846104258284971496347534183756200\" + \"301491570327968530186863157248840152663983568956363465743532178349319982554211\" + \"730846774529708583950761645822963032442432823773745051702856069806788952176819\" + \"815671078163340526675953942492628075696832610749532339053622309080708145591983\" + \"735537774874202903901814293731152933464446815121294509759653430628421531944572\" + \"711861490001765055817709530246887526325011970520947615941676872778447200019278\" + \"913725184162285778379228443908430118112149636642465903363419454065718354477191\" + \"244662125939265662030688852005559912123536371822692253178145879259375044144893\" + \"398160865790087616502463519704582889548179375668104647461410514249887025213993\" + \"687050937230544773411264135489280684105910771667782123833281026218558775131272\" + \"117934444820144042574508306394473836379390628300897330624138061458941422769474\" + \"793166571762318247216835067807648757342049155762821758397297513447899069658953\" + \"254894033561561316740327647246921250575911625152965456854463349811431767025729\" + \"566184477548746937846423373723898192066204851189437886822480727935202250179654\" + \"534375727416391079197295295081294292220534771730418447791567399173841831171036\" + \"252439571615271466900581470000263301045264354786590329073320546833887207873544\" + \"476264792529769017091200787418373673508771337697768349634425241994995138831507\" + \"487753743384945825976556099655595431804092017849718468549737069621208852437701\" + \"385375768141663272241263442398215294164537800049250726276515078908507126599703\" + \"670872669276430837722968598516912230503746274431085293430527307886528397733524\" + \"601746352770320593817912539691562106363762588293757137384075440646896478310070\" + \"458061344673127159119460843593582598778283526653115106504162329532904777217408\" + \"355934972375855213804830509000964667608830154061282430874064559443185341375522\" + \"016630581211103345312074508682433943215904359443031243122747138584203039010607\" + \"094031523555617276799416002039397509989762933532585557562480899669182986422267\" + \"750236019325797472674257821111973470940235745722227121252685238429587427350156\" + \"366009318804549333898974157149054418255973808087156528143010267046028431681923\" + \"039253529779576586241439270154974087927313105163611913757700892956482332364829\" + \"826302460797587576774537716010249080462430185652416175665560016085912153455626\" + \"760219268998285537787258314514408265458348440947846317877737479465358016996077\" + \"940556870119232860804113090462935087182712593466871276669487389982459852778649\" + \"956916546402945893506496433580982476596516514209098675520380830920323048734270\" + \"346828875160407154665383461961122301375945157925269674364253192739003603860823\" + \"645076269882749761872357547676288995075211480485252795084503395857083813047693\" + \"788132112367428131948795022806632017002246033198967197064916374117585485187848\" + \"401205484467258885140156272501982171906696081262778548596481836962141072171421\" + \"498636191877475450965030895709947093433785698167446582826791194061195603784539\" + \"785583924076127634410576675102430755981455278616781594965706255975507430652108\" + \"530159790807334373607943286675789053348366955548680391343372015649883422089339\" + \"997164147974693869690548008919306713805717150585730714881564992071408675825960\" + \"287605645978242377024246980532805663278704192676846711626687946348695046450742\" + \"021937394525926266861355294062478136120620263649819999949840514386828525895634\" + \"226432870766329930489172340072547176418868535137233266787792173834754148002280\" + \"339299735793615241275582956927683723123479898944627433045456679006203242051639\" + \"628258844308543830720149567210646053323853720314324211260742448584509458049408\" + \"182092763914000854042202355626021856434899414543995041098059181794888262805206\" + \"644108631900168856815516922948620301073889718100770929059048074909242714101893\" + \"354281842999598816966099383696164438152887721408526808875748829325873580990567\" + \"075581701794916190611400190855374488272620093668560447559655747648567400817738\" + \"170330738030547697360978654385938218722058390234444350886749986650604064587434\" + \"600533182743629617786251808189314436325120510709469081358644051922951293245007\" + \"883339878842933934243512634336520438581291283434529730865290978330067126179813\" + \"031679438553572629699874035957045845223085639009891317947594875212639707837594\" + \"486113945196028675121056163897600888009274611586080020780334159145179707303683\" + \"519697776607637378533301202412011204698860920933908536577322239241244905153278\" + \"095095586645947763448226998607481329730263097502881210351772312446509534965369\" + \"309001863776409409434983731325132186208021480992268550294845466181471555744470\" + \"966953017769043427203189277060471778452793916047228153437980353967986142437095\" + \"668322149146543801459382927739339603275404800955223181666738035718393275707714\" + \"204672383862461780397629237713120958078936384144792980258806552212926209362393\" + \"063731349664018661951081158347117331202580586672763999276357907806381881306915\" + \"636627412543125958993611964762610140556350339952314032311381965623632719896183\" + \"725484533370206256346422395276694356837676136871196292181875457608161705303159\" + \"072882870071231366630872275491866139577373054606599743781098764980241401124214\" + \"277366808275139095931340415582626678951084677611866595766016599817808941498575\" + \"497628438785610026379654317831363402513581416115190209649913354873313111502270\" + \"068193013592959597164019719605362503355847998096348871803911161281359596856547\" + \"886832585643789617315976200241962155289629790481982219946226948713746244472909\" + \"345647002853769495885959160678928249105441251599630078136836749020937491573289\" + \"627002865682934443134234735123929825916673950342599586897069726733258273590312\" + \"128874666045146148785034614282776599160809039865257571726308183349444182019353\" + \"338507129234577437557934406217871133006310600332405399169368260374617663856575\" + \"887758020122936635327026710068126182517291460820254189288593524449107013820621\" + \"155382779356529691457650204864328286555793470720963480737269214118689546732276\" + \"775133569019015372366903686538916129168888787640752549349424973342718117889275\" + \"993159671935475898809792452526236365903632007085444078454479734829180208204492\" + \"667063442043755532505052752283377888704080403353192340768563010934777212563908\" + \"864041310107381785333831603813528082811904083256440184205374679299262203769871\" + \"801806112262449090924264198582086175117711378905160914038157500336642415609521\" + \"632819712233502316742260056794128140621721964184270578432895980288233505982820\" + \"819666624903585778994033315227481777695284368163008853176969478369058067106482\" + \"808359804669884109813515865490693331952239436328792399053481098783027450017206\" + \"543369906611778455436468772363184446476806914282800455107468664539280539940910\" + \"875493916609573161971503316696830992946634914279878084225722069714887558063748\" + \"030886299511847318712477729191007022758889348693945628951580296537215040960310\" + \"776128983126358996489341024703603664505868728758905140684123812424738638542790\" + \"828273382797332688550493587430316027474906312957234974261122151741715313361862\" + \"241091386950068883589896234927631731647834007746088665559873338211382992877691\" + \"149549218419208777160606847287467368188616750722101726110383067178785669481294\" + \"878504894306308616994879870316051588410828235127415353851336589533294862949449\" + \"506186851477910580469603906937266267038651290520113781085861618888694795760741\" + \"358553458515176805197333443349523012039577073962377131603024288720053732099825\" + \"300897761897312981788194467173116064723147624845755192873278282512718244680782\" + \"421521646956781929409823892628494376024885227900362021938669648221562809360537\" + \"317804086372726842669642192994681921490870170753336109479138180406328738759384\" + \"826953558307739576144799727000347288018278528138950321798634521611106660883931\" + \"405322694490545552786789441757920244002145078019209980446138254780585804844241\" + \"640477503153605490659143007815837243012313751156228401583864427089071828481675\" + \"752712384678245953433444962201009607105137060846180118754312072549133499424761\" + \"711563332140893460915656155060031738421870157022610310191660388706466143889773\" + \"631878094071152752817468957640158104701696524755774089164456867771715850058326\" + \"994340167720215676772406812836656526412298243946513319735919970940327593850266\" + \"955747023181320324371642058614103360652453693916005064495306016126782264894243\" + \"739716671766123104897503188573216555498834212180284691252908610148552781527762\" + \"562375045637576949773433684601560772703550962904939248708840628106794362241870\" + \"474700836884267102255830240359984164595112248527263363264511401739524808619463\" + \"584078375355688562231711552094722306543709260679735100056554938122457548372854\" + \"571179739361575616764169289580525729752233855861138832217110736226581621884244\" + \"317885748879810902665379342666421699091405653643224930133486798815488662866505\" + \"234699723557473842483059042367714327879231642240387776433019260019228477831383\" + \"763253612102533693581262408686669973827597736568222790721583247888864236934639\" + \"616436330873013981421143030600873066616480367898409133592629340230432497492688\" + \"783164360268101130957071614191283068657732353263965367739031766136131596555358\" + \"499939860056515592193675997771793301974468814837110320650369319289452140265091\" + \"546518430993655349333718342529843367991593941746622390038952767381333061774762\" + \"957494386871697845376721949350659087571191772087547710718993796089477451265475\" + \"750187119487073873678589020061737332107569330221632062843206567119209695058576\" + \"117396163232621770894542621460985841023781321581772760222273813349541048100307\" + \"327510779994899197796388353073444345753297591426376840544226478421606312276964\" + \"696715647399904371590332390656072664411643860540483884716191210900870101913072\" + \"607104411414324197679682854788552477947648180295973604943970047959604029274629\" + \"920357209976195014034831538094771460105633344699882082212058728151072918297121\" + \"191787642488035467231691654185225672923442918712816323259696541354858957713320\" + \"833991128877591722611527337901034136208561457799239877832508355073019981845902\" + \"595835598926055329967377049172245493532968330000223018151722657578752405883224\" + \"908582128008974790932610076257877042865600699617621217684547899644070506624171\" + \"021332748679623743022915535820078014116534806564748823061500339206898379476625\" + \"503654982280532966286211793062843017049240230198571997894883689718304380518217\" + \"441914766042975243725168343541121703863137941142209529588579806015293875275379\" + \"903093887168357209576071522190027937929278630363726876582268124199338480816602\" + \"160372215471014300737753779269906958712128928801905203160128586182549441335382\" + \"078488346531163265040764242839087012101519423196165226842200371123046430067344\" + \"206474771802135307012409886035339915266792387110170622186588357378121093517977\" + \"560442563469499978725112544085452227481091487430725986960204027594117894258128\" + \"188215995235965897918114407765335432175759525553615812800116384672031934650729\" + \"680799079396371496177431211940202129757312516525376801735910155733815377200195\" + \"244454362007184847566341540744232862106099761324348754884743453966598133871746\" + \"609302053507027195298394327142537115576660002578442303107342955153394506048622\" + \"276496668762407932435319299263925373107689213535257232108088981933916866827894\" + \"828117047262450194840970097576092098372409007471797334078814182519584259809624\" + \"174761013825264395513525931188504563626418830033853965243599741693132289471987\" + \"830842760040136807470390409723847394583489618653979059411859931035616843686921\" + \"948538205578039577388136067954990008512325944252972448666676683464140218991594\" + \"456530942344065066785194841776677947047204195882204329538032631053749488312218\" + \"039127967844610013972675389219511911783658766252808369005324900459741094706877\" + \"291232821430463533728351995364827432583311914445901780960778288358373011185754\" + \"365995898272453192531058811502630754257149394302445393187017992360816661130542\" + \"625399583389794297160207033876781503301028012009599725222228080142357109476035\" + \"192554443492998676781789104555906301595380976187592035893734197896235893112598\" + \"390259831026719330418921510968915622506965911982832345550305908173073519550372\" + \"166587028805399213857603703537710517802128012956684198414036287272562321442875\" + \"430221090947272107347413497551419073704331827662617727599688882602722524713368\" + \"335345281669277959132886138176634985772893690096574956228710302436259077241221\" + \"909430087175569262575806570991201665962243608024287002454736203639484125595488\" + \"172727247365346778364720191830399871762703751572464992228946793232269361917764\" + \"161461879561395669956778306829031658969943076733350823499079062410020250613405\" + \"734430069574547468217569044165154063658468046369262127421107539904218871612761\" + \"778701425886482577522388918459952337629237791558574454947736129552595222657863\" + \"646211837759847370034797140820699414558071908021359073226923310083175951065901\" + \"912129479540860364075735875020589020870457967000705526250581142066390745921527\" + \"330940682364944159089100922029668052332526619891131184201629163107689408472356\" + \"436680818216865721968826835840278550078280404345371018365109695178233574303050\" + \"485265373807353107418591770561039739506264035544227515610110726177937063472380\" + \"499066692216197119425912044508464174638358993823994651739550900085947999013602\" + \"667426149429006646711506717542217703877450767356374215478290591101261915755587\" + \"023895700140511782264698994491790830179547587676016809410013583761357859135692\" + \"445564776446417866711539195135769610486492249008344671548638305447791433009768\" + \"048687834818467273375843689272431044740680768527862558516509208826381323362314\" + \"873333671476452045087662761495038994950480956046098960432912335834885999029452\" + \"640028499428087862403981181488476730121675416110662999555366819312328742570206\" + \"373835202008686369131173346973174121915363324674532563087134730279217495622701\" + \"468732586789173455837996435135880095935087755635624881049385299900767513551352\" + \"779241242927748856588856651324730251471021057535251651181485090275047684551825\" + \"209633189906852761443513821366215236889057878669943228881602837748203550601602\" + \"989400911971385017987168363374413927597364401700701476370665570350433812111357\" + \"641501845182141361982349515960106475271257593518530433287553778305750956742544\" + \"268471221961870917856078393614451138333564910325640573389866717812397223751931\" + \"643061701385953947436784339267098671245221118969084023632741149660124348309892\" + \"994173803058841716661307304006758838043211155537944060549772170594282151488616\" + \"567277124090338772774562909711013488518437411869565544974573684521806698291104\" + \"505800429988795389902780438359628240942186055628778842880212755388480372864001\" + \"944161425749990427200959520465417059810498996750451193647117277222043610261407\" + \"975080968697517660023718774834801612031023468056711264476612374762785219024120\" + \"256994353471622666089367521983311181351114650385489502512065577263614547360442\" + \"685949807439693233129712737715734709971395229118265348515558713733662912024271\" + \"430250376326950135091161295299378586468130722648600827088133353819370368259886\" + \"789332123832705329762585738279009782646054559855513183668884462826513379849166\" + \"783940976135376625179825824966345877195012438404035914084920973375464247448817\" + \"618407002356958017741017769692507781489338667255789856458985105689196092439884\" + \"156928069698335224022563457049731224526935419383700484318335719651662672157552\" + \"419340193309901831930919658292096965624766768365964701959575473934551433741370\" + \"876151732367720422738567427917069820454995309591887243493952409444167899884631\" + \"984550485239366297207977745281439941825678945779571255242682608994086331737153\" + \"889626288962940211210888442737656862452761213037101730078513571540453304150795\" + \"944777614359743780374243664697324713841049212431413890357909241603640631403814\" + \"983148190525172093710396402680899483257229795456404270175772290417323479607361\" + \"878788991331830584306939482596131871381642346721873084513387721908697510494284\" + \"376932502498165667381626061594176825250999374167288395174406693254965340310145\" + \"222531618900923537648637848288134420987004809622717122640748957193900291857330\" + \"746010436072919094576799461492929042798168772942648772995285843464777538690695\" + \"014898413392454039414468026362540211861431703125111757764282991464453340892097\" + \"696169909837265236176874560589470496817013697490952307208268288789073019001825\" + \"342580534342170592871393173799314241085264739094828459641809361413847583113613\" + \"057610846236683723769591349261582451622155213487924414504175684806412063652017\" + \"038633012953277769902311864802006755690568229501635493199230591424639621702532\" + \"974757311409422018019936803502649563695586642590676268568737211033915679383989\" + \"576556519317788300024161353956243777784080174881937309502069990089089932808839\" + \"743036773659552489130015663329407790713961546453408879151030065132193448667324\" + \"827590794680787981942501958262232039513125201410996053126069655540424867054998\" + \"678692302174698900954785072567297879476988883109348746442640071818316033165551\" + \"153427615562240547447337804924621495213325852769884733626918264917433898782478\" + \"927846891882805466998230368993978341374758702580571634941356843392939606819206\" + \"177333179173820856243643363535986349449689078106401967407443658366707158692452\" + \"118299789380407713750129085864657890577142683358276897855471768718442772612050\" + \"926648610205153564284063236848180728794071712796682006072755955590404023317874\" + \"944734645476062818954151213916291844429765106694796935401686601005519607768733\" + \"539651161493093757096855455938151378956903925101495326562814701199832699220006\" + \"639287537471313523642158926512620407288771657835840521964605410543544364216656\" + \"224456504299901025658692727914275293117208279393775132610605288123537345106837\" + \"293989358087124386938593438917571337630072031976081660446468393772580690923729\" + \"752348670291691042636926209019960520412102407764819031601408586355842760953708\" + \"655816427399534934654631450404019952853725200495780525465625115410925243799132\" + \"626271360909940290226206283675213230506518393405745011209934146491843332364656\" + \"937172591448932415900624202061288573292613359680872650004562828455757459659212\" + \"053034131011182750130696150983551563200431078460190656549380654252522916199181\" + \"995960275232770224985573882489988270746593635576858256051806896428537685077201\" + \"222034792099393617926820659014216561592530673794456894907085326356819683186177\" + \"226824991147261573203580764629811624401331673789278868922903259334986179702199\" + \"498192573961767307583441709855922217017182571277753449150820527843090461946083\" + \"521740200583867284970941102326695392144546106621500641067474020700918991195137\" + \"646690448126725369153716229079138540393756007783515337416774794210038400230895\" + \"185099454877903934612222086506016050035177626483161115332558770507354127924990\" + \"985937347378708119425305512143697974991495186053592040383023571635272763087469\" + \"321962219006426088618367610334600225547747781364101269190656968649501268837629\" + \"690723396127628722304114181361006026404403003599698891994582739762411461374480\" + \"405969706257676472376606554161857469052722923822827518679915698339074767114610\" + \"302277660602006124687647772881909679161335401988140275799217416767879923160396\" + \"356949285151363364721954061117176738737255572852294005436178517650230754469386\" + \"930787349911035218253292972604455321079788771144989887091151123725060423875373\" + \"484125708606406905205845212275453384800820530245045651766951857691320004281675\" + \"805492481178051983264603244579282973012910531838563682120621553128866856495651\" + \"261389226136706409395333457052698695969235035309422454386527867767302754040270\" + \"224638448355323991475136344104405009233036127149608135549053153902100229959575\" + \"658370538126196568314428605795669662215472169562087001372776853696084070483332\" + \"513279311223250714863020695124539500373572334680709465648308920980153487870563\" + \"349109236605755405086411152144148143463043727327104502776866195310785832333485\" + \"784029716092521532609255893265560067212435946425506599677177038844539618163287\" + \"961446081778927217183690888012677820743010642252463480745430047649288555340906\" + \"218515365435547412547615276977266776977277705831580141218568801170502836527554\" + \"321480348800444297999806215790456416195721278450892848980642649742709057912906\" + \"921780729876947797511244730599140605062994689428093103421641662993561482813099\" + \"887074529271604843363081840412646963792584309418544221635908457614607855856247\" + \"381493142707826621518554160387020687698046174740080832434366538235455510944949\" + \"843109349475994467267366535251766270677219418319197719637801570216993367508376\" + \"005716345464367177672338758864340564487156696432104128259564534984138841289042\" + \"068204700761559691684303899934836679354254921032811336318472259230555438305820\" + \"694167562999201337317548912203723034907268106853445403599356182357631283776764\" + \"063101312533521214199461186935083317658785204711236433122676512996417132521751\" + \"355326186768194233879036546890800182713528358488844411176123410117991870923650\" + \"718485785622102110400977699445312179502247957806950653296594038398736990724079\" + \"767904082679400761872954783596349279390457697366164340535979221928587057495748\" + \"169669406233427261973351813662606373598257555249650980726012366828360592834185\" + \"584802695841377255897088378994291054980033111388460340193916612218669605849157\" + \"148573356828614950001909759112521880039641976216355937574371801148055944229873\" + \"041819680808564726571354761283162920044988031540210553059707666636274932830891\" + \"688093235929008178741198573831719261672883491840242972129043496552694272640255\" + \"964146352591434840067586769035038232057293413298159353304444649682944136732344\" + \"215838076169483121933311981906109614295220153617029857510559432646146850545268\" + \"497576480780800922133581137819774927176854507553832876887447459159373116247060\" + \"109124460982942484128752022446259447763874949199784044682925736096853454984326\" + \"653686284448936570411181779380644161653122360021491876876946739840751717630751\" + \"684985635920148689294310594020245796962292456664488196757629434953532638217161\" + \"339575779076637076456957025973880043841580589433613710655185998760075492418721\" + \"171488929522173772114608115434498266547987258005667472405112200738345927157572\" + \"771521858994694811794064446639943237004429114074721818022482583773601734668530\" + \"074498556471542003612359339731291445859152288740871950870863221883728826282288\" + \"463184371726190330577714765156414382230679184738603914768310814135827575585364\" + \"359772165002827780371342286968878734979509603110889919614338666406845069742078\" + \"770028050936720338723262963785603865321643234881555755701846908907464787912243\" + \"637555666867806761054495501726079114293083128576125448194444947324481909379536\" + \"900820638463167822506480953181040657025432760438570350592281891987806586541218\" + \"429921727372095510324225107971807783304260908679427342895573555925272380551144\" + \"043800123904168771644518022649168164192740110645162243110170005669112173318942\" + \"340054795968466980429801736257040673328212996215368488140410219446342464622074\" + \"557564396045298531307140908460849965376780379320189914086581466217531933766597\" + \"011433060862500982956691763884605676297293146491149370462446935198403953444913\" + \"514119366793330193661766365255514917498230798707228086085962611266050428929696\" + \"653565251668888557211227680277274370891738963977225756489053340103885593112567\" + \"999151658902501648696142720700591605616615970245198905183296927893555030393468\" + \"121976158218398048396056252309146263844738629603984892438618729850777592879272\" + \"206855480721049781765328621018747676689724884113956034948037672703631692100735\" + \"083407386526168450748249644859742813493648037242611670426687083192504099761531\" + \"907685577032742178501000644198412420739640013960360158381056592841368457411910\" + \"273642027416372348821452410134771652960312840865841978795111651152982781462037\" + \"913985500639996032659124852530849369031313010079997719136223086601109992914287\" + \"124938854161203802041134018888721969347790449752745428807280350930582875442075\" + \"513481666092787935356652125562013998824962847872621443236285367650259145046837\" + \"763528258765213915648097214192967554938437558260025316853635673137926247587804\" + \"944594418342917275698837622626184636545274349766241113845130548144983631178978\" + \"448973207671950878415861887969295581973325069995140260151167552975057543781024\" + \"223895792578656212843273120220071673057406928686936393018676595825132649914595\" + \"026091706934751940897535746401683081179884645247361895605647942635807056256328\" + \"118926966302647953595109712765913623318086692153578860781275991053717140220450\" + \"618607537486630635059148391646765672320571451688617079098469593223672494673758\" + \"309960704258922048155079913275208858378111768521426933478692189524062265792104\" + \"362034885292626798401395321645879115157905046057971083898337186403802441751134\" + \"722647254701079479399695355466961972676325522991465493349966323418595145036098\" + \"034409221220671256769872342794070885707047429317332918852389672197135392449242\" + \"617864118863779096281448691786946817759171715066911148002075943201206196963779\" + \"510322708902956608556222545260261046073613136886900928172106819861855378098201\" + \"847115416363032626569928342415502360097804641710852553761272890533504550613568\" + \"414377585442967797701466029438768722511536380119175815402812081825560648541078\" + \"793359892106442724489861896162941341800129513068363860929410008313667337215300\" + \"835269623573717533073865333820484219030818644918409372394403340524490955455801\" + \"640646076158101030176748847501766190869294609876920169120218168829104087070956\" + \"095147041692114702741339005225334083481287035303102391969997859741390859360543\" + \"359969707560446013424245368249609877258131102473279856207212657249900346829388\" + \"687230489556225320446360263985422525841646432427161141981780248259556354490721\" + \"922658386366266375083594431487763515614571074552801615967704844271419443518327\" + \"569840755267792641126176525061596523545718795667317091331935876162825592078308\" + \"018520689015150471334038610031005591481785211038475454293338918844412051794396\" + \"997019411269511952656491959418997541839323464742429070271887522353439367363366\" + \"320030723274703740712398256202466265197409019976245205619855762576000870817308\" + \"328834438183107005451449354588542267857855191537229237955549433341017442016960\" + \"009069641561273229777022121795186837635908225512881647002199234886404395915301\" + \"846400471432118636062252701154112228380277853891109849020134274101412155976996\" + \"543887719748537643115822983853312307175113296190455900793806427669581901484262\" + \"799122179294798734890186847167650382732855205908298452980625925035212845192592\" + \"798659350613296194679625237397256558415785374456755899803240549218696288849033\" + \"256085145534439166022625777551291620077279685262938793753045418108072928589198\" + \"971538179734349618723292761474785019261145041327487324297058340847111233374627\" + \"461727462658241532427105932250625530231473875925172478732288149145591560503633\" + \"457542423377916037495250249302235148196138116256391141561032684495807250827343\" + \"176594405409826976526934457986347970974312449827193311386387315963636121862349\" + \"726140955607992062831699942007205481152535339394607685001990988655386143349578\" + \"165008996164907967814290114838764568217491407562376761845377514403147541120676\" + \"016072646055685925779932207033733339891636950434669069482843662998003741452762\" + \"771654762382554617088318981086880684785370553648046935095881802536052974079353\" + \"867651119507937328208314626896007107517552061443378411454995013643244632819334\" + \"638905093654571450690086448344018042836339051357815727397333453728426337217406\" + \"577577107983051755572103679597690188995849413019599957301790124019390868135658\" + \"553966194137179448763207986880037160730322054742357226689680188212342439188598\" + \"416897227765219403249322731479366923400484897605903795809469604175427961378255\" + \"378122394764614783292697654516229028170110043784603875654415173943396004891531\" + \"881757665050095169740241564477129365661425394936888423051740012992055685428985\" + \"389794266995677702708914651373689220610441548166215680421983847673087178759027\" + \"920917590069527345668202651337311151800018143412096260165862982107666352336177\" + \"400783778342370915264406305407180784335806107296110555002041513169637304684921\" + \"335683726540030750982908936461204789111475303704989395283345782408281738644132\" + \"271000296831194020332345642082647327623383029463937899837583655455991934086623\" + \"509096796113400486702712317652666371077872511186035403755448741869351973365662\" + \"177235922939677646325156202348757011379571209623772343137021203100496515211197\" + \"601317641940820343734851285260291333491512508311980285017785571072537314913921\" + \"570910513096505988599993156086365547740355189816673353588004821466509974143376\" + \"118277772335191074121757284159258087259131507460602563490377726337391446137703\" + \"802131834744730111303267029691733504770163210661622783002726928336558401179141\" + \"944780874825336071440329625228577500980859960904093631263562132816207145340610\" + \"422411208301000858726425211226248014264751942618432585338675387405474349107271\" + \"004975428115946601713612259044015899160022982780179603519408004651353475269877\" + \"760952783998436808690898919783969353217998013913544255271791022539701081063214\" + \"304851137829149851138196914304349750018998068164441212327332830719282436240673\" + \"319655469267785119315277511344646890550424811336143498460484905125834568326644\" + \"152848971397237604032821266025351669391408204994732048602162775979177123475109\" + \"750240307893575993771509502175169355582707253391189233407022383207758580213717\" + \"477837877839101523413209848942345961369234049799827930414446316270721479611745\" + \"697571968123929191374098292580556195520743424329598289898052923336641541925636\" + \"738068949420147124134052507220406179435525255522500874879008656831454283516775\" + \"054229480327478304405643858159195266675828292970522612762871104013480178722480\" + \"178968405240792436058274246744307672164527031345135416764966890127478680101029\" + \"513386269864974821211862904033769156857624069929637249309720162870720018983542\" + \"369036414927023696193854737248032985504511208919287982987446786412915941753167\" + \"560253343531062674525450711418148323988060729714023472552071349079839898235526\" + \"872395090936566787899238371257897624875599044322889538837731734894112275707141\" + \"095979004791930104674075041143538178246463079598955563899188477378134134707024\" + \"674736211204898622699188851745625173251934135203811586335012391305444191007362\" + \"844756751416105041097350585276204448919097890198431548528053398577784431393388\" + \"399431044446566924455088594631408175122033139068159659251054685801313383815217\" + \"641821043342978882611963044311138879625874609022613090084997543039577124323061\" + \"690626291940392143974027089477766370248815549932245882597902063125743691094639\" + \"325280624164247686849545532493801763937161563684785982371590238542126584061536\" + \"722860713170267474013114526106376538339031592194346981760535838031061288785205\" + \"154693363924108846763200956708971836749057816308515813816196688222204757043759\" + \"061433804072585386208356517699842677452319582418268369827016023741493836349662\" + \"935157685406139734274647089968561817016055110488097155485911861718966802597354\" + \"170542398513556001872033507906094642127114399319604652742405088222535977348151\" + \"913543857125325854049394601086579379805862014336607882521971780902581737087091\" + \"646045272797715350991034073642502038638671822052287969445838765294795104866071\" + \"739022932745542678566977686593992341683412227466301506215532050265534146099524\" + \"935605085492175654913483095890653617569381763747364418337897422970070354520666\" + \"317092960759198962773242309025239744386101426309868773391388251868431650102796\" + \"491149773758288891345034114886594867021549210108432808078342808941729800898329\" + \"753694064496990312539986391958160146899522088066228540841486427478628197554662\" + \"927881462160717138188018084057208471586890683691939338186427845453795671927239\" + \"797236465166759201105799566396259853551276355876814021340982901629687342985079\" + \"247184605687482833138125916196247615690287590107273310329914062386460833337863\" + \"825792630239159000355760903247728133888733917809696660146961503175422675112599\" + \"331552967421333630022296490648093458200818106180210022766458040027821333675857\" + \"301901137175467276305904435313131903609248909724642792845554991349000518029570\" + \"708291905255678188991389962513866231938005361134622429461024895407240485712325\" + \"662888893172211643294781619055486805494344103409068071608802822795968695013364\" + \"381426825217047287086301013730115523686141690837567574763723976318575703810944\" + \"339056456446852418302814810799837691851212720193504404180460472162693944578837\" + \"709010597469321972055811407877598977207200968938224930323683051586265728111463\" + \"799698313751793762321511125234973430524062210524423435373290565516340666950616\" + \"589287821870775679417608071297378133518711793165003315552382248773065344417945\" + \"341539520242444970341012087407218810938826816751204229940494817944947273289477\" + \"011157413944122845552182842492224065875268917227278060711675404697300803703961\" + \"878779669488255561467438439257011582954666135867867189766129731126720007297155\" + \"361302750355616781776544228744211472988161480270524380681765357327557860250584\" + \"708401320883793281600876908130049249147368251703538221961903901499952349538710\" + \"599735114347829233949918793660869230137559636853237380670359114424326856151210\" + \"940425958263930167801712866923928323105765885171402021119695706479981403150563\" + \"304514156441462316376380990440281625691757648914256971416359843931743327023781\" + \"233693804301289262637538266779503416933432360750024817574180875038847509493945\" + \"489620974048544263563716499594992098088429479036366629752600324385635294584472\" + \"894454716620929749549661687741412088213047702281611645604400723635158114972973\" + \"921896673738264720472264222124201656015028497130633279581430251601369482556701\" + \"478093579088965713492615816134690180696508955631012121849180584792272069187169\" + \"631633004485802010286065785859126997463766174146393415956953955420331462802651\" + \"895116793807457331575984608617370268786760294367778050024467339133243166988035\" + \"407323238828184750105164133118953703648842269027047805274249060349208295475505\" + \"400345716018407257453693814553117535421072655783561549987444748042732345788006\" + \"187314934156604635297977945507535930479568720931672453654720838168585560604380\" + \"197703076424608348987610134570939487700294617579206195254925575710903852517148\" + \"852526567104534981341980339064152987634369542025608027761442191431892139390883\" + \"454313176968510184010384447234894886952098194353190650655535461733581404554483\" + \"788475252625394966586999205841765278012534103389646981864243003414679138061902\" + \"805960785488801078970551694621522877309010446746249797999262712095168477956848\" + \"258334140226647721084336243759374161053673404195473896419789542533503630186140\" + \"095153476696147625565187382329246854735693580289601153679178730355315937836308\" + \"224861517777054157757656175935851201669294311113886358215966761883032610416465\" + \"171484697938542262168716140012237821377977413126897726671299202592201740877007\" + \"695628347393220108815935628628192856357189338495885060385315817976067947984087\" + \"836097596014973342057270460352179060564760328556927627349518220323614411258418\" + \"242624771201203577638889597431823282787131460805353357449429762179678903456816\" + \"988955351850447832561638070947695169908624710001974880920500952194363237871976\" + \"487033922381154036347548862684595615975519376541011501406700122692747439388858\" + \"994385973024541480106123590803627458528849356325158538438324249325266608758890\" + \"831870070910023737710657698505643392885433765834259675065371500533351448990829\" + \"388773735205145933304962653141514138612443793588507094468804548697535817021290\" + \"849078734780681436632332281941582734567135644317153796781805819585246484008403\" + \"290998194378171817730231700398973305049538735611626102399943325978012689343260\" + \"558471027876490107092344388463401173555686590358524491937018104162620850429925\" + \"869743581709813389404593447193749387762423240985283276226660494238512970945324\" + \"558625210360082928664972417491914198896612955807677097959479530601311915901177\" + \"394310420904907942444886851308684449370590902600612064942574471035354765785924\" + \"270813041061854621988183009063458818703875585627491158737542106466795134648758\" + \"677154383801852134828191581246259933516019893559516796893285220582479942103451\" + \"271587716334522299541883968044883552975336128683722593539007920166694133909116\" + \"875880398882886921600237325736158820716351627133281051818760210485218067552664\" + \"867390890090719513805862673512431221569163790227732870541084203784152568328871\" + \"804698795251307326634027851905941733892035854039567703561132935448258562828761\" + \"061069822972142096199350933131217118789107876687204454887608941017479864713788\" + \"246215395593333327556200943958043453791978228059039595992743691379377866494096\" + \"404877784174833643268402628293240626008190808180439091455635193685606304508914\" + \"228964521998779884934747772913279726602765840166789013649050874114212686196986\" + \"204412696528298108704547986155954533802120115564697997678573892018624359932677\" + \"768945406050821883822790983362716712449002676117849826437703300208184459000971\" + \"723520433199470824209877151444975101705564302954282181967000920251561584417420\" + \"593365814813490269311151709387226002645863056132560579256092733226557934628080\" + \"568344392137368840565043430739657406101777937014142461549307074136080544210029\" + \"560009566358897789926763051771878194370676149821756418659011616086540863539151\" + \"303920131680576903417259645369235080641744656235152392905040947995318407486215\" + \"121056183385456617665260639371365880252166622357613220194170137266496607325201\" + \"077194793126528276330241380516490717456596485374835466919452358031530196916048\" + \"099460681490403781982973236093008713576079862142542209641900436790547904993007\" + \"837242158195453541837112936865843055384271762803527912882112930835157565659994\" + \"474178843838156514843422985870424559243469329523282180350833372628379183021659\" + \"183618155421715744846577842013432998259456688455826617197901218084948033244878\" + \"725818377480552226815101137174536841787028027445244290547451823467491956418855\" + \"124442133778352142386597992598820328708510933838682990657199461490629025742768\" + \"603885051103263854454041918495886653854504057132362968106914681484786965916686\" + \"184275679846004186876229805556296304595322792305161672159196867584952363529893\" + \"578850774608153732145464298479231051167635774949462295256949766035947396243099\" + \"534331040499420967788382700271447849406903707324910644415169605325656058677875\" + \"741747211082743577431519406075798356362914332639781221894628744779811980722564\" + \"671466405485013100965678631488009030374933887536418316513498254669467331611812\" + \"336485439764932502617954935720430540218297487125110740401161140589991109306249\" + \"231281311634054926257135672181862893278613883371802853505650359195274140086951\" + \"092616754147679266803210923746708721360627833292238641361959412133927803611827\" + \"632410600474097111104814000362334271451448333464167546635469973149475664342365\" + \"949349684588455152415075637660508663282742479413606287604129064491382851945640\" + \"264315322585862404314183866959063324506300039221319264762596269151090445769530\" + \"144405461803785750303668621246227863975274666787012100339298487337501447560032\" + \"210062235802934377495503203701273846816306102657030087227546296679688089058712\" + \"767636106622572235222973920644309352432722810085997309513252863060110549791564\" + \"479184500461804676240892892568091293059296064235702106152464620502324896659398\" + \"732493396737695202399176089847457184353193664652912584806448019652016283879518\" + \"949933675924148562613699594530728725453246329152911012876377060557060953137752\" + \"775186792329213495524513308986796916512907384130216757323863757582008036357572\" + \"800275449032795307990079944254110872569318801466793559583467643286887696661009\" + \"739574996783659339784634695994895061049038364740950469522606385804675807306991\" + \"229047408987916687211714752764471160440195271816950828973353714853092893704638\" + \"442089329977112585684084660833993404568902678751600877546126798801546585652206\" + \"121095349079670736553970257619943137663996060606110640695933082817187642604357\" + \"342536175694378484849525010826648839515970049059838081210522111109194332395113\" + \"605144645983421079905808209371646452312770402316007213854372346126726099787038\" + \"565709199850759563461324846018840985019428768790226873455650051912154654406382\" + \"925385127631766392205093834520430077301702994036261543400132276391091298832786\" + \"392041230044555168405488980908077917463609243933491264116424009388074635660726\" + \"233669584276458369826873481588196105857183576746200965052606592926354829149904\" + \"576830721089324585707370166071739819448502884260396366074603118478622583105658\" + \"087087030556759586134170074540296568763477417643105175103673286924555858208237\" + \"203860178173940517513043799486882232004437804310317092103426167499800007301609\" + \"481458637448877852227307633049538394434538277060876076354209844500830624763025\" + \"357278103278346176697054428715531534001649707665719598504174819908720149087568\" + \"603778359199471934335277294728553792578768483230110185936580071729118696761765\" + \"505377503029303383070644891281141202550615089641100762382457448865518258105814\" + \"034532012475472326908754750707857765973254284445935304499207001453874894822655\" + \"644222369636554419422544133821222547749753549462482768053333698328415613869236\" + \"344335855386847111143049824839899180316545863828935379913053522283343013795337\" + \"295401625762322808113849949187614414132293376710656349252881452823950620902235\" + \"787668465011666009738275366040544694165342223905210831458584703552935221992827\" + \"276057482126606529138553034554974455147034493948686342945965843102419078592368\" + \"022456076393678416627051855517870290407355730462063969245330779578224594971042\" + \"018804300018388142900817303945050734278701312446686009277858181104091151172937\" + \"487362788787490746528556543474888683106411005102302087510776891878152562273525\" + \"155037953244485778727761700196485370355516765520911933934376286628461984402629\" + \"525218367852236747510880978150709897841308624588152266096355140187449583692691\" + \"779904712072649490573726428600521140358123107600669951853612486274675637589622\" + \"529911649606687650826173417848478933729505673900787861792535144062104536625064\" + \"046372881569823231750059626108092195521115085930295565496753886261297233991462\" + \"835847604862762702730973920200143224870758233735491524608560821032888297418390\" + \"647886992327369136004883743661522351705843770554521081551336126214291181561530\" + \"175888257359489250710887926212864139244330938379733386780613179523731526677382\" + \"085802470143352700924380326695174211950767088432634644274912755890774686358216\" + \"216604274131517021245858605623363149316464691394656249747174195835421860774871\" + \"105733845843368993964591374060338215935224359475162623918868530782282176398323\" + \"730618020424656047752794310479618972429953302979249748168405289379104494700459\" + \"086499187272734541350810198388186467360939257193051196864560185578245021823106\" + \"588943798652243205067737996619695547244058592241795300682045179537004347245176\" + \"289356677050849021310773662575169733552746230294303120359626095342357439724965\" + \"921101065781782610874531887480318743082357369919515634095716270099244492974910\" + \"548985151965866474014822510633536794973714251022934188258511737199449911509758\" + \"374613010550506419772153192935487537119163026203032858865852848019350922587577\" + \"559742527658401172134232364808402714335636754204637518255252494432965704386138\" + \"786590196573880286840189408767281671413703366173265012057865391578070308871426\" + \"151907500149257611292767519309672845397116021360630309054224396632067432358279\" + \"788933232440577919927848463333977773765590187057480682867834796562414610289950\" + \"848739969297075043275302997287229732793444298864641272534816060377970729829917\" + \"302929630869580199631241330493935049332541235507105446118259114111645453471032\" + \"988104784406778013807713146540009938630648126661433085820681139583831916954555\" + \"825942689576984142889374346708410794631893253910696395578070602124597489829356\" + \"461356078898347241997947856436204209461341238761319886535235831299686226894860\" + \"840845665560687695450127448663140505473535174687300980632278046891224682146080\" + \"672762770840240226615548502400895289165711761743902033758487784291128962324705\" + \"919187469104200584832614067733375102719565399469716251724831223063391932870798\" + \"380074848572651612343493327335666447335855643023528088392434827876088616494328\" + \"939916639921048830784777704804572849145630335326507002958890626591549850940797\" + \"276756712979501009822947622896189159144152003228387877348513097908101912926722\" + \"710377889805396415636236416915498576840839846886168437540706512103906250612810\" + \"766379904790887967477806973847317047525344215639038720123880632368803701794930\" + \"895490077633152306354837425681665336160664198003018828712376748189833024683637\" + \"148830925928337590227894258806008728603885916884973069394802051122176635913825\" + \"152427867009440694235512020156837777885182467002565170850924962374772681369428\" + \"435006293881442998790530105621737545918267997321773502936892806521002539626880\" + \"749809264345801165571588670044350397650532347828732736884086354000274067678382\" + \"196352222653929093980736739136408289872201777674716811819585613372158311905468\" + \"293608323697611345028175783020293484598292500089568263027126329586629214765314\" + \"223335179309338795135709534637718368409244442209631933129562030557551734006797\" + \"374061416210792363342380564685009203716715264255637185388957141641977238742261\" + \"059666739699717316816941543509528319355641770566862221521799115135563970714331\" + \"289365755384464832620120642433801695586269856102246064606933079384785881436740\" + \"700059976970364901927332882613532936311240365069865216063898725026723808740339\" + \"674439783025829689425689674186433613497947524552629142652284241924308338810358\" + \"005378702399954217211368655027534136221169314069466951318692810257479598560514\" + \"500502171591331775160995786555198188619321128211070944228724044248115340605589\" + \"595835581523201218460582056359269930347885113206862662758877144603599665610843\" + \"072569650056306448918759946659677284717153957361210818084154727314266174893313\" + \"417463266235422207260014601270120693463952056444554329166298666078308906811879\" + \"009081529506362678207561438881578135113469536630387841209234694286873083932043\" + \"233387277549680521030282154432472338884521534372725012858974769146080831440412\" + \"586818154004918777228786980185345453700652665564917091542952275670922221747411\" + \"206272065662298980603289167206874365494824610869736722554740481288924247185432\" + \"360575341167285075755205713115669795458488739874222813588798584078313506054829\" + \"055148278529489112190538319562422871948475940785939804790109419407067176443903\" + \"273071213588738504999363883820550168340277749607027684488028191222063688863681\" + \"104356952930065219552826152699127163727738841899328713056346468822739828876319\" + \"864570983630891778648708667618548568004767255267541474285102814580740315299219\" + \"781455775684368111018531749816701642664788409026268282444825802753209454991510\" + \"451851771654631180490456798571325752811791365627815811128881656228587603087597\" + \"496384943527567661216895926148503078536204527450775295063101248034180458405943\" + \"292607985443562009370809182152392037179067812199228049606973823874331262673030\" + \"679594396095495718957721791559730058869364684557667609245090608820221223571925\" + \"453671519183487258742391941089044411595993276004450655620646116465566548759424\" + \"736925233695599303035509581762617623184956190649483967300203776387436934399982\" + \"943020914707361894793269276244518656023955905370512897816345542332011497599489\" + \"627842432748378803270141867695262118097500640514975588965029300486760520801049\" + \"153788541390942453169171998762894127722112946456829486028149318156024967788794\" + \"981377721622935943781100444806079767242927624951078415344642915084276452000204\" + \"276947069804177583220909702029165734725158290463091035903784297757265172087724\" + \"474095226716630600546971638794317119687348468873818665675127929857501636341131\" + \"462753049901913564682380432997069577015078933772865803571279091376742080565549\" + \"362541\" ; Tipps: Schauen Sie sich dazu die Klasse String genauer an! \u00dcberlegen Sie sich, wie Sie am besten alle m\u00f6glichen Kombinationen aus 4-stelligen Zahlen als String erzeugen k\u00f6nnen (also \"0000\", \"0001\", \"0002\", ... \"9999\" ) Schreiben Sie sich eine Methode int nrOfOccurences(String sub, String str) , die die Anzahl des Vorkommens von sub in str z\u00e4hlt. Sie k\u00f6nnen diese Methode z.B. testen, indem Sie sub=\"0000\" setzen und str=pi \u2192 \"0000\" kommt 9 Mal in pi vor. Testen Sie auch sub=\"2541\" und str=pi , denn \"2541\" ist der allerletzte substring in unserem pi und kommt 8 Mal vor. Merken Sie sich das bisherige maximale Vorkommen eines bestimmten substrings in pi \u2192 Sie merken sich den String und wie oft er vorkam (wenn er h\u00e4ufiger vorkam als der, den Sie sich bis dahin als h\u00e4ufigstes Vorkommen gemerkt hatten). Am Ende haben Sie sich dann den String gemerkt, der am h\u00e4ufigsten vorkommt und auch die Anzahl der Vorkommen. Laden Sie Ihre L\u00f6sung bis Sonntag, den 29.11.2020 um 24.00 Uhr in Moodle hoch Viel Spa\u00df und viel Erfolg! Aufgabe 3 - Arrays ausgeben Wir geben Arrays in verschiedenen Arten auf der Konsole aus. Implementieren Sie eine Methode public static int[] createAndFillArray(int length, int fromInclusive, int toInclusive) . Diese Methode soll genau so sein, wie die createAndFillArray(int length, int bound) -Methode in Methoden mit Array als R\u00fcckgabe mit dem einzigen Unterschied, dass wir nicht den bound angeben (der sorgt ja daf\u00fcr, dass wir Zufallswerte aus dem Bereich [0, 1, ... , bound-1] erzeugen), sondern fromInclusive und toExclusive , so dass wir Zufallswerte aus dem Wertebereich [fromInclusive, ... , toInclusive] erzeugen. Siehe dazu auch nextInt(bound) . Implementieren Sie eine Methode public static void printArray(int[] a) so, dass sie ein int -Array in der Form [ 27, 30, 25, 26, 23, 20, 30, 30, 22, 21, 29, 29, 21, 20 ] (also Werte durch Komma getrennt in eckigen Klammern) ausgibt. Siehe dazu Ausgabe von Arrays . Rufen Sie in der main() die beiden Methoden wie folgt auf: int length = r . nextInt ( 10 ) + 10 ; int [] arr1 = createAndFillArray ( length , 20 , 30 ); System . out . printf ( \"%n%n%n----------- printArray -----------------%n%n%n\" ); printArray ( arr1 ); Implementieren Sie eine Methode public static void printTable(int[] a) . Diese gibt das Array a als Tabelle in folgender Form aus: | Index : | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | | ------------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | | Wert : | 27 | 30 | 25 | 26 | 23 | 20 | 30 | 30 | 22 | 21 | 29 | 29 | 21 | 20 | Rufen Sie in der main() die Methode printTable() wie folgt auf: System . out . printf ( \"%n%n%n----------- printTable -----------------%n%n%n\" ); printTable ( arr1 ); Implementieren Sie eine Methode public static void printHorizontal(int[] a) . Diese gibt das Array a in folgender Form aus: | 0 | *************************** | 1 | ****************************** | 2 | ************************* | 3 | ************************** | 4 | *********************** | 5 | ******************** | 6 | ****************************** | 7 | ****************************** | 8 | ********************** | 9 | ********************* | 10 | ***************************** | 11 | ***************************** | 12 | ********************* | 13 | ******************** | Das hei\u00dft, f\u00fcr jeden Wert im Array wird die entsprechende Anzahl von Sternen ausgegeben. Ganz links steht jeweils der Index, unter dem der Wert im Array gespeichert wird. Rufen Sie in der main() die Methode printTable() wie folgt auf: System . out . printf ( \"%n%n%n----------- printHorizontal ------------%n%n%n\" ); printHorizontal ( arr1 ); Wenn Sie das geschafft haben, dann haben Sie die Aufgabe erf\u00fcllt! Herzlichen Gl\u00fcckwunsch! Die folgende(n) Aufgabe(n) sind optional : Implementieren Sie eine Methode public static void printUpsideDown(int[] a) oder eine Methode public static void printVertical(int[] a) (beide gleicher Aufwand). Diese geben das Array a in folgender Form aus: ----------- printUpsideDown ------------ | 0 1 2 3 4 5 6 7 8 9 10 11 12 13 ----+---------------------------------------------------------------------- 1 | * * * * * * * * * * * * * * 2 | * * * * * * * * * * * * * * 3 | * * * * * * * * * * * * * * 4 | * * * * * * * * * * * * * * 5 | * * * * * * * * * * * * * * 6 | * * * * * * * * * * * * * * 7 | * * * * * * * * * * * * * * 8 | * * * * * * * * * * * * * * 9 | * * * * * * * * * * * * * * 10 | * * * * * * * * * * * * * * 11 | * * * * * * * * * * * * * * 12 | * * * * * * * * * * * * * * 13 | * * * * * * * * * * * * * * 14 | * * * * * * * * * * * * * * 15 | * * * * * * * * * * * * * * 16 | * * * * * * * * * * * * * * 17 | * * * * * * * * * * * * * * 18 | * * * * * * * * * * * * * * 19 | * * * * * * * * * * * * * * 20 | * * * * * * * * * * * * * * 21 | * * * * * * * * * * * * 22 | * * * * * * * * * * 23 | * * * * * * * * * 24 | * * * * * * * * 25 | * * * * * * * * 26 | * * * * * * * 27 | * * * * * * 28 | * * * * * 29 | * * * * * 30 | * * * ----------- printVertical -------------- 30 | * * * 29 | * * * * * 28 | * * * * * 27 | * * * * * * 26 | * * * * * * * 25 | * * * * * * * * 24 | * * * * * * * * 23 | * * * * * * * * * 22 | * * * * * * * * * * 21 | * * * * * * * * * * * * 20 | * * * * * * * * * * * * * * 19 | * * * * * * * * * * * * * * 18 | * * * * * * * * * * * * * * 17 | * * * * * * * * * * * * * * 16 | * * * * * * * * * * * * * * 15 | * * * * * * * * * * * * * * 14 | * * * * * * * * * * * * * * 13 | * * * * * * * * * * * * * * 12 | * * * * * * * * * * * * * * 11 | * * * * * * * * * * * * * * 10 | * * * * * * * * * * * * * * 9 | * * * * * * * * * * * * * * 8 | * * * * * * * * * * * * * * 7 | * * * * * * * * * * * * * * 6 | * * * * * * * * * * * * * * 5 | * * * * * * * * * * * * * * 4 | * * * * * * * * * * * * * * 3 | * * * * * * * * * * * * * * 2 | * * * * * * * * * * * * * * 1 | * * * * * * * * * * * * * * ----+---------------------------------------------------------------------- | 0 1 2 3 4 5 6 7 8 9 10 11 12 13 Rufen Sie in der main() die beiden Methoden (oder die, die Sie implememntiert haben) wie folgt auf: System . out . printf ( \"%n%n%n----------- printUpsideDown ------------%n%n%n\" ); printUpsideDown ( arr1 ); System . out . printf ( \"%n%n%n----------- printVertical --------------%n%n%n\" ); printVertical ( arr1 ); Tipps zum L\u00f6sen der Zusatzaufgabe: Sie m\u00fcssen zun\u00e4chst ermitteln, welcher der gr\u00f6\u00dfte Wert innerhalb des Arrays ist, denn dieser gibt Ihnen die Anzahl der Zeilen im Diagramm vor. Stellen Sie sich das Problem als eine Matrix aus Zeilen und Spalten vor. Die Spalten lassen sich auf den Index des Arrays mappen und die Zeilen auf die Werte im Array. Viel Spa\u00df und viel Erfolg!","title":"Aufgaben"},{"location":"ausdruecke/","text":"Operatoren und Ausdr\u00fccke \u00b6 Im vorherigen Abschnitt haben wir Variablen und Datentypen kennengelernt. Wir k\u00f6nnen Variablen deklarieren und initialisieren und ihnen neue Werte zuweisen. Nun f\u00fchren wir Operationen ein, die wir in den jeweiligen Datentypen verwenden k\u00f6nnen, um neue Werte zu erzeugen. Wir beginnen bei den arithmetischen Operatoren, d.h. mit den Operatoren, die wir f\u00fcr die ganzzahligen Datentypen und die Gleitkomma-Datentypen verwenden k\u00f6nnen. Arithmetische Operatoren \u00b6 Arithmetische Operationen kennen wir nat\u00fcrlich schon. Die einfachsten arithmetischen Operatoren sind die un\u00e4ren Operatoren, auch Vorzeichenoperatoren genannt. Ansonsten gibt es die Addition + , die Subtraktion - , die Multiplikation * und die Division / . Au\u00dferdem gibt es auch einen Restwertoperator (auch modulo genannt), der bei der ganzzahligen Division den verbleibenden Rest als Ergebnis ermittelt ( % ). Ganz wichtig ist, dass das Divisionssymbol / eine unterschiedliche Bedeutung hat, je nachdem, ob wir ganze Zahlen dividieren oder Gleitkommazahlen. Bei der Division von ganzen Zahlen ist das Ergebnis der Division der ganzzahlige Wert (also z.B. 5 / 4 ergibt 1 ), aber bei der Division von Gleitkommazahlen ein Gleitkommawert (also z.B. 5.0 / 4.0 ergibt 1.25 ). Der Restwertoperator wird wirklich sinnvoll eigentlich nur f\u00fcr ganze Zahlen verwendet (also z.B. 7 % 4 ergibt 3 - der verbleibende Rest der ganzzahligen Divsion ist 3 ). Trotzdem kann der Restwertoperator auch auf Gleitkommazahlen angewendet werden (obwohl dort ja eigentlich kein Rest bleibt). So ergibt 7.0 % 4.0 auch 3.0 und/aber 7.5 % 4.0 ergibt 3.5 . Operatorsymbol(e) Bedeutung Beispiel Un\u00e4re Operatoren + Wird als Vorzeichen vor ganzen Zahlen (z.B. +5 ) oder vor Gleikommazahlen (z.B. +5.5 ) verwendet. + \u00e4ndert nichts und kann immer weggelassen werden. Verhalten f\u00fcr ganze Zahlen und Gleitkommazahlen gleich. int x = -5; x = +x; Wert von x ist -5 - Wird als Vorzeichen vor ganzen Zahlen (z.B. -5 ) oder vor Gleikommazahlen (z.B. -5.5 ) verwendet. -x dreht das Vorzeichen von x um. Verhalten f\u00fcr ganze Zahlen und Gleitkommazahlen gleich. int x = -5; x = -x; Wert von x ist +5 double y = -5.5; y = -y; Wert von y ist +5.5 Bin\u00e4re Operatoren + Addition von Zahlen. Verhalten f\u00fcr ganze Zahlen und Gleitkommazahlen gleich. int x = -5 + 6; Wert von x: +1 double y = -5.5 + 6.5; Wert von y: +1.0 - Subtraktion von Zahlen. Verhalten f\u00fcr ganze Zahlen und Gleitkommazahlen gleich. int x = -5 - 6; Wert von x ist -11 double y = -5.5 - 6.5; Wert von y: -12.0 * Multiplikation von Zahlen. Verhalten f\u00fcr ganze Zahlen und Gleitkommazahlen gleich. int x = -5 * 6; Wert von x: -30 double y = -5.0 * 6.0; Wert von y: -30.0 / Division von Zahlen. Achtung! Sie m\u00fcssen unterscheiden, ob Sie ganze Zahlen dividieren oder Gleitkommazahlen! Bei ganzen Zahlen handelt es sich um die ganzzahlige Division! int x = 5 / 4; Wert von x: +1 double y = 5.0 / 4.0; Wert von y: +1.25 % Restwertoperator. Ergebnis ist der Rest, der bei ganzzahliger Division \u00fcbrig bleibt. Wirklich sinnvoll nur bei ganzzahligen Werten, geht aber auch bei Gleitkommazahlen. int x = 7 % 4; Wert von x ist 3 double y = 6.5 % 5.0; Wert von y ist 1.5 Pr\u00e4- und Postfix-Operatoren \u00b6 Dar\u00fcber hinaus gibt es noch besondere Operatoren, die eingef\u00fchrt wurden, weil sie eine h\u00e4ufig vorkommende Operation in der Schreibweise verk\u00fcrzen. Angenommen, wir haben eine Variable int x = 5; . Da es (insbesondere sp\u00e4ter in Schleifen) h\u00e4ufig vorkommt, dass der Wert dieser Variablen um 1 erh\u00f6ht werden soll, hat man daf\u00fcr einen eigenen Operator eingef\u00fchrt: ++ . Dieser Operator steht f\u00fcr die Erh\u00f6hung des Wertes um den Summanden 1 . Er kann sowohl als Pr\u00e4fix-Operator ( ++x ) als auch als Postfix-Operator eingesetzt werden. Man spricht hier von Pr\u00e4- und Postfix- Inkrement -Operatoren. 1 2 3 4 5 int x = 5 ; System . out . println ( x ++ ); // 5 System . out . println ( x ); // 6 System . out . println ( ++ x ); // 7 System . out . println ( x ); // 7 Der Unterschied zwischen den beiden wird im obigen Beispiel deutlich. x hat nach der Initialisierung den Wert 5 . In Zeile 2 geben wir den Wert aus und erh\u00f6hen x danach um 1 . Ausgegeben wird also der Wert 5 , aber nach der Ausgabe ist der Wert um 1 erh\u00f6ht auf 6 (siehe Zeile 3 ). Bei dem Prefix-Operator (Zeile 4 ) wird der Wert erst erh\u00f6ht und dann ausgelesen. Es wird also bereits der neue Wert 7 ausgegeben. Im Prinzip entsprechen beide Operatoren aber der Anweisung x = x + 1; . Den \u00e4quivalenten Operator gibt es auch f\u00fcr die Subtraktion minus 1 . Dies wird mit dem Prefix-Operator --x; sowie mit dem Postfix-Operator x--; erreicht. Diese hei\u00dfen Pr\u00e4- und Postfix- Dekrement -Operatoren. Verk\u00fcrzte Schreibweisen f\u00fcr arithmetische Operatoren \u00b6 Aus dieser Verwendung haben sich weitere Schreibweisen etabliert: Operatoren (Beispiele) Bedeutung x+=7; x = x + 7; x-=7; x = x - 7; x*=7; x = x * 7; x/=7; x = x / 7; x%=7; x = x % 7; Vergleichsoperatoren \u00b6 Werden die oben genannten Operatoren auf arithmetische Datentypen angewendet, so ist das Ergebnis selbst wieder von einem arithmetischen Datentyp ( int oder double ). Bei den folgenden Vergleichsoperatoren ist das anders. Die Operanden sind zwar auch wieder von arithmetischen Datentypen, aber das Ergebnis ist ein boolean , das hei\u00dft, der Vergleich resultiert in einem Wert true oder in einem Wert false . Vergleichsoperator Beispiel Bedeutung == x == y Vergleich auf Gleichheit. Ergibt true , wenn x den gleichen Wert hat wie y , sonst false < x < y Kleiner als. Ergibt true , wenn x einen echt kleineren Wert hat als y , sonst false > x > y Gr\u00f6\u00dfer als. Ergibt true , wenn x einen echt gr\u00f6\u00dferen Wert hat als y , sonst false < = x < = y Kleiner gleich. Ergibt true , wenn x einen kleineren als oder den gleichen Wert wie y hat, sonst false >= x >= y Gr\u00f6\u00dfer gleich. Ergibt true , wenn x einen gr\u00f6\u00dferen als oder den gleichen Wert wie y hat, sonst false != x != y Ungleich. Ergibt true , wenn x einen anderen Wert hat als y , sonst false Wertzuweisungsoperator \u00b6 Einen weiteren Operator kennen wir bereits, den Wertzuweisungsoperator = . Auf der linken Seite der Zuweisung steht immer eine Variable und auf der rechten Seite ein Wert, der sich auch aus einem Ausdruck ergeben kann, z.B. int x = 5 + 6; . Dann wird x der Wert 11 zugeweisen. Beachte Der Zuweisungsoperator ist zun\u00e4chst gew\u00f6hnungsbed\u00fcrftig, denn eine Zuweisung der Form x = x+1; sieht ja aus mathematischer Sicht komisch aus, da in der Mathematik das Symbol = f\u00fcr die Gleichheit verwendet wird. In der (Java-)Programmierung hat dieses Symbol aber eine andere Bedeutung, n\u00e4mlich die Zuweisung des Wertes auf der rechten Seite zur Variablen auf der linken Seite. In der Zuweisung x = x+1; wird also erst der Wert x+1 berechnet und dieser Wert dann der Variablen x zugeordnet (die dann einen um 1 h\u00f6heren Wert hat als zuvor). Der Operator f\u00fcr die Gleichheit ist \u00fcbrigens == , wie wir gleich sehen werden. Logische Operatoren \u00b6 Die arithmetischen Operatoren werden auf Operanden angewendet, die von einem ganzzahligen Datentyp oder von einem Gleitkomma-Datentyp sind. Jetzt lernen wir Operatoren kennen, die auf Operanden vom Typ boolean angewendet werden. Nehmen wir in der folgenden Tabelle an, dass die Variablen a und b jeweils vom Typ boolean sind. Sie wurden also wie folgt deklariert: boolean a; und boolean b; . Logischer Operator Beispiel Bedeutung && a && b UND-Operator. Ergibt true , wenn a den Wert true hat UND b auch den Wert true , sonst false || a || b ODER-Operator. Ergibt true , wenn a den Wert true hat ODER b den Wert true (oder beide), sonst false ^ a ^ b EXCLUSIVES ODER. Ergibt true , wenn ENTWEDER a den Wert true hat ODER b den Wert true (aber NICHT beide), sonst false ! !a NEGATION (un\u00e4rer Operator). Ergibt true , wenn a den Wert false hat, ergibt false , wenn a den Wert true hat Es sein angemerkt, dass es f\u00fcr die Operatoren && und || jeweils auch die Operatoren & und | gibt. Das logische Prinzip ist das gleiche (also UND und ODER). Es gibt nur jeweils eine Unterscheidung und diese ist im folgenden Beispiel dargestellt: false && a // a wird nicht mehr gepr\u00fcft, Ausdruck ist false false & a // a wird gepr\u00fcft, Ausdruck ist false true || b // b wird nicht mehr gepr\u00fcft, Ausdruck ist true true | b // b wird gepr\u00fcft, Ausdruck ist true Ist beim logischen UND bereits der erste Operand false , dann kann das Ergebnis nicht mehr true sein, sondern ist false . Egal, welchen Wert der zweite Operand hat. Bei dem Operator && wird dann der zweite Operand auch gar nicht mehr gepr\u00fcft. Bei dem Operator & aber doch. && ist somit effizienter. Ist beim logischen ODER bereits der erste Operand true , dann ist das Ergebnis bereits true , egal, welchen Wert der zweite Operand hat. Bei dem Operator || wird dann der zweite Operand auch gar nicht mehr gepr\u00fcft. Bei dem Operator | aber doch. || ist somit effizienter. Wir verwenden deshalb immer && und || anstatt & und | . Wahrheitstabellen \u00b6 Hier nochmal eine Veranschaulichung der obigen logischen Operatoren in einer Wahrheitstabelle. Wir nehmen wieder an, dass die Variablen a und b jeweils vom Typ boolean sind. a b a && b a || b a ^ b !a true true true true false false true false false true true false false true false true true true false false false false false true \u00dcbung Exclusives Oder Angenommen, es g\u00e4be den Operator ^ f\u00fcr das Exclusive Oder nicht und Sie h\u00e4tten nur die Operatoren && , || und ! . Wie k\u00f6nnen Sie mit && , || und ! das exclusive Oder \"nachbauen\"? Ausdr\u00fccke und Anweisungen \u00b6 Anweisungen haben wir bereits kennengelernt. Zum Beispiel sind Deklarationen Anweisungen und Initialisierungen auch. Neben Anweisungen gibt es im Programmcode auch Ausdr\u00fccke . Ausdr\u00fccke unterscheiden sich von Anweisungen dahingehened, dass sie einen Wert (genauer einen R\u00fcckgabewert ) haben. Jeder Wert in Java hat einen Typ. Wir schauen uns zun\u00e4chst die einfachsten Ausdr\u00fccke an, die es gibt, n\u00e4mlich sogenannte Literale . Literale \u00b6 Ein Literal ist ein konstanter Wert im Java-Quellcode. Literale sind z.B. ganze Zahlen (z.B. 123 oder -123 ), Gleikommazahlen (z.B 5.5 oder -6.0 ), Wahrheitswerte ( true oder false ), ein Character (z.B. 'a' oder 'A' ) Wir werden sp\u00e4ter noch andere Literale kennenlernen: Zeichenketten (Datentyp String ), z.B. \"Hallo FIW!\" die leere Referenz null Jedes Literal ist ein Ausdruck. Der R\u00fcckgabewert des Literals ist der Wert des Literals. Jedes Literal ist von einem konkreten Datentyp. Die folgenden Anweisungen werden auch Ausdrucksanweisung genannt, da in der Anweisung ein Ausdruck verwendet wird und der Wert dieses Ausdrucks als Nebeneffekt zum Tragen kommt (nur die ersten beiden sind Ausdrucksanweisungen - die folgenden drei sind Fehler ): int x = 123 ; // auf der rechten Seite des Zuweisungsoperators steht ein Ausdruck; // der Wert des Ausdrucks wird der Wert der Variablen x x ++ ; // x++ ist ein Ausdruck - durch das Semikolon wird der Ausdruck hier zu einer Ausdrucksanweisung x ++ // der Ausdruck selbst kann so nicht stehen (Compilerfehler) // da steht nur ein Wert mit dem nichts gemacht wird 5 + 6 // gleicher Fehler wie oben; nur ein Ausdruck, kann so nicht alleine stehen 5 + 6 ; // geht auch nicht; hier gibt es keinen Nebeneffekt (keine Zuweisung) // keine g\u00fcltige Ausdrucksanweisung Ausdr\u00fccke sind Literale Literale, die mit (passenden) Operatoren verkn\u00fcpft sind Ausdr\u00fccke, die mit passenden Operatoren verkn\u00fcpft sind Ausdr\u00fccke mit Operatoren \u00b6 Verbinden wir Literale mit Operatoren, entstehen dadurch Ausdr\u00fccke. Ausdr\u00fccke k\u00f6nnen wiederum mithilfe von Operatoren mit weiteren Literalen oder auch mit weiteren Ausdr\u00fccken verbunden werden. Beachten Sie, dass Ausdr\u00fccke immer einen Wert haben, der Wert ermittelt wird, indem der Ausdruck aufgel\u00f6st wird, d.h. die Operatoren angewendet werden. Dies erfolgt in folgender Reihenfolge: wenn runde Klammern um einen Ausdruck gesetzt sind, wird zun\u00e4chst der geklammerte Ausdruck aufgerufen, un\u00e4re (also einelementige) Operatoren binden st\u00e4rker als bin\u00e4re (also zweielementige) Operatoren, d.h. es werden zun\u00e4chst die einelementigen Operatoren angewendet, bei arithmetischen Operatoren gilt \"Punkt vor Strich-Rechnung\", bei logischen Operatoren gilt folgende Reihenfolge (st\u00e4rkere Bindung von links nach rechts) == , != -> & \u2192 ^ \u2192 | \u2192 && \u2192 || (lernen Sie das aber keinesfalls auswendig und verlassen sich dann auf Ihr Ged\u00e4chtnis, sondern verwenden Sie Klammern!) der Zuweisungsoperator ( = ) sowie += , -= , /= , *= , %= binden am schw\u00e4chsten dann erfolgt die Aufl\u00f6sung von links nach rechts Achten Sie darauf, dass Ausdr\u00fccke einen anderen Typ haben k\u00f6nnen als die Literale (bzw. Ausdr\u00fccke), die man im Ausdruck mithilfe von Operatoren miteinander verbindet, z.B. 3 == 4 ist vom Typ boolean , aber 3 und 4 sind jeweils vom Typ int . Beispiele f\u00fcr Ausdr\u00fccke sind: 5 + 6 - 8 // Ergebnis (Wert) ist ein int true && false // Ergebnis (Wert) ist ein boolean 5 < 6 // Ergebnis (Wert) ist ein boolean 7 >= 7 // Ergebnis (Wert) ist ein boolean 6 == 6 // Ergebnis (Wert) ist ein boolean 6 != 6 // Ergebnis (Wert) ist ein boolean 5.5 * 2.0 // Ergebnis (Wert) ist ein double 7.0 / 4.0 // Ergebnis (Wert) ist ein double ( 7.0 / 4.0 ) > 1.0 // Ergebnis (Wert) ist ein boolean \u00dcbung Ausdruck Angenommen, a , b und c seien vom Typ int . Was ist an diesem Ausdruck falsch: a < b < c ? Wie w\u00e4re es richtig? \u00dcbung Durchschnitt berechnen Angenommen, Sie sollen die Durchschnittsnote von folgenden Noten berechnen: 1 , 1 , 1 , 1 , 2 , 2 , 3 , 4 . Sie \u00fcberlegen sich folgendes Programm daf\u00fcr: int summe = 1 + 1 + 1 + 1 + 2 + 2 + 3 + 4 ; int anzahl = 8 ; System . out . println ( summe / anzahl ); Vom Ergebnis sind Sie aber entt\u00e4uscht. Welches Ergebnis wird ausgegeben? Welches w\u00e4re richtig gewesen? Was ist an Ihrem Programm falsch? Wie geht es besser? Bei der Verwendung des Zuweisungsoperators gibt es auf der linken Seite immer eine Variable und auf der rechten Seite immer einen Ausdruck. Bevor die Zuweisung erfolgt, wird der Wert des Ausdrucks auf der rechten Seite ausgewertet. Beispiele: int x = 0 ; // Wert von x ist 0 x = 7 + 4 / 2 ; // Wert von x ist 9 int y = 7 % 4 ; // Wert von y ist 3 x = y ++ ; // Achtung Wert von x ist 3 (Postfix); Wert von y ist 4 x = y ; // Wert von x ist 4 boolean a = ( 7 > 4 ); // Wert von a ist true a = ! a ; // Wert von a ist false a = ( a || true ); // Wert von a ist true a = !! a && true ; // Wert von a ist true Beachte Generell gilt bei der Zuweisung immer , dass der Ausdruck auf der rechten Seite erst vollst\u00e4ndig ausgerechnet wird und der berechnete Wert dann der Variablen auf der linken Seite zugewiesen wird. \"Leider\" macht der Postfix-Operator dabei eine Ausnahme . Bei diesem Operator erfolgt erst die Zuweisung und dann die Berechnung: int x = 3 ; // x hat den Wert 3 int y = x ++ ; // y hat den Wert 3 und x den Wert 4 int a = 3 ; // a hat den Wert 3 int b = a -- ; // b hat den Wert 3 und a den Wert 2 Das gilt nicht f\u00fcr den Pr\u00e4fix-Operator: int x = 3 ; // x hat den Wert 3 int y = ++ x ; // y hat den Wert 4 und x den Wert 4 int a = 3 ; // a hat den Wert 3 int b = -- a ; // b hat den Wert 2 und a den Wert 2","title":"Ausdr\u00fccke"},{"location":"ausdruecke/#operatoren-und-ausdrucke","text":"Im vorherigen Abschnitt haben wir Variablen und Datentypen kennengelernt. Wir k\u00f6nnen Variablen deklarieren und initialisieren und ihnen neue Werte zuweisen. Nun f\u00fchren wir Operationen ein, die wir in den jeweiligen Datentypen verwenden k\u00f6nnen, um neue Werte zu erzeugen. Wir beginnen bei den arithmetischen Operatoren, d.h. mit den Operatoren, die wir f\u00fcr die ganzzahligen Datentypen und die Gleitkomma-Datentypen verwenden k\u00f6nnen.","title":"Operatoren und Ausdr\u00fccke"},{"location":"ausdruecke/#arithmetische-operatoren","text":"Arithmetische Operationen kennen wir nat\u00fcrlich schon. Die einfachsten arithmetischen Operatoren sind die un\u00e4ren Operatoren, auch Vorzeichenoperatoren genannt. Ansonsten gibt es die Addition + , die Subtraktion - , die Multiplikation * und die Division / . Au\u00dferdem gibt es auch einen Restwertoperator (auch modulo genannt), der bei der ganzzahligen Division den verbleibenden Rest als Ergebnis ermittelt ( % ). Ganz wichtig ist, dass das Divisionssymbol / eine unterschiedliche Bedeutung hat, je nachdem, ob wir ganze Zahlen dividieren oder Gleitkommazahlen. Bei der Division von ganzen Zahlen ist das Ergebnis der Division der ganzzahlige Wert (also z.B. 5 / 4 ergibt 1 ), aber bei der Division von Gleitkommazahlen ein Gleitkommawert (also z.B. 5.0 / 4.0 ergibt 1.25 ). Der Restwertoperator wird wirklich sinnvoll eigentlich nur f\u00fcr ganze Zahlen verwendet (also z.B. 7 % 4 ergibt 3 - der verbleibende Rest der ganzzahligen Divsion ist 3 ). Trotzdem kann der Restwertoperator auch auf Gleitkommazahlen angewendet werden (obwohl dort ja eigentlich kein Rest bleibt). So ergibt 7.0 % 4.0 auch 3.0 und/aber 7.5 % 4.0 ergibt 3.5 . Operatorsymbol(e) Bedeutung Beispiel Un\u00e4re Operatoren + Wird als Vorzeichen vor ganzen Zahlen (z.B. +5 ) oder vor Gleikommazahlen (z.B. +5.5 ) verwendet. + \u00e4ndert nichts und kann immer weggelassen werden. Verhalten f\u00fcr ganze Zahlen und Gleitkommazahlen gleich. int x = -5; x = +x; Wert von x ist -5 - Wird als Vorzeichen vor ganzen Zahlen (z.B. -5 ) oder vor Gleikommazahlen (z.B. -5.5 ) verwendet. -x dreht das Vorzeichen von x um. Verhalten f\u00fcr ganze Zahlen und Gleitkommazahlen gleich. int x = -5; x = -x; Wert von x ist +5 double y = -5.5; y = -y; Wert von y ist +5.5 Bin\u00e4re Operatoren + Addition von Zahlen. Verhalten f\u00fcr ganze Zahlen und Gleitkommazahlen gleich. int x = -5 + 6; Wert von x: +1 double y = -5.5 + 6.5; Wert von y: +1.0 - Subtraktion von Zahlen. Verhalten f\u00fcr ganze Zahlen und Gleitkommazahlen gleich. int x = -5 - 6; Wert von x ist -11 double y = -5.5 - 6.5; Wert von y: -12.0 * Multiplikation von Zahlen. Verhalten f\u00fcr ganze Zahlen und Gleitkommazahlen gleich. int x = -5 * 6; Wert von x: -30 double y = -5.0 * 6.0; Wert von y: -30.0 / Division von Zahlen. Achtung! Sie m\u00fcssen unterscheiden, ob Sie ganze Zahlen dividieren oder Gleitkommazahlen! Bei ganzen Zahlen handelt es sich um die ganzzahlige Division! int x = 5 / 4; Wert von x: +1 double y = 5.0 / 4.0; Wert von y: +1.25 % Restwertoperator. Ergebnis ist der Rest, der bei ganzzahliger Division \u00fcbrig bleibt. Wirklich sinnvoll nur bei ganzzahligen Werten, geht aber auch bei Gleitkommazahlen. int x = 7 % 4; Wert von x ist 3 double y = 6.5 % 5.0; Wert von y ist 1.5","title":"Arithmetische Operatoren"},{"location":"ausdruecke/#pra-und-postfix-operatoren","text":"Dar\u00fcber hinaus gibt es noch besondere Operatoren, die eingef\u00fchrt wurden, weil sie eine h\u00e4ufig vorkommende Operation in der Schreibweise verk\u00fcrzen. Angenommen, wir haben eine Variable int x = 5; . Da es (insbesondere sp\u00e4ter in Schleifen) h\u00e4ufig vorkommt, dass der Wert dieser Variablen um 1 erh\u00f6ht werden soll, hat man daf\u00fcr einen eigenen Operator eingef\u00fchrt: ++ . Dieser Operator steht f\u00fcr die Erh\u00f6hung des Wertes um den Summanden 1 . Er kann sowohl als Pr\u00e4fix-Operator ( ++x ) als auch als Postfix-Operator eingesetzt werden. Man spricht hier von Pr\u00e4- und Postfix- Inkrement -Operatoren. 1 2 3 4 5 int x = 5 ; System . out . println ( x ++ ); // 5 System . out . println ( x ); // 6 System . out . println ( ++ x ); // 7 System . out . println ( x ); // 7 Der Unterschied zwischen den beiden wird im obigen Beispiel deutlich. x hat nach der Initialisierung den Wert 5 . In Zeile 2 geben wir den Wert aus und erh\u00f6hen x danach um 1 . Ausgegeben wird also der Wert 5 , aber nach der Ausgabe ist der Wert um 1 erh\u00f6ht auf 6 (siehe Zeile 3 ). Bei dem Prefix-Operator (Zeile 4 ) wird der Wert erst erh\u00f6ht und dann ausgelesen. Es wird also bereits der neue Wert 7 ausgegeben. Im Prinzip entsprechen beide Operatoren aber der Anweisung x = x + 1; . Den \u00e4quivalenten Operator gibt es auch f\u00fcr die Subtraktion minus 1 . Dies wird mit dem Prefix-Operator --x; sowie mit dem Postfix-Operator x--; erreicht. Diese hei\u00dfen Pr\u00e4- und Postfix- Dekrement -Operatoren.","title":"Pr\u00e4- und Postfix-Operatoren"},{"location":"ausdruecke/#verkurzte-schreibweisen-fur-arithmetische-operatoren","text":"Aus dieser Verwendung haben sich weitere Schreibweisen etabliert: Operatoren (Beispiele) Bedeutung x+=7; x = x + 7; x-=7; x = x - 7; x*=7; x = x * 7; x/=7; x = x / 7; x%=7; x = x % 7;","title":"Verk\u00fcrzte Schreibweisen f\u00fcr arithmetische Operatoren"},{"location":"ausdruecke/#vergleichsoperatoren","text":"Werden die oben genannten Operatoren auf arithmetische Datentypen angewendet, so ist das Ergebnis selbst wieder von einem arithmetischen Datentyp ( int oder double ). Bei den folgenden Vergleichsoperatoren ist das anders. Die Operanden sind zwar auch wieder von arithmetischen Datentypen, aber das Ergebnis ist ein boolean , das hei\u00dft, der Vergleich resultiert in einem Wert true oder in einem Wert false . Vergleichsoperator Beispiel Bedeutung == x == y Vergleich auf Gleichheit. Ergibt true , wenn x den gleichen Wert hat wie y , sonst false < x < y Kleiner als. Ergibt true , wenn x einen echt kleineren Wert hat als y , sonst false > x > y Gr\u00f6\u00dfer als. Ergibt true , wenn x einen echt gr\u00f6\u00dferen Wert hat als y , sonst false < = x < = y Kleiner gleich. Ergibt true , wenn x einen kleineren als oder den gleichen Wert wie y hat, sonst false >= x >= y Gr\u00f6\u00dfer gleich. Ergibt true , wenn x einen gr\u00f6\u00dferen als oder den gleichen Wert wie y hat, sonst false != x != y Ungleich. Ergibt true , wenn x einen anderen Wert hat als y , sonst false","title":"Vergleichsoperatoren"},{"location":"ausdruecke/#wertzuweisungsoperator","text":"Einen weiteren Operator kennen wir bereits, den Wertzuweisungsoperator = . Auf der linken Seite der Zuweisung steht immer eine Variable und auf der rechten Seite ein Wert, der sich auch aus einem Ausdruck ergeben kann, z.B. int x = 5 + 6; . Dann wird x der Wert 11 zugeweisen. Beachte Der Zuweisungsoperator ist zun\u00e4chst gew\u00f6hnungsbed\u00fcrftig, denn eine Zuweisung der Form x = x+1; sieht ja aus mathematischer Sicht komisch aus, da in der Mathematik das Symbol = f\u00fcr die Gleichheit verwendet wird. In der (Java-)Programmierung hat dieses Symbol aber eine andere Bedeutung, n\u00e4mlich die Zuweisung des Wertes auf der rechten Seite zur Variablen auf der linken Seite. In der Zuweisung x = x+1; wird also erst der Wert x+1 berechnet und dieser Wert dann der Variablen x zugeordnet (die dann einen um 1 h\u00f6heren Wert hat als zuvor). Der Operator f\u00fcr die Gleichheit ist \u00fcbrigens == , wie wir gleich sehen werden.","title":"Wertzuweisungsoperator"},{"location":"ausdruecke/#logische-operatoren","text":"Die arithmetischen Operatoren werden auf Operanden angewendet, die von einem ganzzahligen Datentyp oder von einem Gleitkomma-Datentyp sind. Jetzt lernen wir Operatoren kennen, die auf Operanden vom Typ boolean angewendet werden. Nehmen wir in der folgenden Tabelle an, dass die Variablen a und b jeweils vom Typ boolean sind. Sie wurden also wie folgt deklariert: boolean a; und boolean b; . Logischer Operator Beispiel Bedeutung && a && b UND-Operator. Ergibt true , wenn a den Wert true hat UND b auch den Wert true , sonst false || a || b ODER-Operator. Ergibt true , wenn a den Wert true hat ODER b den Wert true (oder beide), sonst false ^ a ^ b EXCLUSIVES ODER. Ergibt true , wenn ENTWEDER a den Wert true hat ODER b den Wert true (aber NICHT beide), sonst false ! !a NEGATION (un\u00e4rer Operator). Ergibt true , wenn a den Wert false hat, ergibt false , wenn a den Wert true hat Es sein angemerkt, dass es f\u00fcr die Operatoren && und || jeweils auch die Operatoren & und | gibt. Das logische Prinzip ist das gleiche (also UND und ODER). Es gibt nur jeweils eine Unterscheidung und diese ist im folgenden Beispiel dargestellt: false && a // a wird nicht mehr gepr\u00fcft, Ausdruck ist false false & a // a wird gepr\u00fcft, Ausdruck ist false true || b // b wird nicht mehr gepr\u00fcft, Ausdruck ist true true | b // b wird gepr\u00fcft, Ausdruck ist true Ist beim logischen UND bereits der erste Operand false , dann kann das Ergebnis nicht mehr true sein, sondern ist false . Egal, welchen Wert der zweite Operand hat. Bei dem Operator && wird dann der zweite Operand auch gar nicht mehr gepr\u00fcft. Bei dem Operator & aber doch. && ist somit effizienter. Ist beim logischen ODER bereits der erste Operand true , dann ist das Ergebnis bereits true , egal, welchen Wert der zweite Operand hat. Bei dem Operator || wird dann der zweite Operand auch gar nicht mehr gepr\u00fcft. Bei dem Operator | aber doch. || ist somit effizienter. Wir verwenden deshalb immer && und || anstatt & und | .","title":"Logische Operatoren"},{"location":"ausdruecke/#wahrheitstabellen","text":"Hier nochmal eine Veranschaulichung der obigen logischen Operatoren in einer Wahrheitstabelle. Wir nehmen wieder an, dass die Variablen a und b jeweils vom Typ boolean sind. a b a && b a || b a ^ b !a true true true true false false true false false true true false false true false true true true false false false false false true \u00dcbung Exclusives Oder Angenommen, es g\u00e4be den Operator ^ f\u00fcr das Exclusive Oder nicht und Sie h\u00e4tten nur die Operatoren && , || und ! . Wie k\u00f6nnen Sie mit && , || und ! das exclusive Oder \"nachbauen\"?","title":"Wahrheitstabellen"},{"location":"ausdruecke/#ausdrucke-und-anweisungen","text":"Anweisungen haben wir bereits kennengelernt. Zum Beispiel sind Deklarationen Anweisungen und Initialisierungen auch. Neben Anweisungen gibt es im Programmcode auch Ausdr\u00fccke . Ausdr\u00fccke unterscheiden sich von Anweisungen dahingehened, dass sie einen Wert (genauer einen R\u00fcckgabewert ) haben. Jeder Wert in Java hat einen Typ. Wir schauen uns zun\u00e4chst die einfachsten Ausdr\u00fccke an, die es gibt, n\u00e4mlich sogenannte Literale .","title":"Ausdr\u00fccke und Anweisungen"},{"location":"ausdruecke/#literale","text":"Ein Literal ist ein konstanter Wert im Java-Quellcode. Literale sind z.B. ganze Zahlen (z.B. 123 oder -123 ), Gleikommazahlen (z.B 5.5 oder -6.0 ), Wahrheitswerte ( true oder false ), ein Character (z.B. 'a' oder 'A' ) Wir werden sp\u00e4ter noch andere Literale kennenlernen: Zeichenketten (Datentyp String ), z.B. \"Hallo FIW!\" die leere Referenz null Jedes Literal ist ein Ausdruck. Der R\u00fcckgabewert des Literals ist der Wert des Literals. Jedes Literal ist von einem konkreten Datentyp. Die folgenden Anweisungen werden auch Ausdrucksanweisung genannt, da in der Anweisung ein Ausdruck verwendet wird und der Wert dieses Ausdrucks als Nebeneffekt zum Tragen kommt (nur die ersten beiden sind Ausdrucksanweisungen - die folgenden drei sind Fehler ): int x = 123 ; // auf der rechten Seite des Zuweisungsoperators steht ein Ausdruck; // der Wert des Ausdrucks wird der Wert der Variablen x x ++ ; // x++ ist ein Ausdruck - durch das Semikolon wird der Ausdruck hier zu einer Ausdrucksanweisung x ++ // der Ausdruck selbst kann so nicht stehen (Compilerfehler) // da steht nur ein Wert mit dem nichts gemacht wird 5 + 6 // gleicher Fehler wie oben; nur ein Ausdruck, kann so nicht alleine stehen 5 + 6 ; // geht auch nicht; hier gibt es keinen Nebeneffekt (keine Zuweisung) // keine g\u00fcltige Ausdrucksanweisung Ausdr\u00fccke sind Literale Literale, die mit (passenden) Operatoren verkn\u00fcpft sind Ausdr\u00fccke, die mit passenden Operatoren verkn\u00fcpft sind","title":"Literale"},{"location":"ausdruecke/#ausdrucke-mit-operatoren","text":"Verbinden wir Literale mit Operatoren, entstehen dadurch Ausdr\u00fccke. Ausdr\u00fccke k\u00f6nnen wiederum mithilfe von Operatoren mit weiteren Literalen oder auch mit weiteren Ausdr\u00fccken verbunden werden. Beachten Sie, dass Ausdr\u00fccke immer einen Wert haben, der Wert ermittelt wird, indem der Ausdruck aufgel\u00f6st wird, d.h. die Operatoren angewendet werden. Dies erfolgt in folgender Reihenfolge: wenn runde Klammern um einen Ausdruck gesetzt sind, wird zun\u00e4chst der geklammerte Ausdruck aufgerufen, un\u00e4re (also einelementige) Operatoren binden st\u00e4rker als bin\u00e4re (also zweielementige) Operatoren, d.h. es werden zun\u00e4chst die einelementigen Operatoren angewendet, bei arithmetischen Operatoren gilt \"Punkt vor Strich-Rechnung\", bei logischen Operatoren gilt folgende Reihenfolge (st\u00e4rkere Bindung von links nach rechts) == , != -> & \u2192 ^ \u2192 | \u2192 && \u2192 || (lernen Sie das aber keinesfalls auswendig und verlassen sich dann auf Ihr Ged\u00e4chtnis, sondern verwenden Sie Klammern!) der Zuweisungsoperator ( = ) sowie += , -= , /= , *= , %= binden am schw\u00e4chsten dann erfolgt die Aufl\u00f6sung von links nach rechts Achten Sie darauf, dass Ausdr\u00fccke einen anderen Typ haben k\u00f6nnen als die Literale (bzw. Ausdr\u00fccke), die man im Ausdruck mithilfe von Operatoren miteinander verbindet, z.B. 3 == 4 ist vom Typ boolean , aber 3 und 4 sind jeweils vom Typ int . Beispiele f\u00fcr Ausdr\u00fccke sind: 5 + 6 - 8 // Ergebnis (Wert) ist ein int true && false // Ergebnis (Wert) ist ein boolean 5 < 6 // Ergebnis (Wert) ist ein boolean 7 >= 7 // Ergebnis (Wert) ist ein boolean 6 == 6 // Ergebnis (Wert) ist ein boolean 6 != 6 // Ergebnis (Wert) ist ein boolean 5.5 * 2.0 // Ergebnis (Wert) ist ein double 7.0 / 4.0 // Ergebnis (Wert) ist ein double ( 7.0 / 4.0 ) > 1.0 // Ergebnis (Wert) ist ein boolean \u00dcbung Ausdruck Angenommen, a , b und c seien vom Typ int . Was ist an diesem Ausdruck falsch: a < b < c ? Wie w\u00e4re es richtig? \u00dcbung Durchschnitt berechnen Angenommen, Sie sollen die Durchschnittsnote von folgenden Noten berechnen: 1 , 1 , 1 , 1 , 2 , 2 , 3 , 4 . Sie \u00fcberlegen sich folgendes Programm daf\u00fcr: int summe = 1 + 1 + 1 + 1 + 2 + 2 + 3 + 4 ; int anzahl = 8 ; System . out . println ( summe / anzahl ); Vom Ergebnis sind Sie aber entt\u00e4uscht. Welches Ergebnis wird ausgegeben? Welches w\u00e4re richtig gewesen? Was ist an Ihrem Programm falsch? Wie geht es besser? Bei der Verwendung des Zuweisungsoperators gibt es auf der linken Seite immer eine Variable und auf der rechten Seite immer einen Ausdruck. Bevor die Zuweisung erfolgt, wird der Wert des Ausdrucks auf der rechten Seite ausgewertet. Beispiele: int x = 0 ; // Wert von x ist 0 x = 7 + 4 / 2 ; // Wert von x ist 9 int y = 7 % 4 ; // Wert von y ist 3 x = y ++ ; // Achtung Wert von x ist 3 (Postfix); Wert von y ist 4 x = y ; // Wert von x ist 4 boolean a = ( 7 > 4 ); // Wert von a ist true a = ! a ; // Wert von a ist false a = ( a || true ); // Wert von a ist true a = !! a && true ; // Wert von a ist true Beachte Generell gilt bei der Zuweisung immer , dass der Ausdruck auf der rechten Seite erst vollst\u00e4ndig ausgerechnet wird und der berechnete Wert dann der Variablen auf der linken Seite zugewiesen wird. \"Leider\" macht der Postfix-Operator dabei eine Ausnahme . Bei diesem Operator erfolgt erst die Zuweisung und dann die Berechnung: int x = 3 ; // x hat den Wert 3 int y = x ++ ; // y hat den Wert 3 und x den Wert 4 int a = 3 ; // a hat den Wert 3 int b = a -- ; // b hat den Wert 3 und a den Wert 2 Das gilt nicht f\u00fcr den Pr\u00e4fix-Operator: int x = 3 ; // x hat den Wert 3 int y = ++ x ; // y hat den Wert 4 und x den Wert 4 int a = 3 ; // a hat den Wert 3 int b = -- a ; // b hat den Wert 2 und a den Wert 2","title":"Ausdr\u00fccke mit Operatoren"},{"location":"glossar/","text":"Glossar \u00b6 Begriff Erl\u00e4uterung Klasse Eine Klasse stellt einen Bauplan f\u00fcr einen Datentypen dar. Aus einer Klasse werden typischerweise Objekte erzeugt. Diese Objekte sind vom Typ der Klasse. Eine besondere Klasse ist die Programmklasse , die die main() -Methode enth\u00e4lt. Von manchen Klassen ist das Erzeugen von Objekten auch nicht notwendig bzw. nicht m\u00f6glich, n\u00e4mlich wenn diese Klasse nur statische Methoden neth\u00e4lt (z.B. Math oder System ). Klassen k\u00f6nnen beliebig viele Variablen ( Objektvariablen und Klassenvariablen ) sowie Methoden ( Objektmethoden und Klassenmethoden ) enthalten. Schl\u00fcsselwort Ein Schl\u00fcsselwort ist ein reserviertes Wort in der verwendeten Programmiersprache. Jedes Schl\u00fcsselwort hat eine bestimmte Bedeutung. Ein Schl\u00fcsselwort ist Teil der Syntax der Programmiersprache. Sichtbarkeitsmodifizierer Sichtbarkeitsmodifizierer (auch Zugriffsmodifizierer genannt) geben die Sichtbarkeit von Klassen, Methoden und Variablen an. Es gibt 4 Sichtbarkeitsmodifizierer: public , protected , private und default (kein Schl\u00fcsselwort). public -Elemente sind \u00f6ffentlich, d.h. jeder kann aus allen Klassen darauf zugreifen. protected Elemente sind dahingehend gesch\u00fctzt, dass auf sie nur innerhalb der Vererbungshierarchie und innerhalb des Paktes darauf zugegriffen werden kann. Der default -Modifizierer begrenzt den Zugriff auf das Paket (Paketsichtbarkeit), d.h. nur innerhalb des gleichen Paketes kann darauf zugregriffen werden. private Elemente sind am st\u00e4rksten gesch\u00fctzt. Der Zugriff kann nur innerhalb der Klasse erfolgen, ansonsten nicht. Syntax Syntax ist die formale Beschreibung, wie Programme aufgebaut sein m\u00fcssen. Wie bei der nat\u00fcrlichen Sprache auch gibt es Regeln (eine Grammatik), wie S\u00e4tze aus W\u00f6rtern aufgebaut sein m\u00fcssen. Die W\u00f6rter in Programmiersprachen sind die Schl\u00fcsselw\u00f6rter der Programmiersprache, die von der Programmiererin gew\u00e4hlten Bezeiochner , die erlaubten Literale , Operatoren und Zeichen (z.B. { , } , ( , ) , [ , ] , ;). Die Syntaxregeln besagen z.B. dass auf \u00f6ffnende Klammern immer auch schlie\u00dfende folgen m\u00fcssen, dass Bezeichner nicht mit einer Ziffer beginnen d\u00fcrfen und dass eine Anweisung mit einem Semikolon ;` enden muss. Wird gegen die Syntaxregeln versto\u00dfen, l\u00e4sst sich das Programm gar nicht compilieren. Variablendeklaration Um eine Variable zu erzeugen, muss sie deklariert werden. Dazu vergibt man einen Namen f\u00fcr die Variable und weist ihr einen Datentyp zu. Die Syntax f\u00fcr die Deklaration ist datentyp variablenName; . Eine Variable wird genau ein Mal deklariert. * Wertzuweisung* Einer Variablen kann mithilfe des Wertzuweisungsoperators = ein Wert zugewiesen werden. Die Syntax der Wertzuweisung ist variablenName = wert; . Einer Variablen kann beliebig oft ein neuer Wert zugewiesen werden. Zugriffsmodifizierer siehe Sichtbarkeitsmodifizierer","title":"Glossar"},{"location":"glossar/#glossar","text":"Begriff Erl\u00e4uterung Klasse Eine Klasse stellt einen Bauplan f\u00fcr einen Datentypen dar. Aus einer Klasse werden typischerweise Objekte erzeugt. Diese Objekte sind vom Typ der Klasse. Eine besondere Klasse ist die Programmklasse , die die main() -Methode enth\u00e4lt. Von manchen Klassen ist das Erzeugen von Objekten auch nicht notwendig bzw. nicht m\u00f6glich, n\u00e4mlich wenn diese Klasse nur statische Methoden neth\u00e4lt (z.B. Math oder System ). Klassen k\u00f6nnen beliebig viele Variablen ( Objektvariablen und Klassenvariablen ) sowie Methoden ( Objektmethoden und Klassenmethoden ) enthalten. Schl\u00fcsselwort Ein Schl\u00fcsselwort ist ein reserviertes Wort in der verwendeten Programmiersprache. Jedes Schl\u00fcsselwort hat eine bestimmte Bedeutung. Ein Schl\u00fcsselwort ist Teil der Syntax der Programmiersprache. Sichtbarkeitsmodifizierer Sichtbarkeitsmodifizierer (auch Zugriffsmodifizierer genannt) geben die Sichtbarkeit von Klassen, Methoden und Variablen an. Es gibt 4 Sichtbarkeitsmodifizierer: public , protected , private und default (kein Schl\u00fcsselwort). public -Elemente sind \u00f6ffentlich, d.h. jeder kann aus allen Klassen darauf zugreifen. protected Elemente sind dahingehend gesch\u00fctzt, dass auf sie nur innerhalb der Vererbungshierarchie und innerhalb des Paktes darauf zugegriffen werden kann. Der default -Modifizierer begrenzt den Zugriff auf das Paket (Paketsichtbarkeit), d.h. nur innerhalb des gleichen Paketes kann darauf zugregriffen werden. private Elemente sind am st\u00e4rksten gesch\u00fctzt. Der Zugriff kann nur innerhalb der Klasse erfolgen, ansonsten nicht. Syntax Syntax ist die formale Beschreibung, wie Programme aufgebaut sein m\u00fcssen. Wie bei der nat\u00fcrlichen Sprache auch gibt es Regeln (eine Grammatik), wie S\u00e4tze aus W\u00f6rtern aufgebaut sein m\u00fcssen. Die W\u00f6rter in Programmiersprachen sind die Schl\u00fcsselw\u00f6rter der Programmiersprache, die von der Programmiererin gew\u00e4hlten Bezeiochner , die erlaubten Literale , Operatoren und Zeichen (z.B. { , } , ( , ) , [ , ] , ;). Die Syntaxregeln besagen z.B. dass auf \u00f6ffnende Klammern immer auch schlie\u00dfende folgen m\u00fcssen, dass Bezeichner nicht mit einer Ziffer beginnen d\u00fcrfen und dass eine Anweisung mit einem Semikolon ;` enden muss. Wird gegen die Syntaxregeln versto\u00dfen, l\u00e4sst sich das Programm gar nicht compilieren. Variablendeklaration Um eine Variable zu erzeugen, muss sie deklariert werden. Dazu vergibt man einen Namen f\u00fcr die Variable und weist ihr einen Datentyp zu. Die Syntax f\u00fcr die Deklaration ist datentyp variablenName; . Eine Variable wird genau ein Mal deklariert. * Wertzuweisung* Einer Variablen kann mithilfe des Wertzuweisungsoperators = ein Wert zugewiesen werden. Die Syntax der Wertzuweisung ist variablenName = wert; . Einer Variablen kann beliebig oft ein neuer Wert zugewiesen werden. Zugriffsmodifizierer siehe Sichtbarkeitsmodifizierer","title":"Glossar"},{"location":"hilfsklassen/","text":"N\u00fctzliche Klassen \u00b6 In Java gibt es eine Vielzahl bereits existierender Klassen, auf die wir zugreifen k\u00f6nnen. Wir werden nach und nach einige davon kennenlernen - aber l\u00e4ngst nicht alle. Bis jetzt haben wir nur zwei Klassen direkt verwendet: die Klasse System , die uns eine Schnittstelle zu unserer Konsole (dem Standardausgabeger\u00e4t zur Verf\u00fcgung stellt - z.B. System.out.println() ) und die Klasse String , die einen Datentyp f\u00fcr Zeichenketten darstellt und daf\u00fcr auch n\u00fctzliche Methoden mitbringt, die wir uns hier mal genauer anschauen wollen. Beide Klassen geh\u00f6ren zum Paket java.lang . Dieses Paket muss nicht importiert werden, umn die Klassen daraus zu nutzen. Bei anderen Klassen, die wir im Folgenden betrachten, ist das teilweise anders. Die Klasse Scanner \u00b6 Wir k\u00f6nnen derzeit Ausgaben auf die Konsole schreiben. Wir k\u00f6nnen jedoch noch keine Eingaben t\u00e4tigen. Das wird sich mit der Verwendung der Klasse Scanner nun \u00e4ndern. Die Verwendung dieser Klasse durch uns erfolgt durch die Erzeugung eines Scanner - Objektes den Aufruf einer passenden Objektmethode , je nachdem, was wir einlesen wollen, ein int , ein double oder einen String . Erzeugen eines Scanner -Objektes \u00b6 Wir haben oben zwei begriffe verwendet, deren Bedeutung wir erst sp\u00e4ter kennenlernen: Objekt und Objektmethode . Das soll uns aber nicht aufhalten, einfach einmal ein Scanner -Objekt zu erzeugen: Scanner sc = new Scanner ( System . in ); Hierbei passiert folgendes: wir deklarieren uns eine Variable sc vom Datentyp Scanner , wir erzeugen mithilfe von new Scanner() ein neues Objekt vom Datentyp Scanner , wir \u00fcbergeben der Methode, die ein Scanner -Objekt erzeugt unser Standardeingabeger\u00e4t ( System.in ) - das ist die Konsole, d.h. wir wollen unsere Daten \u00fcber die Konsole einlesen wir weisen unser neues Objekt (genauer gesagt: eine Referenz auf unser neues Objekt) der Variablen sc zu Wenn Sie obige Anweisung z.B. in Ihre main() -Methode einf\u00fcgen, dann stellen Sie fest, dass beide Scanner rot unterstrichen sind. Die Fehlerausgabe ist Scanner cannot be resolved to a type . Das liegt daran, dass die Klasse Scanner nicht zum Standardpaket java.lang geh\u00f6rt, sondern wir sie erst importieren m\u00fcssen. Das lassen wir aber von unserer IDE erledigen. Wir w\u00e4hlen eines der vorgeschlagenen quick fixes aus, und zwar import Scanner (java.util) . Achten Sie darauf, dass dies nicht der erste Vorschlag f\u00fcr ein quick fix ist! Nachdem die entsprechende import -Anweisung ( import java.util.Scanner; ) eingef\u00fcgt wurde, ist die Fehlermeldung behoben. Das Programm k\u00f6nnte also so aussehen: 1 2 3 4 5 6 7 8 9 10 11 12 13 package themen.hilfsklassen ; import java.util.Scanner ; public class Hilfsklassen { public static void main ( String [] args ) { Scanner sc = new Scanner ( System . in ); } } Die import -Anweisung (Zeile 3 ) erfolgt au\u00dferhalb und vor der Klassendeklaration. Aufrufen der passenden Objektmethoden \u00b6 F\u00fcr ein solches Objekt vom Typ Scanner stehen eine Vielzahl von Methoden zur Verf\u00fcgung, von denen wir uns nur die folgenden anschauen wollen: next() : liest einen String ein nextInt() : liest ein int ein nextDouble() : liest ein double ein nextBoolean() : liest ein boolean ein Es sei erw\u00e4hnt, dass es auch noch nextLong() , nextFloat() , nextShort() usw. gibt. Der Aufruf einer solchen Objektmethode erfolgt stets nach dem Prinzip: referenzVariable.objektMethode () Das hei\u00dft die Variable, die eine Referenz auf das Objekt h\u00e4lt (bei uns sc ), ruft \u00fcber Punktnotation (mit einem . verbinden) die entsprechende Objektmethode auf. Wir betrachten Beispiele: 1 2 3 4 5 6 7 8 public static void main ( String [] args ) { Scanner sc = new Scanner ( System . in ); System . out . print ( \"Geben Sie eine ganze Zahl ein: \" ); int ganzeZahl = sc . nextInt (); System . out . println ( ganzeZahl ); } In Zeile 6 sehen Sie den Aufruf der Methode nextInt() f\u00fcr das sc -Objekt, also sc.nextInt() . Die Methode nextInt() gibt die eingegebene Zahl zur\u00fcck, d.h. der Aufruf der Methode entspricht einer Zahl vom Datentyp int . Diese speichern wir in obigem Beispiel in der Variablen ganzeZahl vom Typ int . Wenn Sie auf der Konsole dann eine Zahl eingeben, sieht das so aus: Was passiert, wenn Sie keine Zahl eingeben? Dann wird eine sogenannte * Exception* geworfen. Eine Exception ist ein Fehler, der zur Laufzeit passiert. Wir werden bald lernen, wie man soclhe Exceptions abf\u00e4ngt, damit es nicht einen solchen \"Systemabsturz\" gibt. Derzeit m\u00fcssen wir damit noch leben. Eine solche fehlerhafte Eingabe w\u00fcrde so aussehenen: F\u00fcr diejenigen, die es interessiert, ist hier eine Methode, die einen solchen Fehlerfall abf\u00e4ngt. Das m\u00fcssen sie jetzt aber noch nicht verstehen - es ist, wie gesagt, nur f\u00fcr eventuelles Interesse: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package themen.hilfsklassen ; import java.util.InputMismatchException ; import java.util.Scanner ; public class Hilfsklassen { public static int ganzeZahlEinlesen ( String message ) { Scanner sc = new Scanner ( System . in ); int number = 0 ; boolean inputOk = false ; do { System . out . print ( message + \": \" ); try { number = sc . nextInt (); inputOk = true ; } catch ( InputMismatchException e ) { message = \"Sie m\u00fcssen eine Zahl eingeben\" ; sc . next (); } } while ( ! inputOk ); return number ; } public static void main ( String [] args ) { int ganzeZahl = ganzeZahlEinlesen ( \"Geben Sie eine Zahl ein\" ); System . out . println ( ganzeZahl ); } } Ein m\u00f6glicher Ablauf w\u00e4re dann wie folgt: Wir gehen erstmal davon aus, dass die Eingaben korrekt erfolgen und schauen uns noch weitere Beispiele an: public static void weitereBeispiele () { Scanner sc = new Scanner ( System . in ); System . out . print ( \"int Zahl : \" ); int intNumber = sc . nextInt (); System . out . println ( intNumber ); System . out . print ( \"double Zahl : \" ); double doubleNumber = sc . nextDouble (); System . out . println ( doubleNumber ); System . out . print ( \"boolean : \" ); boolean wahrheitswert = sc . nextBoolean (); System . out . println ( wahrheitswert ); System . out . print ( \"String : \" ); String zeichenkette = sc . next (); System . out . println ( zeichenkette ); } Ein Aufruf der Methode weitereBeispiele(); (z.B. in main() ) k\u00f6nnte dann so aussehen: Beachten Sie: Bei der Eingabe einer double -Zahl m\u00fcssen Sie anstelle des Punktes ein Komma eingeben. Das h\u00e4ngt mit den l\u00e4ndertypischen Einstellungen von Eclipse zusammen. (Bei manchen ist es vielleicht ein Punkt.) Wenn Sie ein String eingeben, dann wird bei der Methode next() nur der String bis zum ersten Leerzeichen eingelesen. (Das l\u00e4sst sich \u00e4ndern, aber darauf gehen wir hier nicht n\u00e4her ein.) Success Wir k\u00f6nnen jetzt Eingaben \u00fcber unsere Konsole t\u00e4tigen! Die Klasse Math \u00b6 Die Klasse Math enth\u00e4lt viele mathematische Funktionen als Methoden. Au\u00dferdem ist in ihr z.B. die Konstante PI definiert. Um die Klasse Math zu verwenden, m\u00fcssen wir sie nicht importieren, denn sie befindet sich im Paket java.lang . Wir m\u00fcssen auch kein Objekt der Klasse erzeugen, da alle Methoden dieser Klasse Klassenmethoden (also static sind). Um eine Methode dieser Klasse aufzurufen, setzen wir vor die Methode einfach Math. . Wir schauen uns Beispiele an: double nr1 = 16.0 ; double nr2 = Math . sqrt ( nr1 ); // Quadratwurzel double nr3 = Math . PI * 3.0 ; double nr4 = Math . abs ( - 12.0 ); // absoluter Betrag double nr5 = Math . floor ( 12.3456 ); // abgeschnitten -> 12 double nr6 = Math . floor ( 12.9876 ); // abgeschnitten -> 12 double nr7 = Math . floor ( - 12.3456 ); // abgeschnitten -> -13 double nr8 = Math . floor ( - 12.9876 ); // abgeschnitten -> -13 double nr9 = Math . pow ( 2 , 5 ); // 2 hoch 5 = 32 Beachten Sie, dass floor() nicht rundet, sondern die n\u00e4chste ganze Zahl angibt, die kleiner als der Parameterwert ist. Mithilfe der Math.random() -Methode k\u00f6nnen Sie sich au\u00dferdem double -Zufallszahlen aus dem Bereich 0.0 <= zufallszahl <1.0 erzeugen lassen. Wir werden das aber meistens mithilfe der folgenden Klasse Random erledigen. Alle Methoden der Klasse Math finden Sie hier . Die Klasse Random \u00b6 Mithilfe der Klasse Random k\u00f6nnen wir Zufallszahlen erzeugen. Bei der Klasse Random ist es \u00e4hnlich wie bei Scanner : wir erzeugen uns ein Random -Objekt, die Klasse befindet sich im Paket java.util , d.h. wir m\u00fcssen sie importieren, wir w\u00e4hlen die passende Methode aus, je nachdem, von welchem Datentyp unsere Zufallszahl sein soll Ein Random -Objekt erzeugen \u00b6 Wir erzwugen uns ein Random -Objekt wie folgt Random r = new Random (); Um die Klasse Random verwenden zu k\u00f6nnen, muss sie importiert werden. Hier ein Ausschnitt aus der Klasse, in der wir neben Random auch Scanner verwenden: 1 2 3 4 5 6 7 package themen.hilfsklassen ; import java.util.Random ; import java.util.Scanner ; public class Hilfsklassen { In Zeile 3 wird die Klasse Random importiert. Objektemethoden der Klasse Random \u00b6 Die Klasse Random bietet verschiedene Methoden, um Zufallswerte der einzelnen Datentypen zu generieren: nextDouble() : erzeugt eine double -Zahl (aus dem Bereich 0.0 inklusive bis 1.0 exclusive) nextFloat() : erzeugt eine float -Zahl (aus dem Bereich 0.0 inklusive bis 1.0 exclusive) nextLong() : erzeugt eine long -Zahl (aus (fast) dem Bereich gesamten Bereich von long ) nextBoolean() : erzeugt einen boolean -Wert zuf\u00e4llig ( true oder false ) Wir betrachten jedoch haupts\u00e4chlich die Methoden, die uns zuf\u00e4llig einen int -Wert liefern: nextInt() : erzeugt eine int -Zahl aus dem gesamten Wertebereich von int - also auch negative Zahlen, nextInt(int bound) : erzeugt eine int -Zahl aus dem Bereich 0 inklusive bis bound exclusive) nextInt() \u00b6 Schauen wir uns zun\u00e4chst nextInt() an. Wir implementieren eine Methode, die uns 10 Zufallszahlen mithilfe der Methode nextInt() erzeugt und auf die Konsole ausgibt: 1 2 3 4 5 6 7 8 9 public static void printIntRandomNumbers () { Random r = new Random (); for ( int i = 0 ; i < 10 ; i ++ ) { int randomNumber = r . nextInt (); System . out . println ( randomNumber ); } } In Zeile 6 sehen wir den Aufruf der Methode nextInt() . Die Referenzvariable r zeigt auf unser Random -Objekt. F\u00fcr die Referenzvariable wird mithilfe der Punktnotation die Methode nextInt() aufgerufen, also r.nextInt(); . Diese Methode gibt eine Zufallszahl zur\u00fcck, die wir in der Variablen randomNumber speichern. Ein Aufruf der Methode printIntRandomNumbers(); z.B. in main() kann zu folgender Ausgabe f\u00fchren (das sind Zufallszahlen, also jeder Aufruf liefert andere Werte): 1362288576 1801089219 -1573362027 56087730 1015233281 1341464232 2112804572 841838154 1460116224 -910734474 nextInt(int bound) \u00b6 Die Methode nextInt() existiert auch parametrisiert, d.h. wir k\u00f6nnen ihr einen Parameterwert (vom Datentyp int ) \u00fcbergeben. Dieser Wert muss positiv sein! Wenn nicht, dann wird eine IllegalArgumentException geworfen. Die Idee dieses Parameters ist zun\u00e4chst die, dass wir den Wertebereich einschr\u00e4nken, aus dem die Zufallszahlen erzeugt werden. Angenommen, wir \u00fcbergeben eine 6 , dann werden die Zufallszahlen aus dem Bereich 0 , 1 , 2 , 3 , 4 , 5 erzeugt. F\u00fcr nextInt(bound) gilt also, dass eine Zufallszahl aus dem Bereich 0 (inklusive) bis bound (exklusive) ( 0 <= zufZahl < bound ) erzeugt wird. Wir betrachten folgendes Beispiel: 1 2 3 4 5 6 7 8 9 10 public static void printIntRandomNumbers () { Random r = new Random (); int bound = 10 ; for ( int i = 0 ; i < 10 ; i ++ ) { int randomNumber = r . nextInt ( bound ); System . out . println ( randomNumber ); } } Wir haben die gleiche Methode wie oben, nur dass wir jetzt nicht nextInt() , sondern nextInt(bound) aufrufen (Zeile 7 ). bound ist vom Typ int und hat den Wert 10 (Zeile 4 ). Ein Aufruf der Methode printIntRandomNumbers(); z.B. in main() kann zu folgender Ausgabe f\u00fchren (das sind Zufallszahlen, also jeder Aufruf liefert andere Werte): 2 8 8 6 8 2 5 9 8 3 Angenommen, wir wollen einen W\u00fcrfel implementieren. Mit dem Aufruf nextInt(6) w\u00fcrden wir Zahlen zuf\u00e4llig aus dem Bereich [0, ..., 5] erzeugen. Das w\u00e4re es noch nicht ganz. Erst, wenn wir zu der erzeugten Zufallszahl jeweils eine 1 hinzuaddieren, \"w\u00fcrfeln\" wir Zahlen aus dem Bereich [1, ..., 6] . Ein W\u00fcrfel w\u00fcrde also so implementiert werden: Random r = new Random (); int wurf = r . nextInt ( 6 ) + 1 ; // zufaellig Zahlen 1 bis 6 Eine generelle Methode, um mithilfe der Methode nextInt(bound) einen beliebigen Bereich aus dem int -Wertebereich zuf\u00e4llig abzudecken, sehe z.B. wie folgt aus: 1 2 3 4 5 6 7 public static int getRandomNumber ( int fromInclusive , int toInclusive ) { Random r = new Random (); int bound = ( toInclusive - fromInclusive ) + 1 ; // +1 wegen toInclusive soll auch int randomNumber = r . nextInt ( bound ) + fromInclusive ; return randomNumber ; } Die Methode ist nicht besonders stabil. Wir m\u00fcssten eigentlich \u00fcberpr\u00fcfen, ob toInclusive gr\u00f6\u00dfer ist als fromInclusive , aber wir wollen hier zun\u00e4chst nur das Prinzip erl\u00e4utern. Wir \"testen\" unsere Methode und schauen mal, ob wir Zufallszahlen aus dem Bereich [90, ... , 99] erzeugen: for ( int i = 0 ; i < 50 ; i ++ ) { System . out . print ( getRandomNumber ( 90 , 99 ) + \" \" ); } Eine m\u00f6gliche Ausgabe: 96 99 92 98 95 91 95 96 97 93 97 90 94 92 92 94 95 93 99 91 92 95 99 90 91 97 99 93 92 98 91 92 99 90 90 97 95 90 92 97 93 92 94 93 94 90 92 96 96 94 Noch ein \"Test\", diesmal Zahlen aus dem Bereich [-33 , ... , -10] : for ( int i = 0 ; i < 50 ; i ++ ) { System . out . print ( getRandomNumber ( - 33 , - 10 ) + \" \" ); } Eine m\u00f6gliche Ausgabe: -10 -31 -29 -29 -33 -11 -19 -15 -33 -22 -13 -15 -14 -10 -28 -27 -24 -19 -13 -26 -21 -10 -25 -16 -29 -28 -16 -18 -29 -15 -23 -26 -18 -25 -29 -19 -12 -23 -26 -22 -15 -26 -11 -16 -18 -22 -20 -12 -21 -25 Von [-10, ... , 10] geht auch: for ( int i = 0 ; i < 50 ; i ++ ) { System . out . print ( getRandomNumber ( - 10 , - 10 ) + \" \" ); } und unser W\u00fcrfel klappt auch: for ( int i = 0 ; i < 50 ; i ++ ) { System . out . print ( getRandomNumber ( 1 , 6 ) + \" \" ); } Die Klasse String \u00b6 Wir haben die Klasse String bereits bei den Datentypen betrachtet. Dort haben wir gesagt, dass String ein anderer Datentyp ist, als die Wertetypen int , boolean , double usw. Bei String handelt es sich um einen Referenztypen . Ein String ist eine Referenz auf ein Objekt. Wenn wir also so etwas haben: String str = \"Hallo FIW!\" ; dann ist str eine Referenzvariable , so wie z.B. r bei Random und sc bei Scanner . Wie bei Random und Scanner gibt es auch f\u00fcr String Methoden, die wir auf die Objekte anwenden k\u00f6nnen. Einige davon schauen wir uns im Folgenden an. Zun\u00e4chst untersuchen wir jedoch, was so ein String eigentlich intern ist. Bei einer Zeichenkette handelt es sich um ein Array aus einzelnen Zeichen, also char . Wir wissen noch nicht, was ein Array ist, aber wir bekommen hier eine Vorstellung davon. Angenommen, wir haben den obigen String ( \"Hallo FIW!\" ). Intern sieht der so aus: Ein String besteht also aus einzelnen Zeichen (vom Typ char ) und diese sind sogar automatisch \"nummeriert\". Wir haben einen sogenannten Index . Dieser Index ist eine ganze Zahl ( int ) und beginnt beim ersten Zeichen mit 0 und l\u00e4uft dann fortlaufend mit jedem Zeichen eins h\u00f6her. Betrachten wir unsere erste Methode f\u00fcr String: die Methode length() . Diese Methode gibt die L\u00e4nge eines Strings zur\u00fcck - in unserem Beispiel 10 . String str = \"Hallo FIW!\" ; System . out . println ( str . length ()); // 10 Sie k\u00f6nnen die Methode \u00fcber Punktnotation \u00fcbrigens auch direkt an das Literal anh\u00e4ngen, also so: System . out . println ( \"Hallo FIW!\" . length ()); // 10 das gilt f\u00fcr alle der folgenden Objektmethoden. Beachten Sie, dass L\u00e4nge ( length() ) eines Strings um 1 gr\u00f6\u00dfer ist als der gr\u00f6\u00dfte Indexwert. In der obigen Abbildung sehen wir, dass das Ausrufezeichen ( ! ) mit dem Index 9 nummeriert ist. Das liegt daran, dass der erste Index die 0 ist. Nun wollen wir den Index verwenden, also die \"Nummer\" jedes einzelnen Zeichens in einem String. Die Methode charAt(int index) liefrt das Zeichen eines Strings an dem Index index zur\u00fcck. Also z.B.: char c = \"Hallo FIW!\" . charAt ( 6 ); // 'F' System . out . println ( c ); // F Wir lassen uns einmal alle Zeichen einzeln eines Strings ausgeben. Dazu verwenden wir eine for -Schleife. Die Laufvariable nimmt alle Werte aus dem Index an, d.h. 0 bis kleiner als length() : String str = \"Hallo FIW!\" ; for ( int i = 0 ; i < str . length (); i ++ ) { char c = str . charAt ( i ); System . out . println ( c ); } Das erzeugt folgende Ausgabe: H a l l o F I W ! Verschl\u00fcsseln Wir wissen ja, dass char ein ganzzahliger Datentyp ist. Wir k\u00f6nnten unsere Zeichenkette jetzt verschl\u00fcsseln, indem wir einfach zu dem ASCII-Code des jeweiligen Zeichens eine 1 hinzuaddieren. Das machen wir mal: String str = \"Hallo FIW!\" ; System . out . println ( str ); // Hallo FIW! for ( int i = 0 ; i < str . length (); i ++ ) { char c = str . charAt ( i ); c ++ ; // naechstgroesserer ASCII-Code (um 1 addiert) System . out . print ( c ); // Ibmmp!GJX\" } Erzeugt folgende Ausgabe: Hallo FIW! Ibmmp!GJX \" Wir k\u00f6nnen auch einen bestimmten Index erfragen. Die Methode indexOf(char c) gibt den Index zur\u00fcck, an dem das Zeichen zum ersten Mal im String autaucht. Die Methode lastIndexOf(char c) gibt den Index zur\u00fcck, an dem das Zeichen zum letzten Mal im String autaucht. int first = \"Hallo FIW!\" . indexOf ( 'l' ); // 2 int last = \"Hallo FIW!\" . lastIndexOf ( 'l' ); // 3 System . out . println ( \"l zum ersten Mal : \" + first ); System . out . println ( \"l zum letzten Mal : \" + last ); Mithilfe des Index k\u00f6nnen wir auch Teile eines Strings extrahieren. Die Methode substring(int beginIndex) liefert den Teilstring beginnend mit dem Index beginIndex bis zum Ende des Strings zur\u00fcck. Die Methode substring(int beginIndex, int endIndex) liefert den Teilstring beginnend mit dem Index beginIndex (inklusive) bis zum Index endIndex (exklusive) zur\u00fcck. String substr1 = \"Hallo FIW!\" . substring ( 3 ); // lo FIW! String substr2 = \"Hallo FIW!\" . substring ( 3 , 7 ); // lo F System . out . println ( substr1 ); System . out . println ( substr2 ); Mithilfe der Methode toLowerCase() werden alle Buchstaben eines Strings in Kleinbuchstaben umgewandelt. Mithilfe der Methode toUpperCase() werden alle Buchstaben eines Strings in Gro\u00dfbuchstaben umgewandelt. String lower = \"Hallo FIW!\" . toLowerCase (); // hallo fiw! String upper = \"Hallo FIW!\" . toUpperCase (); // HALLO FIW! System . out . println ( lower ); System . out . println ( upper ); Um zwei Strings lexikographisch miteinander zu vergleichen, kann die Methode compareTo(String) verwendet werden. Diese gibt ein int zur\u00fcck. Wir betrachten dazu ein Beispiel: 1 2 3 int result1 = \"abc\" . compareTo ( \"abd\" ); // -1 int result2 = \"abd\" . compareTo ( \"abc\" ); // 1 int result3 = \"abc\" . compareTo ( \"abc\" ); // 0 In Zeile 1 ruft der String \"abc\" die compareTo() -Methode auf und vergleicht sich mit dem String \"abd\" . Da \"abc\" \"kleiner\" ist als \"abd\" , ist der R\u00fcckgabewert negativ -1 . In Zeile 2 ruft der String \"abd\" die compareTo() -Methode auf und vergleicht sich mit dem String \"abc\" . Da \"abd\" \"gr\u00f6\u00dfer\" ist als \"abc\" , ist der R\u00fcckgabewert positiv 1 . In Zeile 3 ruft der String \"abc\" die compareTo() -Methode auf und vergleicht sich mit dem String \"abc\" . Da beide Strings gleich sind, ist der R\u00fcckgabewert 0 . Um einen Wert von einem Wertetypen (also die primitiven Datentypen int , boolean , double usw.) in einen String umzuwandeln, stehen die Klassenmethoden valueOf() zur Verf\u00fcgung. Der Zugriff auf eine solche Methode erfolgt mittels Punktschreibweise und dem Namen der Klasse, also String.valueOf() (es handelt sich um static Methoden). Die Umwandlung erfolgt also wie folgt: String si9 = String . valueOf ( 9 ); // int --> String String si123 = String . valueOf ( 123 ); // int --> String String sb = String . valueOf ( true ); // boolean --> String String sd = String . valueOf ( 5.5 ); // double --> String format() -Methode und printf() \u00b6 In der \u00dcbung 2 sollte das kleine 1x1 einaml als Liste und einmal als Matrix ausgegeben werden. Bei beiden war die Formatierung der Ausgabe nicht besonders sch\u00f6n, da die Zahlen unterschiedliche L\u00e4ngen hatten. Sch\u00f6ner w\u00e4re es gewesen, die Ausgabe der Zahlen rechtsb\u00fcndig zu gestalten. Das geht mit der System.out.printf() -Methode. Die printf() -Methode verwendet die format() -Methode von Strings zur Formatierung der Ausgabe. Wir schauen uns zun\u00e4chst ein einf\u00fchrendes Beispiel an: 1 2 String output = String . format ( \"in %s angemeldet : %d Studentinnen\" , \"FIW\" , 44 ); System . out . println ( output ); Die format() -Methode in Zeile 1 hat drei Parameter: einen Ausgabestring, der Platzhalter enth\u00e4lt einen String \"FIW\" und eine int -Zahl 44 Der Ausgabestring enth\u00e4lt sogenannte Platzhalter , n\u00e4mlich %s f\u00fcr einen String und %d f\u00fcr ein int . Anstelle dieser Platzhalter werden die nach dem Ausgabestring aufgelisteten Werte eingef\u00fcgt, also f\u00fcr %s wird \"FIW\" eingesetzt und f\u00fcr %d die 44 . Die Ausgabe sieht dann so aus: in FIW angemeldet : 44 Studentinnen Das ist zun\u00e4chst wenig spektakul\u00e4r. Hier zun\u00e4chst eine Tabelle mit den wichtigsten Platzhaltern: Platzhalter Eingabetyp Ausgabe (String) %d int/long/... ganze Zahl %f float/double Gleitkommazahl, Standardnotation %e float/double Gleitkommazahl, wiss. Notation %s String Zeichenkette %c char Buchstabe %n Zeilenumbruch Ein Beispiel sieht also so aus: Die eigentliche Formatierung erfolgt durch die Angabe der vorgesehenen Breite f\u00fcr einen Ausgabewert und ob dieser Wert rechtsb\u00fcndig oder linksb\u00fcndig dargestellt werden soll. Die allgemeine Syntax f\u00fcr einen solchen Platzhalter ist wie folgt: % [ Schalter ] [ Breite ] . [ Genauigkeit ] Typ Dabei sind: % : Formatierungsausdruck beginnt Schalter (optional): ver\u00e4ndert das Format der Ausgabe (Minuszeichen (-) = linksb\u00fcndige Ausgabe) Breite : Anzahl der ausgegebenen Zeichen Genauigkeit (optional): Nachkommastellen Typ : Ausgabetyp ( s (String): Zeichenkette kleingeschrieben, S : Zeichenkette gro\u00dfgeschrieben, d (decimal): Ganzzahl, f (floating-point): Nachkommazahl) Dazu ein Beispiel: public static void createTable ( int rows ) { Random r = new Random (); int number1 = 0 ; int number2 = 0 ; System . out . println ( \" a | b | a + b | a - b | a * b | a / b | a % b \" ); System . out . println ( \"----------------------------------------------------------------\" ); for ( int i = 0 ; i < rows ; i ++ ) { number1 = r . nextInt ( 100 ) + 1 ; number2 = r . nextInt ( 100 ) + 1 ; System . out . printf ( \"%4d | %4d | %5d | %5d |%7d | %5d | %4d %n\" , number1 , number2 , number1 + number2 , number1 - number2 , number1 * number2 , number1 / number2 , number1 % number2 ); } } Bei Aufruf von createTable(8); erreichen wir zum Beispiel folgende Ausgabe: a | b | a + b | a - b | a * b | a / b | a % b ---------------------------------------------------------------- 4 | 39 | 43 | -35 | 156 | 0 | 4 60 | 2 | 62 | 58 | 120 | 30 | 0 93 | 60 | 153 | 33 | 5580 | 1 | 33 8 | 68 | 76 | -60 | 544 | 0 | 8 80 | 82 | 162 | -2 | 6560 | 0 | 80 31 | 10 | 41 | 21 | 310 | 3 | 1 7 | 30 | 37 | -23 | 210 | 0 | 7 54 | 12 | 66 | 42 | 648 | 4 | 6 Die Zahlen erscheinen also alle geordnet untereinander und rechtsb\u00fcndig. Wie gesagt, System.out.printf() und String.format() funktionieren exakt gleich, da printf() format() verwendet. Weitere Beispiele f\u00fcr Schalter und ihre Breitenangaben: String output ; output = String . format ( \"|%10d|\" , 1234 ); // | 1234| output = String . format ( \"|%-10d|\" , 1234 ); // |1234 | output = String . format ( \"|%010d|\" , 1234 ); // |0000001234| output = String . format ( \"|%+10d|\" , 1234 ); // | +1234| output = String . format ( \"|%,10d|\" , 1234 ); // | 1.234| output = String . format ( \"|%10.2f|\" , 1234.567 ); // | 1234,57| output = String . format ( \"|%-10.2f|\" , 1234.567 ); // |1234,57 | output = String . format ( \"|%5.2f|\" , 1234.567 ); // |1234,57| output = String . format ( \"|%15s|\" , \"Hallo FIW!\" ); // | Hallo FIW!| output = String . format ( \"|%-15s|\" , \"Hallo FIW!\" ); // |Hallo FIW! | output = String . format ( \"|%.7s|\" , \"Hallo FIW!\" ); // |Hallo F| Unsere beiden Methoden des kleinen 1x1 aus \u00dcbung 2 h\u00e4tten dann auch eine sch\u00f6nere Ausgabe: public static void printTimesTables ( int nr1 , int nr2 ) { for ( int faktor1 = 1 ; faktor1 <= nr1 ; faktor1 ++ ) { for ( int faktor2 = 1 ; faktor2 <= nr2 ; faktor2 ++ ) { int produkt = faktor1 * faktor2 ; System . out . printf ( \"%2d * %2d = %3d %n\" , faktor1 , faktor2 , produkt ); } System . out . println (); } } public static void printTimesMatrix ( int nr1 , int nr2 ) { for ( int faktor1 = 1 ; faktor1 <= nr1 ; faktor1 ++ ) { for ( int faktor2 = 1 ; faktor2 <= nr2 ; faktor2 ++ ) { int produkt = faktor1 * faktor2 ; System . out . printf ( \"%4d\" , produkt ); } System . out . println (); } } N\u00e4mlich so: ----- Aufgabe 1 ------ 1 * 1 = 1 1 * 2 = 2 1 * 3 = 3 1 * 4 = 4 1 * 5 = 5 1 * 6 = 6 1 * 7 = 7 1 * 8 = 8 1 * 9 = 9 1 * 10 = 10 2 * 1 = 2 2 * 2 = 4 2 * 3 = 6 2 * 4 = 8 2 * 5 = 10 2 * 6 = 12 2 * 7 = 14 2 * 8 = 16 2 * 9 = 18 2 * 10 = 20 3 * 1 = 3 3 * 2 = 6 3 * 3 = 9 3 * 4 = 12 3 * 5 = 15 3 * 6 = 18 3 * 7 = 21 3 * 8 = 24 3 * 9 = 27 3 * 10 = 30 4 * 1 = 4 4 * 2 = 8 4 * 3 = 12 4 * 4 = 16 4 * 5 = 20 4 * 6 = 24 4 * 7 = 28 4 * 8 = 32 4 * 9 = 36 4 * 10 = 40 5 * 1 = 5 5 * 2 = 10 5 * 3 = 15 5 * 4 = 20 5 * 5 = 25 5 * 6 = 30 5 * 7 = 35 5 * 8 = 40 5 * 9 = 45 5 * 10 = 50 6 * 1 = 6 6 * 2 = 12 6 * 3 = 18 6 * 4 = 24 6 * 5 = 30 6 * 6 = 36 6 * 7 = 42 6 * 8 = 48 6 * 9 = 54 6 * 10 = 60 7 * 1 = 7 7 * 2 = 14 7 * 3 = 21 7 * 4 = 28 7 * 5 = 35 7 * 6 = 42 7 * 7 = 49 7 * 8 = 56 7 * 9 = 63 7 * 10 = 70 8 * 1 = 8 8 * 2 = 16 8 * 3 = 24 8 * 4 = 32 8 * 5 = 40 8 * 6 = 48 8 * 7 = 56 8 * 8 = 64 8 * 9 = 72 8 * 10 = 80 9 * 1 = 9 9 * 2 = 18 9 * 3 = 27 9 * 4 = 36 9 * 5 = 45 9 * 6 = 54 9 * 7 = 63 9 * 8 = 72 9 * 9 = 81 9 * 10 = 90 10 * 1 = 10 10 * 2 = 20 10 * 3 = 30 10 * 4 = 40 10 * 5 = 50 10 * 6 = 60 10 * 7 = 70 10 * 8 = 80 10 * 9 = 90 10 * 10 = 100 ----- Aufgabe 2 ------ 1 2 3 4 5 6 7 8 9 10 2 4 6 8 10 12 14 16 18 20 3 6 9 12 15 18 21 24 27 30 4 8 12 16 20 24 28 32 36 40 5 10 15 20 25 30 35 40 45 50 6 12 18 24 30 36 42 48 54 60 7 14 21 28 35 42 49 56 63 70 8 16 24 32 40 48 56 64 72 80 9 18 27 36 45 54 63 72 81 90 10 20 30 40 50 60 70 80 90 100","title":"Hilfsklassen"},{"location":"hilfsklassen/#nutzliche-klassen","text":"In Java gibt es eine Vielzahl bereits existierender Klassen, auf die wir zugreifen k\u00f6nnen. Wir werden nach und nach einige davon kennenlernen - aber l\u00e4ngst nicht alle. Bis jetzt haben wir nur zwei Klassen direkt verwendet: die Klasse System , die uns eine Schnittstelle zu unserer Konsole (dem Standardausgabeger\u00e4t zur Verf\u00fcgung stellt - z.B. System.out.println() ) und die Klasse String , die einen Datentyp f\u00fcr Zeichenketten darstellt und daf\u00fcr auch n\u00fctzliche Methoden mitbringt, die wir uns hier mal genauer anschauen wollen. Beide Klassen geh\u00f6ren zum Paket java.lang . Dieses Paket muss nicht importiert werden, umn die Klassen daraus zu nutzen. Bei anderen Klassen, die wir im Folgenden betrachten, ist das teilweise anders.","title":"N\u00fctzliche Klassen"},{"location":"hilfsklassen/#die-klasse-scanner","text":"Wir k\u00f6nnen derzeit Ausgaben auf die Konsole schreiben. Wir k\u00f6nnen jedoch noch keine Eingaben t\u00e4tigen. Das wird sich mit der Verwendung der Klasse Scanner nun \u00e4ndern. Die Verwendung dieser Klasse durch uns erfolgt durch die Erzeugung eines Scanner - Objektes den Aufruf einer passenden Objektmethode , je nachdem, was wir einlesen wollen, ein int , ein double oder einen String .","title":"Die Klasse Scanner"},{"location":"hilfsklassen/#erzeugen-eines-scanner-objektes","text":"Wir haben oben zwei begriffe verwendet, deren Bedeutung wir erst sp\u00e4ter kennenlernen: Objekt und Objektmethode . Das soll uns aber nicht aufhalten, einfach einmal ein Scanner -Objekt zu erzeugen: Scanner sc = new Scanner ( System . in ); Hierbei passiert folgendes: wir deklarieren uns eine Variable sc vom Datentyp Scanner , wir erzeugen mithilfe von new Scanner() ein neues Objekt vom Datentyp Scanner , wir \u00fcbergeben der Methode, die ein Scanner -Objekt erzeugt unser Standardeingabeger\u00e4t ( System.in ) - das ist die Konsole, d.h. wir wollen unsere Daten \u00fcber die Konsole einlesen wir weisen unser neues Objekt (genauer gesagt: eine Referenz auf unser neues Objekt) der Variablen sc zu Wenn Sie obige Anweisung z.B. in Ihre main() -Methode einf\u00fcgen, dann stellen Sie fest, dass beide Scanner rot unterstrichen sind. Die Fehlerausgabe ist Scanner cannot be resolved to a type . Das liegt daran, dass die Klasse Scanner nicht zum Standardpaket java.lang geh\u00f6rt, sondern wir sie erst importieren m\u00fcssen. Das lassen wir aber von unserer IDE erledigen. Wir w\u00e4hlen eines der vorgeschlagenen quick fixes aus, und zwar import Scanner (java.util) . Achten Sie darauf, dass dies nicht der erste Vorschlag f\u00fcr ein quick fix ist! Nachdem die entsprechende import -Anweisung ( import java.util.Scanner; ) eingef\u00fcgt wurde, ist die Fehlermeldung behoben. Das Programm k\u00f6nnte also so aussehen: 1 2 3 4 5 6 7 8 9 10 11 12 13 package themen.hilfsklassen ; import java.util.Scanner ; public class Hilfsklassen { public static void main ( String [] args ) { Scanner sc = new Scanner ( System . in ); } } Die import -Anweisung (Zeile 3 ) erfolgt au\u00dferhalb und vor der Klassendeklaration.","title":"Erzeugen eines Scanner-Objektes"},{"location":"hilfsklassen/#aufrufen-der-passenden-objektmethoden","text":"F\u00fcr ein solches Objekt vom Typ Scanner stehen eine Vielzahl von Methoden zur Verf\u00fcgung, von denen wir uns nur die folgenden anschauen wollen: next() : liest einen String ein nextInt() : liest ein int ein nextDouble() : liest ein double ein nextBoolean() : liest ein boolean ein Es sei erw\u00e4hnt, dass es auch noch nextLong() , nextFloat() , nextShort() usw. gibt. Der Aufruf einer solchen Objektmethode erfolgt stets nach dem Prinzip: referenzVariable.objektMethode () Das hei\u00dft die Variable, die eine Referenz auf das Objekt h\u00e4lt (bei uns sc ), ruft \u00fcber Punktnotation (mit einem . verbinden) die entsprechende Objektmethode auf. Wir betrachten Beispiele: 1 2 3 4 5 6 7 8 public static void main ( String [] args ) { Scanner sc = new Scanner ( System . in ); System . out . print ( \"Geben Sie eine ganze Zahl ein: \" ); int ganzeZahl = sc . nextInt (); System . out . println ( ganzeZahl ); } In Zeile 6 sehen Sie den Aufruf der Methode nextInt() f\u00fcr das sc -Objekt, also sc.nextInt() . Die Methode nextInt() gibt die eingegebene Zahl zur\u00fcck, d.h. der Aufruf der Methode entspricht einer Zahl vom Datentyp int . Diese speichern wir in obigem Beispiel in der Variablen ganzeZahl vom Typ int . Wenn Sie auf der Konsole dann eine Zahl eingeben, sieht das so aus: Was passiert, wenn Sie keine Zahl eingeben? Dann wird eine sogenannte * Exception* geworfen. Eine Exception ist ein Fehler, der zur Laufzeit passiert. Wir werden bald lernen, wie man soclhe Exceptions abf\u00e4ngt, damit es nicht einen solchen \"Systemabsturz\" gibt. Derzeit m\u00fcssen wir damit noch leben. Eine solche fehlerhafte Eingabe w\u00fcrde so aussehenen: F\u00fcr diejenigen, die es interessiert, ist hier eine Methode, die einen solchen Fehlerfall abf\u00e4ngt. Das m\u00fcssen sie jetzt aber noch nicht verstehen - es ist, wie gesagt, nur f\u00fcr eventuelles Interesse: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package themen.hilfsklassen ; import java.util.InputMismatchException ; import java.util.Scanner ; public class Hilfsklassen { public static int ganzeZahlEinlesen ( String message ) { Scanner sc = new Scanner ( System . in ); int number = 0 ; boolean inputOk = false ; do { System . out . print ( message + \": \" ); try { number = sc . nextInt (); inputOk = true ; } catch ( InputMismatchException e ) { message = \"Sie m\u00fcssen eine Zahl eingeben\" ; sc . next (); } } while ( ! inputOk ); return number ; } public static void main ( String [] args ) { int ganzeZahl = ganzeZahlEinlesen ( \"Geben Sie eine Zahl ein\" ); System . out . println ( ganzeZahl ); } } Ein m\u00f6glicher Ablauf w\u00e4re dann wie folgt: Wir gehen erstmal davon aus, dass die Eingaben korrekt erfolgen und schauen uns noch weitere Beispiele an: public static void weitereBeispiele () { Scanner sc = new Scanner ( System . in ); System . out . print ( \"int Zahl : \" ); int intNumber = sc . nextInt (); System . out . println ( intNumber ); System . out . print ( \"double Zahl : \" ); double doubleNumber = sc . nextDouble (); System . out . println ( doubleNumber ); System . out . print ( \"boolean : \" ); boolean wahrheitswert = sc . nextBoolean (); System . out . println ( wahrheitswert ); System . out . print ( \"String : \" ); String zeichenkette = sc . next (); System . out . println ( zeichenkette ); } Ein Aufruf der Methode weitereBeispiele(); (z.B. in main() ) k\u00f6nnte dann so aussehen: Beachten Sie: Bei der Eingabe einer double -Zahl m\u00fcssen Sie anstelle des Punktes ein Komma eingeben. Das h\u00e4ngt mit den l\u00e4ndertypischen Einstellungen von Eclipse zusammen. (Bei manchen ist es vielleicht ein Punkt.) Wenn Sie ein String eingeben, dann wird bei der Methode next() nur der String bis zum ersten Leerzeichen eingelesen. (Das l\u00e4sst sich \u00e4ndern, aber darauf gehen wir hier nicht n\u00e4her ein.) Success Wir k\u00f6nnen jetzt Eingaben \u00fcber unsere Konsole t\u00e4tigen!","title":"Aufrufen der passenden Objektmethoden"},{"location":"hilfsklassen/#die-klasse-math","text":"Die Klasse Math enth\u00e4lt viele mathematische Funktionen als Methoden. Au\u00dferdem ist in ihr z.B. die Konstante PI definiert. Um die Klasse Math zu verwenden, m\u00fcssen wir sie nicht importieren, denn sie befindet sich im Paket java.lang . Wir m\u00fcssen auch kein Objekt der Klasse erzeugen, da alle Methoden dieser Klasse Klassenmethoden (also static sind). Um eine Methode dieser Klasse aufzurufen, setzen wir vor die Methode einfach Math. . Wir schauen uns Beispiele an: double nr1 = 16.0 ; double nr2 = Math . sqrt ( nr1 ); // Quadratwurzel double nr3 = Math . PI * 3.0 ; double nr4 = Math . abs ( - 12.0 ); // absoluter Betrag double nr5 = Math . floor ( 12.3456 ); // abgeschnitten -> 12 double nr6 = Math . floor ( 12.9876 ); // abgeschnitten -> 12 double nr7 = Math . floor ( - 12.3456 ); // abgeschnitten -> -13 double nr8 = Math . floor ( - 12.9876 ); // abgeschnitten -> -13 double nr9 = Math . pow ( 2 , 5 ); // 2 hoch 5 = 32 Beachten Sie, dass floor() nicht rundet, sondern die n\u00e4chste ganze Zahl angibt, die kleiner als der Parameterwert ist. Mithilfe der Math.random() -Methode k\u00f6nnen Sie sich au\u00dferdem double -Zufallszahlen aus dem Bereich 0.0 <= zufallszahl <1.0 erzeugen lassen. Wir werden das aber meistens mithilfe der folgenden Klasse Random erledigen. Alle Methoden der Klasse Math finden Sie hier .","title":"Die Klasse Math"},{"location":"hilfsklassen/#die-klasse-random","text":"Mithilfe der Klasse Random k\u00f6nnen wir Zufallszahlen erzeugen. Bei der Klasse Random ist es \u00e4hnlich wie bei Scanner : wir erzeugen uns ein Random -Objekt, die Klasse befindet sich im Paket java.util , d.h. wir m\u00fcssen sie importieren, wir w\u00e4hlen die passende Methode aus, je nachdem, von welchem Datentyp unsere Zufallszahl sein soll","title":"Die Klasse Random"},{"location":"hilfsklassen/#ein-random-objekt-erzeugen","text":"Wir erzwugen uns ein Random -Objekt wie folgt Random r = new Random (); Um die Klasse Random verwenden zu k\u00f6nnen, muss sie importiert werden. Hier ein Ausschnitt aus der Klasse, in der wir neben Random auch Scanner verwenden: 1 2 3 4 5 6 7 package themen.hilfsklassen ; import java.util.Random ; import java.util.Scanner ; public class Hilfsklassen { In Zeile 3 wird die Klasse Random importiert.","title":"Ein Random-Objekt erzeugen"},{"location":"hilfsklassen/#objektemethoden-der-klasse-random","text":"Die Klasse Random bietet verschiedene Methoden, um Zufallswerte der einzelnen Datentypen zu generieren: nextDouble() : erzeugt eine double -Zahl (aus dem Bereich 0.0 inklusive bis 1.0 exclusive) nextFloat() : erzeugt eine float -Zahl (aus dem Bereich 0.0 inklusive bis 1.0 exclusive) nextLong() : erzeugt eine long -Zahl (aus (fast) dem Bereich gesamten Bereich von long ) nextBoolean() : erzeugt einen boolean -Wert zuf\u00e4llig ( true oder false ) Wir betrachten jedoch haupts\u00e4chlich die Methoden, die uns zuf\u00e4llig einen int -Wert liefern: nextInt() : erzeugt eine int -Zahl aus dem gesamten Wertebereich von int - also auch negative Zahlen, nextInt(int bound) : erzeugt eine int -Zahl aus dem Bereich 0 inklusive bis bound exclusive)","title":"Objektemethoden der Klasse Random"},{"location":"hilfsklassen/#nextint","text":"Schauen wir uns zun\u00e4chst nextInt() an. Wir implementieren eine Methode, die uns 10 Zufallszahlen mithilfe der Methode nextInt() erzeugt und auf die Konsole ausgibt: 1 2 3 4 5 6 7 8 9 public static void printIntRandomNumbers () { Random r = new Random (); for ( int i = 0 ; i < 10 ; i ++ ) { int randomNumber = r . nextInt (); System . out . println ( randomNumber ); } } In Zeile 6 sehen wir den Aufruf der Methode nextInt() . Die Referenzvariable r zeigt auf unser Random -Objekt. F\u00fcr die Referenzvariable wird mithilfe der Punktnotation die Methode nextInt() aufgerufen, also r.nextInt(); . Diese Methode gibt eine Zufallszahl zur\u00fcck, die wir in der Variablen randomNumber speichern. Ein Aufruf der Methode printIntRandomNumbers(); z.B. in main() kann zu folgender Ausgabe f\u00fchren (das sind Zufallszahlen, also jeder Aufruf liefert andere Werte): 1362288576 1801089219 -1573362027 56087730 1015233281 1341464232 2112804572 841838154 1460116224 -910734474","title":"nextInt()"},{"location":"hilfsklassen/#nextintint-bound","text":"Die Methode nextInt() existiert auch parametrisiert, d.h. wir k\u00f6nnen ihr einen Parameterwert (vom Datentyp int ) \u00fcbergeben. Dieser Wert muss positiv sein! Wenn nicht, dann wird eine IllegalArgumentException geworfen. Die Idee dieses Parameters ist zun\u00e4chst die, dass wir den Wertebereich einschr\u00e4nken, aus dem die Zufallszahlen erzeugt werden. Angenommen, wir \u00fcbergeben eine 6 , dann werden die Zufallszahlen aus dem Bereich 0 , 1 , 2 , 3 , 4 , 5 erzeugt. F\u00fcr nextInt(bound) gilt also, dass eine Zufallszahl aus dem Bereich 0 (inklusive) bis bound (exklusive) ( 0 <= zufZahl < bound ) erzeugt wird. Wir betrachten folgendes Beispiel: 1 2 3 4 5 6 7 8 9 10 public static void printIntRandomNumbers () { Random r = new Random (); int bound = 10 ; for ( int i = 0 ; i < 10 ; i ++ ) { int randomNumber = r . nextInt ( bound ); System . out . println ( randomNumber ); } } Wir haben die gleiche Methode wie oben, nur dass wir jetzt nicht nextInt() , sondern nextInt(bound) aufrufen (Zeile 7 ). bound ist vom Typ int und hat den Wert 10 (Zeile 4 ). Ein Aufruf der Methode printIntRandomNumbers(); z.B. in main() kann zu folgender Ausgabe f\u00fchren (das sind Zufallszahlen, also jeder Aufruf liefert andere Werte): 2 8 8 6 8 2 5 9 8 3 Angenommen, wir wollen einen W\u00fcrfel implementieren. Mit dem Aufruf nextInt(6) w\u00fcrden wir Zahlen zuf\u00e4llig aus dem Bereich [0, ..., 5] erzeugen. Das w\u00e4re es noch nicht ganz. Erst, wenn wir zu der erzeugten Zufallszahl jeweils eine 1 hinzuaddieren, \"w\u00fcrfeln\" wir Zahlen aus dem Bereich [1, ..., 6] . Ein W\u00fcrfel w\u00fcrde also so implementiert werden: Random r = new Random (); int wurf = r . nextInt ( 6 ) + 1 ; // zufaellig Zahlen 1 bis 6 Eine generelle Methode, um mithilfe der Methode nextInt(bound) einen beliebigen Bereich aus dem int -Wertebereich zuf\u00e4llig abzudecken, sehe z.B. wie folgt aus: 1 2 3 4 5 6 7 public static int getRandomNumber ( int fromInclusive , int toInclusive ) { Random r = new Random (); int bound = ( toInclusive - fromInclusive ) + 1 ; // +1 wegen toInclusive soll auch int randomNumber = r . nextInt ( bound ) + fromInclusive ; return randomNumber ; } Die Methode ist nicht besonders stabil. Wir m\u00fcssten eigentlich \u00fcberpr\u00fcfen, ob toInclusive gr\u00f6\u00dfer ist als fromInclusive , aber wir wollen hier zun\u00e4chst nur das Prinzip erl\u00e4utern. Wir \"testen\" unsere Methode und schauen mal, ob wir Zufallszahlen aus dem Bereich [90, ... , 99] erzeugen: for ( int i = 0 ; i < 50 ; i ++ ) { System . out . print ( getRandomNumber ( 90 , 99 ) + \" \" ); } Eine m\u00f6gliche Ausgabe: 96 99 92 98 95 91 95 96 97 93 97 90 94 92 92 94 95 93 99 91 92 95 99 90 91 97 99 93 92 98 91 92 99 90 90 97 95 90 92 97 93 92 94 93 94 90 92 96 96 94 Noch ein \"Test\", diesmal Zahlen aus dem Bereich [-33 , ... , -10] : for ( int i = 0 ; i < 50 ; i ++ ) { System . out . print ( getRandomNumber ( - 33 , - 10 ) + \" \" ); } Eine m\u00f6gliche Ausgabe: -10 -31 -29 -29 -33 -11 -19 -15 -33 -22 -13 -15 -14 -10 -28 -27 -24 -19 -13 -26 -21 -10 -25 -16 -29 -28 -16 -18 -29 -15 -23 -26 -18 -25 -29 -19 -12 -23 -26 -22 -15 -26 -11 -16 -18 -22 -20 -12 -21 -25 Von [-10, ... , 10] geht auch: for ( int i = 0 ; i < 50 ; i ++ ) { System . out . print ( getRandomNumber ( - 10 , - 10 ) + \" \" ); } und unser W\u00fcrfel klappt auch: for ( int i = 0 ; i < 50 ; i ++ ) { System . out . print ( getRandomNumber ( 1 , 6 ) + \" \" ); }","title":"nextInt(int bound)"},{"location":"hilfsklassen/#die-klasse-string","text":"Wir haben die Klasse String bereits bei den Datentypen betrachtet. Dort haben wir gesagt, dass String ein anderer Datentyp ist, als die Wertetypen int , boolean , double usw. Bei String handelt es sich um einen Referenztypen . Ein String ist eine Referenz auf ein Objekt. Wenn wir also so etwas haben: String str = \"Hallo FIW!\" ; dann ist str eine Referenzvariable , so wie z.B. r bei Random und sc bei Scanner . Wie bei Random und Scanner gibt es auch f\u00fcr String Methoden, die wir auf die Objekte anwenden k\u00f6nnen. Einige davon schauen wir uns im Folgenden an. Zun\u00e4chst untersuchen wir jedoch, was so ein String eigentlich intern ist. Bei einer Zeichenkette handelt es sich um ein Array aus einzelnen Zeichen, also char . Wir wissen noch nicht, was ein Array ist, aber wir bekommen hier eine Vorstellung davon. Angenommen, wir haben den obigen String ( \"Hallo FIW!\" ). Intern sieht der so aus: Ein String besteht also aus einzelnen Zeichen (vom Typ char ) und diese sind sogar automatisch \"nummeriert\". Wir haben einen sogenannten Index . Dieser Index ist eine ganze Zahl ( int ) und beginnt beim ersten Zeichen mit 0 und l\u00e4uft dann fortlaufend mit jedem Zeichen eins h\u00f6her. Betrachten wir unsere erste Methode f\u00fcr String: die Methode length() . Diese Methode gibt die L\u00e4nge eines Strings zur\u00fcck - in unserem Beispiel 10 . String str = \"Hallo FIW!\" ; System . out . println ( str . length ()); // 10 Sie k\u00f6nnen die Methode \u00fcber Punktnotation \u00fcbrigens auch direkt an das Literal anh\u00e4ngen, also so: System . out . println ( \"Hallo FIW!\" . length ()); // 10 das gilt f\u00fcr alle der folgenden Objektmethoden. Beachten Sie, dass L\u00e4nge ( length() ) eines Strings um 1 gr\u00f6\u00dfer ist als der gr\u00f6\u00dfte Indexwert. In der obigen Abbildung sehen wir, dass das Ausrufezeichen ( ! ) mit dem Index 9 nummeriert ist. Das liegt daran, dass der erste Index die 0 ist. Nun wollen wir den Index verwenden, also die \"Nummer\" jedes einzelnen Zeichens in einem String. Die Methode charAt(int index) liefrt das Zeichen eines Strings an dem Index index zur\u00fcck. Also z.B.: char c = \"Hallo FIW!\" . charAt ( 6 ); // 'F' System . out . println ( c ); // F Wir lassen uns einmal alle Zeichen einzeln eines Strings ausgeben. Dazu verwenden wir eine for -Schleife. Die Laufvariable nimmt alle Werte aus dem Index an, d.h. 0 bis kleiner als length() : String str = \"Hallo FIW!\" ; for ( int i = 0 ; i < str . length (); i ++ ) { char c = str . charAt ( i ); System . out . println ( c ); } Das erzeugt folgende Ausgabe: H a l l o F I W ! Verschl\u00fcsseln Wir wissen ja, dass char ein ganzzahliger Datentyp ist. Wir k\u00f6nnten unsere Zeichenkette jetzt verschl\u00fcsseln, indem wir einfach zu dem ASCII-Code des jeweiligen Zeichens eine 1 hinzuaddieren. Das machen wir mal: String str = \"Hallo FIW!\" ; System . out . println ( str ); // Hallo FIW! for ( int i = 0 ; i < str . length (); i ++ ) { char c = str . charAt ( i ); c ++ ; // naechstgroesserer ASCII-Code (um 1 addiert) System . out . print ( c ); // Ibmmp!GJX\" } Erzeugt folgende Ausgabe: Hallo FIW! Ibmmp!GJX \" Wir k\u00f6nnen auch einen bestimmten Index erfragen. Die Methode indexOf(char c) gibt den Index zur\u00fcck, an dem das Zeichen zum ersten Mal im String autaucht. Die Methode lastIndexOf(char c) gibt den Index zur\u00fcck, an dem das Zeichen zum letzten Mal im String autaucht. int first = \"Hallo FIW!\" . indexOf ( 'l' ); // 2 int last = \"Hallo FIW!\" . lastIndexOf ( 'l' ); // 3 System . out . println ( \"l zum ersten Mal : \" + first ); System . out . println ( \"l zum letzten Mal : \" + last ); Mithilfe des Index k\u00f6nnen wir auch Teile eines Strings extrahieren. Die Methode substring(int beginIndex) liefert den Teilstring beginnend mit dem Index beginIndex bis zum Ende des Strings zur\u00fcck. Die Methode substring(int beginIndex, int endIndex) liefert den Teilstring beginnend mit dem Index beginIndex (inklusive) bis zum Index endIndex (exklusive) zur\u00fcck. String substr1 = \"Hallo FIW!\" . substring ( 3 ); // lo FIW! String substr2 = \"Hallo FIW!\" . substring ( 3 , 7 ); // lo F System . out . println ( substr1 ); System . out . println ( substr2 ); Mithilfe der Methode toLowerCase() werden alle Buchstaben eines Strings in Kleinbuchstaben umgewandelt. Mithilfe der Methode toUpperCase() werden alle Buchstaben eines Strings in Gro\u00dfbuchstaben umgewandelt. String lower = \"Hallo FIW!\" . toLowerCase (); // hallo fiw! String upper = \"Hallo FIW!\" . toUpperCase (); // HALLO FIW! System . out . println ( lower ); System . out . println ( upper ); Um zwei Strings lexikographisch miteinander zu vergleichen, kann die Methode compareTo(String) verwendet werden. Diese gibt ein int zur\u00fcck. Wir betrachten dazu ein Beispiel: 1 2 3 int result1 = \"abc\" . compareTo ( \"abd\" ); // -1 int result2 = \"abd\" . compareTo ( \"abc\" ); // 1 int result3 = \"abc\" . compareTo ( \"abc\" ); // 0 In Zeile 1 ruft der String \"abc\" die compareTo() -Methode auf und vergleicht sich mit dem String \"abd\" . Da \"abc\" \"kleiner\" ist als \"abd\" , ist der R\u00fcckgabewert negativ -1 . In Zeile 2 ruft der String \"abd\" die compareTo() -Methode auf und vergleicht sich mit dem String \"abc\" . Da \"abd\" \"gr\u00f6\u00dfer\" ist als \"abc\" , ist der R\u00fcckgabewert positiv 1 . In Zeile 3 ruft der String \"abc\" die compareTo() -Methode auf und vergleicht sich mit dem String \"abc\" . Da beide Strings gleich sind, ist der R\u00fcckgabewert 0 . Um einen Wert von einem Wertetypen (also die primitiven Datentypen int , boolean , double usw.) in einen String umzuwandeln, stehen die Klassenmethoden valueOf() zur Verf\u00fcgung. Der Zugriff auf eine solche Methode erfolgt mittels Punktschreibweise und dem Namen der Klasse, also String.valueOf() (es handelt sich um static Methoden). Die Umwandlung erfolgt also wie folgt: String si9 = String . valueOf ( 9 ); // int --> String String si123 = String . valueOf ( 123 ); // int --> String String sb = String . valueOf ( true ); // boolean --> String String sd = String . valueOf ( 5.5 ); // double --> String","title":"Die Klasse String"},{"location":"hilfsklassen/#format-methode-und-printf","text":"In der \u00dcbung 2 sollte das kleine 1x1 einaml als Liste und einmal als Matrix ausgegeben werden. Bei beiden war die Formatierung der Ausgabe nicht besonders sch\u00f6n, da die Zahlen unterschiedliche L\u00e4ngen hatten. Sch\u00f6ner w\u00e4re es gewesen, die Ausgabe der Zahlen rechtsb\u00fcndig zu gestalten. Das geht mit der System.out.printf() -Methode. Die printf() -Methode verwendet die format() -Methode von Strings zur Formatierung der Ausgabe. Wir schauen uns zun\u00e4chst ein einf\u00fchrendes Beispiel an: 1 2 String output = String . format ( \"in %s angemeldet : %d Studentinnen\" , \"FIW\" , 44 ); System . out . println ( output ); Die format() -Methode in Zeile 1 hat drei Parameter: einen Ausgabestring, der Platzhalter enth\u00e4lt einen String \"FIW\" und eine int -Zahl 44 Der Ausgabestring enth\u00e4lt sogenannte Platzhalter , n\u00e4mlich %s f\u00fcr einen String und %d f\u00fcr ein int . Anstelle dieser Platzhalter werden die nach dem Ausgabestring aufgelisteten Werte eingef\u00fcgt, also f\u00fcr %s wird \"FIW\" eingesetzt und f\u00fcr %d die 44 . Die Ausgabe sieht dann so aus: in FIW angemeldet : 44 Studentinnen Das ist zun\u00e4chst wenig spektakul\u00e4r. Hier zun\u00e4chst eine Tabelle mit den wichtigsten Platzhaltern: Platzhalter Eingabetyp Ausgabe (String) %d int/long/... ganze Zahl %f float/double Gleitkommazahl, Standardnotation %e float/double Gleitkommazahl, wiss. Notation %s String Zeichenkette %c char Buchstabe %n Zeilenumbruch Ein Beispiel sieht also so aus: Die eigentliche Formatierung erfolgt durch die Angabe der vorgesehenen Breite f\u00fcr einen Ausgabewert und ob dieser Wert rechtsb\u00fcndig oder linksb\u00fcndig dargestellt werden soll. Die allgemeine Syntax f\u00fcr einen solchen Platzhalter ist wie folgt: % [ Schalter ] [ Breite ] . [ Genauigkeit ] Typ Dabei sind: % : Formatierungsausdruck beginnt Schalter (optional): ver\u00e4ndert das Format der Ausgabe (Minuszeichen (-) = linksb\u00fcndige Ausgabe) Breite : Anzahl der ausgegebenen Zeichen Genauigkeit (optional): Nachkommastellen Typ : Ausgabetyp ( s (String): Zeichenkette kleingeschrieben, S : Zeichenkette gro\u00dfgeschrieben, d (decimal): Ganzzahl, f (floating-point): Nachkommazahl) Dazu ein Beispiel: public static void createTable ( int rows ) { Random r = new Random (); int number1 = 0 ; int number2 = 0 ; System . out . println ( \" a | b | a + b | a - b | a * b | a / b | a % b \" ); System . out . println ( \"----------------------------------------------------------------\" ); for ( int i = 0 ; i < rows ; i ++ ) { number1 = r . nextInt ( 100 ) + 1 ; number2 = r . nextInt ( 100 ) + 1 ; System . out . printf ( \"%4d | %4d | %5d | %5d |%7d | %5d | %4d %n\" , number1 , number2 , number1 + number2 , number1 - number2 , number1 * number2 , number1 / number2 , number1 % number2 ); } } Bei Aufruf von createTable(8); erreichen wir zum Beispiel folgende Ausgabe: a | b | a + b | a - b | a * b | a / b | a % b ---------------------------------------------------------------- 4 | 39 | 43 | -35 | 156 | 0 | 4 60 | 2 | 62 | 58 | 120 | 30 | 0 93 | 60 | 153 | 33 | 5580 | 1 | 33 8 | 68 | 76 | -60 | 544 | 0 | 8 80 | 82 | 162 | -2 | 6560 | 0 | 80 31 | 10 | 41 | 21 | 310 | 3 | 1 7 | 30 | 37 | -23 | 210 | 0 | 7 54 | 12 | 66 | 42 | 648 | 4 | 6 Die Zahlen erscheinen also alle geordnet untereinander und rechtsb\u00fcndig. Wie gesagt, System.out.printf() und String.format() funktionieren exakt gleich, da printf() format() verwendet. Weitere Beispiele f\u00fcr Schalter und ihre Breitenangaben: String output ; output = String . format ( \"|%10d|\" , 1234 ); // | 1234| output = String . format ( \"|%-10d|\" , 1234 ); // |1234 | output = String . format ( \"|%010d|\" , 1234 ); // |0000001234| output = String . format ( \"|%+10d|\" , 1234 ); // | +1234| output = String . format ( \"|%,10d|\" , 1234 ); // | 1.234| output = String . format ( \"|%10.2f|\" , 1234.567 ); // | 1234,57| output = String . format ( \"|%-10.2f|\" , 1234.567 ); // |1234,57 | output = String . format ( \"|%5.2f|\" , 1234.567 ); // |1234,57| output = String . format ( \"|%15s|\" , \"Hallo FIW!\" ); // | Hallo FIW!| output = String . format ( \"|%-15s|\" , \"Hallo FIW!\" ); // |Hallo FIW! | output = String . format ( \"|%.7s|\" , \"Hallo FIW!\" ); // |Hallo F| Unsere beiden Methoden des kleinen 1x1 aus \u00dcbung 2 h\u00e4tten dann auch eine sch\u00f6nere Ausgabe: public static void printTimesTables ( int nr1 , int nr2 ) { for ( int faktor1 = 1 ; faktor1 <= nr1 ; faktor1 ++ ) { for ( int faktor2 = 1 ; faktor2 <= nr2 ; faktor2 ++ ) { int produkt = faktor1 * faktor2 ; System . out . printf ( \"%2d * %2d = %3d %n\" , faktor1 , faktor2 , produkt ); } System . out . println (); } } public static void printTimesMatrix ( int nr1 , int nr2 ) { for ( int faktor1 = 1 ; faktor1 <= nr1 ; faktor1 ++ ) { for ( int faktor2 = 1 ; faktor2 <= nr2 ; faktor2 ++ ) { int produkt = faktor1 * faktor2 ; System . out . printf ( \"%4d\" , produkt ); } System . out . println (); } } N\u00e4mlich so: ----- Aufgabe 1 ------ 1 * 1 = 1 1 * 2 = 2 1 * 3 = 3 1 * 4 = 4 1 * 5 = 5 1 * 6 = 6 1 * 7 = 7 1 * 8 = 8 1 * 9 = 9 1 * 10 = 10 2 * 1 = 2 2 * 2 = 4 2 * 3 = 6 2 * 4 = 8 2 * 5 = 10 2 * 6 = 12 2 * 7 = 14 2 * 8 = 16 2 * 9 = 18 2 * 10 = 20 3 * 1 = 3 3 * 2 = 6 3 * 3 = 9 3 * 4 = 12 3 * 5 = 15 3 * 6 = 18 3 * 7 = 21 3 * 8 = 24 3 * 9 = 27 3 * 10 = 30 4 * 1 = 4 4 * 2 = 8 4 * 3 = 12 4 * 4 = 16 4 * 5 = 20 4 * 6 = 24 4 * 7 = 28 4 * 8 = 32 4 * 9 = 36 4 * 10 = 40 5 * 1 = 5 5 * 2 = 10 5 * 3 = 15 5 * 4 = 20 5 * 5 = 25 5 * 6 = 30 5 * 7 = 35 5 * 8 = 40 5 * 9 = 45 5 * 10 = 50 6 * 1 = 6 6 * 2 = 12 6 * 3 = 18 6 * 4 = 24 6 * 5 = 30 6 * 6 = 36 6 * 7 = 42 6 * 8 = 48 6 * 9 = 54 6 * 10 = 60 7 * 1 = 7 7 * 2 = 14 7 * 3 = 21 7 * 4 = 28 7 * 5 = 35 7 * 6 = 42 7 * 7 = 49 7 * 8 = 56 7 * 9 = 63 7 * 10 = 70 8 * 1 = 8 8 * 2 = 16 8 * 3 = 24 8 * 4 = 32 8 * 5 = 40 8 * 6 = 48 8 * 7 = 56 8 * 8 = 64 8 * 9 = 72 8 * 10 = 80 9 * 1 = 9 9 * 2 = 18 9 * 3 = 27 9 * 4 = 36 9 * 5 = 45 9 * 6 = 54 9 * 7 = 63 9 * 8 = 72 9 * 9 = 81 9 * 10 = 90 10 * 1 = 10 10 * 2 = 20 10 * 3 = 30 10 * 4 = 40 10 * 5 = 50 10 * 6 = 60 10 * 7 = 70 10 * 8 = 80 10 * 9 = 90 10 * 10 = 100 ----- Aufgabe 2 ------ 1 2 3 4 5 6 7 8 9 10 2 4 6 8 10 12 14 16 18 20 3 6 9 12 15 18 21 24 27 30 4 8 12 16 20 24 28 32 36 40 5 10 15 20 25 30 35 40 45 50 6 12 18 24 30 36 42 48 54 60 7 14 21 28 35 42 49 56 63 70 8 16 24 32 40 48 56 64 72 80 9 18 27 36 45 54 63 72 81 90 10 20 30 40 50 60 70 80 90 100","title":"format()-Methode und printf()"},{"location":"iteration/","text":"Iteration \u00b6 Die Iteration ist eine der drei Programmablaufstrukturen , die es gibt. Die Nacheinanderausf\u00fchrung von Anweisungen, die Sequenz ist einfach und wir benutzen es st\u00e4ndig. Die Selektion haben wir uns hier genauer angeschaut. Nun geht es um die letzte Programmstruktur, die wir kennenlernen, die Iteration . Unter einer Iteration verstehen wir die wiederholte Ausf\u00fchrung eines Anweisungsblocks. Die Programmkonstrukte, mit denen wir eine Iteration umsetzen, werden Schleifen genannt. Wir werden drei Schleifen kennenlernen: die for -Schleife und die while -Schleife. die do...while -Schleife Die for -Schleife \u00b6 Die for -Schleife verwenden wir, wenn wir eine oder mehrere Anweisungen abz\u00e4hlbar oft wiederholen wollen, wenn wir also die Anzahl der Ausf\u00fchrungen kennen. Die Idee bei der for -Schleife ist die, dass wir uns eine Laufvariable (typischerweise vom Datentyp int ) deklarieren und initialisieren ( INITIALISIERUNG ), eine Bedingung angeben, f\u00fcr welche Werte der Laufvariablen die Schleife wiederholt werden soll ( BEDINGUNG ) und wie sich der Wert der Laufvariablen nach jedem Schleifendurchlauf \u00e4ndern soll ( \u00c4NDERUNG ). Die allgemeine Syntax f\u00fcr eine solche Vorschleife sieht so aus: for ( INITIALISIERUNG ; BEDINGUNG ; \u00c4NDERUNG ) { /* * Anweisungsblock, der wiederholt * werden soll */ } Wir betrachten ein einfaches Beispiel: 1 2 3 4 for ( int i = 0 ; i < 5 ; i ++ ) { System . out . println ( i ); } Der Ablauf dieser Schleife sieht wie folgt aus: Zuerst wird die Laufvariable i deklariert und mit dem Wert 0 initialisiert. Das passiert genau ein Mal. Dann wird gepr\u00fcft, ob die Bedingung i<5 den Wert true ergibt. Das passiert vor jedem Schleifendurchlauf. Wenn der Wert true ist, wird der Schleifenk\u00f6rper, also der Anweisungsblock ausgef\u00fchrt. i<5 ist true , also wird System.out.println(i); ausgef\u00fchrt. Der Wert von i ist 0 , also wird eine 0 auf die Konsole ausgegeben. Mehr Anweisungen gibt es nicht im Anweisungsblock, somit sind wir am Ende der Schleife. Nun wird der Wert von i ge\u00e4ndert. Dazu wird i++ ausgef\u00fchrt. Der Wert von i ist nun 1 . Nun wird erneut gepr\u00fcft, ob die Bedingung i<5 den Wert true ergibt. i<5 ist true , also wird System.out.println(i); ausgef\u00fchrt. Der Wert von i ist 1 , also wird eine 1 auf die Konsole ausgegeben. Nun wird wieder der Wert von i ge\u00e4ndert. Dazu wird i++ ausgef\u00fchrt. Der Wert von i ist nun 2 . Es wird erneut gepr\u00fcft, ob die Bedingung i<5 den Wert true ergibt. i<5 ist true , also wird System.out.println(i); ausgef\u00fchrt. Der Wert von i ist 2 , also wird eine 2 auf die Konsole ausgegeben. i++ \u2192 Wert von i ist 3 i<5 ist true \u2192 Anweisungsblock System.out.println(i); der Wert von i ist 3 \u2192 Ausgabe 3 i++ \u2192 Wert von i ist 4 i<5 ist true \u2192 Anweisungsblock System.out.println(i); der Wert von i ist 4 \u2192 Ausgabe 4 i++ \u2192 Wert von i ist 5 i<5 ist nun false \u2192 Deshalb wird der Anweisungsblock nicht mehr ausgef\u00fchrt! Wir verlassen die Schleife und f\u00fchren die n\u00e4chste Anweisung aus, die nach der Schleife kommt. Oberes Beispiel erzeugt also folgende Ausgabe auf der Konsole: 0 1 2 3 4 In den meisten for -Schleifen wird die Initialisierung wie oben aussehen, also eine Laufvariable (hier i ) wird auf 0 am Anfang gesetzt und die \u00c4nderung des Wertes erfolgt dann durch die Erh\u00f6hung des Wertes um 1 (hier i++ ). Das kann aber auch anders sein, z.B.: 1 2 3 4 for ( int i = 5 ; i > 0 ; i -- ) { System . out . println ( i ); } Hier ist der initiale Wert der Laufvariablen 5 . Die Bedingung pr\u00fcft, ob i gr\u00f6\u00dfer ist als 0 . nach jedem Schleifendurchlauf wird der Wert der Laufvriablen i um 1 rediziert. Es entsteht folgende Ausgabe: 5 4 3 2 1 F\u00fcr die \u00c4nderung des Wertes der Laufvariablen k\u00f6nnen Sie auch jeden der in verk\u00fcrzte Schreibweisen f\u00fcr arithmetische Operatoren eingef\u00fchrten Operatoren verenden, z.B. for ( int i = 1 ; i < 10 ; i += 2 ) { System . out . println ( i ); // 1 3 5 7 9 } for ( int i = 1 ; i < 10 ; i *= 2 ) { System . out . println ( i ); // 1 2 4 8 } Deklaration von Variablen in der for -Schleife In dem oberen Beispiel ist die Laufvariable i zwei Mal deklariert, einmal f\u00fcr die erste for -Schleife und ein weiteres Mal f\u00fcr die zweite for -Schleife. Eigentlich hatten wir ja gesagt, dass eine Variable immer nur genau ein Mal deklariert wird. Korrekt ist es, dass eine Variable immer nur in dem Anweisungsblock existiert, in dem sie deklariert wird. Au\u00dferhalb dieses Anweisungsblockes existiert sie nicht. Wir hatten das auch schon bei Methoden erw\u00e4hnt. Dort hatten wir gesagt, dass die Variablen, die in zwei verschiedenen Methoden deklariert werden, miteinander nichts zu tun haben, sondern dass es sich dabei um verschiedene Variablen handelt. Wenn wir eine Variable innerhalb der for -Schleife deklarieren, dann exitiert sie f\u00fcr die for -Schleife. Davor und danch existiert die Variable nicht (mehr). Deshalb m\u00fcssen wir i in der zweiten for -Schleife auch erneut deklarieren. Wir kommen darauf nochmal ausf\u00fchrlicher zu sprechen, wenn es um die Lebensdauer und Sichtbarkeit von Variablen geht. Weitere Beispiele f\u00fcr einfache for -Schleifen \u00b6 Wir betrachten noch einige Beispiele f\u00fcr einfache for -Schleifen, um uns mit dem Konzept weiter vertraut zu machen. Summe 1 bis n \u00b6 Ausgabe der Summe von 1 bis n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public static void computeSumFrom1ToN ( int n ) { int sum = 0 ; String s = \"1\" ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i > 1 ) { s += \" + \" + i ; } sum = sum + i ; System . out . println ( s + \" = \" + sum ); } } In der Methode computeSumFrom1ToN(int n) wird die Summe von 1 + 2 + ... + n berechnet, wobai n als Parameterwert der Methode \u00fcbergeben wird. Jeder einzelne Schritt wird ausgegeben. Dazu wird ein String s erzeugt, der initial den Wert \"1\" hat. F\u00fcr jede Weitere Addition kommt \" + 2\" , \" + 3\" usw. zu diesem String hinzu. Beachten Sie, dass wir die Variable s au\u00dferhalb der for -Schleife deklariert haben. W\u00e4re sie innerhalb der for -Schleife deklariert, dann w\u00fcrde sie bei jedem Schleifendurchlauf neu erzeugt werden. So wird ihr Wert bei jedem Schleifendurchlauf aktualisiert. Die Selektion wurde eingef\u00fcgt, damit beim ersten Schleifendurchlauf (f\u00fcr i==1 ) nichts an den String s angeh\u00e4ngt wird, sondern nur f\u00fcr alle weiteren Schleifendurchl\u00e4ufe. Beachten Sie auch, dass die Laufvariable i von 1 bis einschlie\u00dflich n la\u00e4uft und wir dadurch die Summe von 1 + 2 + ... + n erzeugen. Wird als Parameterwert eine Zahl kleiner als 1 \u00fcbergeben, erfolgt keine Ausgabe, denn dann ist die Bedingung 1<=n bereits vor dem ersten Schleifendurchlauf false . Ausgabe f\u00fcr den Aufruf `computeSumFrom1ToN(10)` 1 = 1 1 + 2 = 3 1 + 2 + 3 = 6 1 + 2 + 3 + 4 = 10 1 + 2 + 3 + 4 + 5 = 15 1 + 2 + 3 + 4 + 5 + 6 = 21 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 = 36 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = 55 Fakult\u00e4t von n \u00b6 Die Fakult\u00e4t von n ist definiert als n! = 1 * 2 * ... * n f\u00fcr alle Nat\u00fcrlichen Zahlen n>=1 . Wir schreiben uns daf\u00fcr eine Methode und \u00fcbergeben ein n : Fakult\u00e4t von n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public static void fakultaetVonN ( int n ) { int product = 1 ; String s = \"!\" ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i == 2 ) { s += \" = 1 * 2\" ; } else if ( i > 2 ) { s += \" * \" + i ; } product *= i ; System . out . println ( i + s + \" = \" + product ); } } In der Variablen product speichern wir das Produkt aus den Faktoren 1 * 2 * ... * n . beachten Sie, dass product am Anfang den Wert 1 haben muss, um nicht immer mit 0 zu multiplizieren und somit w\u00e4re das Produkt immer 0 . Anstelle von product *= i; h\u00e4tten wir auch product = product * i; schreiben k\u00f6nnen. Weil wir unseren Ausgabestring s noch ein wenig komplizierter gestalttet haben, ist hier sogar eine Fallunterscheidung zwischen i==2 und i>2) notwendig. Ausgabe f\u00fcr den Aufruf `fakultaetVonN(8)` 1 ! = 1 2 ! = 1 * 2 = 2 3 ! = 1 * 2 * 3 = 6 4 ! = 1 * 2 * 3 * 4 = 24 5 ! = 1 * 2 * 3 * 4 * 5 = 120 6 ! = 1 * 2 * 3 * 4 * 5 * 6 = 720 7 ! = 1 * 2 * 3 * 4 * 5 * 6 * 7 = 5040 8 ! = 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 = 40320 Fibonacci-Folge \u00b6 \u00dcbung Fibonacci-Folge Schreiben Sie ein Programm, das die Fibonacci-Folge auf der Konsole ausgibt. Die ersten beiden Werte der Fibonacci-Folge sind 0 und 1 . Die Berechnung der Folgezahlen soll in einer Schleife gemacht werden. Eine Fibonacci-Folge sieht wie folgt aus: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, \u2026 . Es gilt: eine Zahl n ist immer die Summe ihrer beiden Vorg\u00e4nger n-1 und n-2 . Verschachtelte for -Schleifen \u00b6 In den bisherigen Beispielen haben wir immer genau eine for -Schleife ben\u00f6tigt, da wir \"nur\" etwas aufaddiert oder aufmultipliziert haben, um eine eindimensionale Folge zu berechnen oder auszugeben. Wir wissen aber bereits, dass in dem Anweisungsblock des Schleifenk\u00f6rpers jede beliebige Kontrollstruktur vorkommen kann, also eine Sequenz und/oder eine Iteration und/oder eine Selektion. Selektion und Sequenz haben wir in unseren Beispielen bereits verwendet. Nun wollen wir auch noch eine Schleife innerhalb der Schleife untersuchen. Rechteck \u00b6 Angenommen, wir sollen ein Rechteck aus lauter * -zeichen auf die Konsole ausgeben und sowohl die Breite des Rechtecks als auch dessen H\u00f6he sind variabel. Am Ende soll also so ein Bild herauskommen: *********************** *********************** *********************** *********************** *********************** In diesem Beispiel ist die Breite 23 und die H\u00f6he 5 . Unsere \u00dcberlegungen sind zun\u00e4chst wie folgt: wir k\u00f6nnen nur zeilenweise ausgeben (spaltenweise geht nicht auf der Konsole) wir ben\u00f6tigen eine Schleife, um die 23 Sterne in einer Zeile auszugeben wir ben\u00f6tigen eine Schleife, um die 5 Zeilen auszugeben D.h. wir \u00fcberlegen uns zun\u00e4chst, wie wir eine Zeile ausgeben. Wir nehmen dazu an, wir haben eine int -Variable width , die uns die Breite des Rechtecks vorgibt (z.B. 23 ): 1 2 3 4 for ( int col = 0 ; col < width ; col ++ ) { System . out . print ( \"*\" ); } Wir geben also in einer Schleife eine Anzahl width von Sternen aus. Beachten Sie, dass die Laufvariable col (f\u00fcr column) mit 0 initialisert wird. Deshalb ist die Schleifenbedingung col < width . H\u00e4tten wir col <= width geschrieben, w\u00fcrde ein Stern zu viel ausgegeben (au\u00dfer, wir h\u00e4tten col mit 1 initialisiert). Sie m\u00fcssen die Initialisierung und die Bedingung immer gut aufeinander abstimmen! dass wir zur Ausgabe print(\"*\") statt println(\"*\") verwenden, weil sonst nach jedem Stern ein Zeilenumbruch erfolgen w\u00fcrde, die Sterne also nicht nebeneinander sondern untereinander ausgegeben w\u00fcrden. Nun \u00fcberlegen wir uns, wie wir die Zeilen ausgeben. Dazu nehmen wir an, wir haben eine int -Variable height , die uns die H\u00f6he des Rechtecks vorgibt (z.B. 5 ): 1 2 3 4 for ( int row = 0 ; row < height ; row ++ ) { // Hier soll jetzt eine Zeile ausgegeben werden } Wir geben also in einer Schleife eine Anzahl height von Zeilen aus aus. In jeder Zeile soll die Anzahl width von Sternen ausgegeben werden. Wir m\u00fcssen also die Schleife f\u00fcr die Sterne in die Schleife f\u00fcr die Zeilen einsetzen: 1 2 3 4 5 6 7 for ( int row = 0 ; row < height ; row ++ ) { for ( int col = 0 ; col < width ; col ++ ) { System . out . print ( \"*\" ); } } Jetzt heben wir nur noch ein kleines Problem. Nachdem wir unsere Zeile mit Sternen ausgegeben haben, steht der Kursor noch hinter dem zuletzt ausgegebenen Stern. Er sollte danach aber an den Anfang der neuen Zeile wandern. Wir m\u00fcssen also noch f\u00fcr einen Zeilenumbruch sorgen. das erledigen wir mit System.out.println(); . Diese Anweisung kommt nach der inneren Schleife in die \u00e4u\u00dfere Schleife. Die gesamte Methode sieht dann so aus: 1 2 3 4 5 6 7 8 9 10 11 public static void printRectangle ( int width , int height ) { for ( int row = 0 ; row < height ; row ++ ) { for ( int col = 0 ; col < width ; col ++ ) { System . out . print ( \"*\" ); } System . out . println (); } } Die Zeilen 3-10 beschreiben die \u00e4u\u00dfere for -Schleife und die Zeilen 5-8 die innere for -Schleife. Wir \"laufen\" einmal durch den Beginn unseres Programms durch. Angenommen, unsere Methode wird mit der Anweisung printRectangle(23,5); aufgerufen, d.h. die Variable width bekommt den Wert 23 und die Variable height den Wert 5 zugewiesen. Die Laufvariable row bekommt initial den Wert 0 . 0 ist kleiner als 5 und somit ist die Bedingung row < height true . Wir betreten also den Anweisungsblock der \u00e4u\u00dferen Schleife. Die erste Anweisung in diesem Anweisungsblock ist die innere for -Schleife. Diese wird nun vollst\u00e4ndig abgearbeitet, d.h. die Laufvariable col nimmt alle Werte von 0 bis 22 an und gibt jedes Mal (also 23 Mal) einen * aus. Wenn der Wert von col auf 23 gesetzt wurde, ist die Bedingung col < width nicht mehr true sondern false und die Abarbeitung der Schleife ist beendet. Es wird Zeile 9 und somit ein Zeilenumbruch ausgef\u00fchrt. Dann wird der Wert von row um 1 erh\u00f6ht ( row++ ) und hat somit den Wert 1 . Die Bedingung row < height ist true und somit wird erneut der Anweisungsblock der \u00e4u\u00dferen Schleife ausgef\u00fchrt. Wieder ist die erste Anweisung in diesem Anweisungsblock die innere for -Schleife. Diese wird nun wieder vollst\u00e4ndig abgearbeitet, d.h. die Laufvariable col nimmt alle Werte von 0 bis 22 an und gibt jedes Mal (also 23 Mal) einen * aus. Wenn der Wert von col auf 23 gesetzt wurde, ist die Bedingung col < width nicht mehr true sondern false und die Abarbeitung der Schleife ist beendet. Es wird Zeile 9 und somit ein Zeilenumbruch ausgef\u00fchrt. Dann wird der Wert von row um 1 erh\u00f6ht ( row++ ) und hat somit den Wert 2 . Die Bedingung row < height ist true und somit wird erneut der Anweisungsblock der \u00e4u\u00dferen Schleife ausgef\u00fchrt. usw. bis der Wert von row 5 ist. Dann wird die \u00e4u\u00dfere for -Schleife verlassen und die Abarbeitung der Methode ist beendet. Wichtig ist, dass die innere Schleife jedes Mal vollst\u00e4ndig abgearbeitet wird, ehe der Zeilenumbruch erfolgt und dann der Wert von row erh\u00f6ht wird. Wir \u00e4ndern die Ausgabe unserer Methode mal ein wenig, um das Prinzip besser zu erkennen: 1 2 3 4 5 6 7 8 9 10 11 12 public static void printRectangle ( int width , int height ) { for ( int row = 0 ; row < height ; row ++ ) { System . out . print ( \"(row = \" + row + \"): \" ); for ( int col = 0 ; col < width ; col ++ ) { System . out . print ( \"[col = \" + col + \"]\" ); } System . out . println (); } } F\u00fcr den Aufruf der Methode printRectangle(10,5); erhalten wir dann folgende Ausgabe: ( row = 0 ) : [ col = 0 ][ col = 1 ][ col = 2 ][ col = 3 ][ col = 4 ][ col = 5 ][ col = 6 ][ col = 7 ][ col = 8 ][ col = 9 ] ( row = 1 ) : [ col = 0 ][ col = 1 ][ col = 2 ][ col = 3 ][ col = 4 ][ col = 5 ][ col = 6 ][ col = 7 ][ col = 8 ][ col = 9 ] ( row = 2 ) : [ col = 0 ][ col = 1 ][ col = 2 ][ col = 3 ][ col = 4 ][ col = 5 ][ col = 6 ][ col = 7 ][ col = 8 ][ col = 9 ] ( row = 3 ) : [ col = 0 ][ col = 1 ][ col = 2 ][ col = 3 ][ col = 4 ][ col = 5 ][ col = 6 ][ col = 7 ][ col = 8 ][ col = 9 ] ( row = 4 ) : [ col = 0 ][ col = 1 ][ col = 2 ][ col = 3 ][ col = 4 ][ col = 5 ][ col = 6 ][ col = 7 ][ col = 8 ][ col = 9 ] Durch die Verschachtelung der for -Schleife erzeugen wir somit eine 2-dimensionale Ausgabe. Die innere Schleife entwickelt die horizontale Dimension (eine Zeile mit width Sternen) und die \u00e4u\u00dfere for -Schleife entwickelt entwickelt die vertikale Dimension ( height viele Zeilen). Wir schauen uns noch ein Beispiel an. Nun ist die Bedingung der inneren Schleife vom Wert der Alufvariablen der \u00e4u\u00dferen Schleife abh\u00e4ngig. Dreieck \u00b6 Angenommen, wir wollen ein gleichschenkliges rechteckiges Dreieck erzeugen. Dazu \u00fcbergeben wir die H\u00f6he des Dreiecks als Wert. Angenommen, wir wollen ein Dreieck der H\u00f6he 7 , dann soll folgende Ausgabe erscheinen: * ** *** **** ***** ****** ******* Unsere \u00e4u\u00dfere Schleife wird sicherlich so aussehen, wie unsere \u00e4u\u00dfere Schleife beim Rechteck. Angenommen, unsere H\u00f6he ist in der Variablen height gespeichert, dann m\u00fcssen wir height viele Zeilen ausgeben: 1 2 3 4 for ( int row = 0 ; row < height ; row ++ ) { // Hier soll jetzt eine Zeile ausgegeben werden } Daran hat sich also nichts ge\u00e4ndert, aber die innere Schleife sieht sicherlich anders aus, denn wir haben keine width -Variable mehr. Die Anzahl der Sterne in einer Zeile ist nicht konstant, sondern h\u00e4ngt davon ab, in welcher Zeile wir uns befinden: Zeile 1 : row == 0 : 1 Stern ausgeben Zeile 2 : row == 1 : 2 Sterne ausgeben Zeile 3 : row == 2 : 3 Sterne ausgeben Zeile 4 : row == 3 : 4 Sterne ausgeben Zeile 5 : row == 4 : 5 Sterne ausgeben Zeile 6 : row == 5 : 6 Sterne ausgeben Zeile 7 : row == 6 : 7 Sterne ausgeben Das bedeutet, die Bedingung der inneren Schleife muss sich \u00e4ndern. Sie muss abh\u00e4ngig sein vom Wert von row : 1 2 3 4 for ( int col = 0 ; col <= row ; col ++ ) { System . out . print ( \"*\" ); } Wenn row den Wert 0 hat, wird die Schleife 1 Mal durchlaufen, Wert 1 hat, wird die Schleife 2 Mal durchlaufen, Wert 2 hat, wird die Schleife 3 Mal durchlaufen, usw. Die gesamte Methode sieht dann so aus: 1 2 3 4 5 6 7 8 9 10 11 public static void printTriangle ( int height ) { for ( int row = 0 ; row < height ; row ++ ) { for ( int col = 0 ; col <= row ; col ++ ) { System . out . print ( \"*\" ); } System . out . println (); } } 2 Schleifen in einer Schleife \u00b6 Wir betrachten noch ein letztes Beispiel. Wir k\u00f6nnten Schleifen nat\u00fcrlich noch weiter verschachteln, also noch eine weitere Schleife in der inneren Schleife implementieren. Das ist m\u00f6glich, wird aber schnell un\u00fcbersichtlich. Prinzipiell ist die Verschachtelungstiefe aber unbegrenzt endlich. Stattdessen wollen wir uns in unserem letzten Beispiel aber einmal \u00fcberlegen, wie wir erneut ein gleichschenkliges rechtwinkliges Dreieck erzeugen k\u00f6nnten. Dieses Mal soll es aber nicht \"linksb\u00fcndig\", sondern \"rechtsb\u00fcndig\" sein, also so: * ** *** **** ***** ****** ******* Der Unterschied zum oberen Beispiel ist der, dass wir nun immer erst eine bestimmte Anzahl an Leerzeichen ausgeben m\u00fcssen, ehe wir den ersten Stern ausgeben. Dazu \u00fcberlegen wir uns wieder die Abh\u00e4ngigkeiten f\u00fcr ein Dreieck der H\u00f6he 7 : Zeile 1 : row == 0 : 6 Leerzeichen ausgeben + 1 Stern ausgeben ( height == 7 ) Zeile 2 : row == 1 : 5 Leerzeichen ausgeben + 2 Sterne ausgeben ( height == 7 ) Zeile 3 : row == 2 : 4 Leerzeichen ausgeben + 3 Sterne ausgeben ( height == 7 ) Zeile 4 : row == 3 : 3 Leerzeichen ausgeben + 4 Sterne ausgeben ( height == 7 ) Zeile 5 : row == 4 : 2 Leerzeichen ausgeben + 5 Sterne ausgeben ( height == 7 ) Zeile 6 : row == 5 : 1 Leerzeichen ausgeben + 6 Sterne ausgeben ( height == 7 ) Zeile 7 : row == 6 : 0 Leerzeichen ausgeben + 7 Sterne ausgeben ( height == 7 ) Die \u00e4u\u00dfere Schleife bleibt wieder so wie vorher: 1 2 3 4 for ( int row = 0 ; row < height ; row ++ ) { // Hier soll jetzt eine Zeile ausgegeben werden } Allerdings ist die Ausgabe einer Zeile nun in 2 Aufgaben zerlegt. Zuerst eine bestimmte Anzahl von Leerzeichen ausgeben und dann eine bestimmte Anzahl von Sternen: 1 2 3 4 5 6 for ( int row = 0 ; row < height ; row ++ ) { // zuerst muss eine bestimmte Anzahl von Leerzeichen ausgegeben werden // dann wird eine bestimmte Anzahl von Sternen ausgegeben } F\u00fcr die Anzahl von Sternen haben wir bereits eine L\u00f6sung, die wir verwenden k\u00f6nnen: 1 2 3 4 for ( int col = 0 ; col <= row ; col ++ ) { System . out . print ( \"*\" ); } Diese Schleife k\u00f6nnen wir schonmal in unsere \u00e4u\u00dfere Schleife einsetzen: 1 2 3 4 5 6 7 8 9 for ( int row = 0 ; row < height ; row ++ ) { // zuerst muss eine bestimmte Anzahl von Leerzeichen ausgegeben werden for ( int col = 0 ; col <= row ; col ++ ) { System . out . print ( \"*\" ); } } So wie die Anzahl von Sternen abh\u00e4ngig von der Zeile ist, in der wir die Sterne ausgeben, so ist auch die Anzahl der Leerzeichen davon abh\u00e4ngig. Allerdings beginnen wir mit einem gr\u00f6\u00dferen Wert und werden dann immer kleiner (von 6 bis 0 bei der H\u00f6he height==7 ). Die Anzahl der auszugebenden Leerzeichen ist also einerseits abh\u00e4ngig von der Gesamth\u00f6he ( height ) und andererseits von der aktuellen Zeile row . Wir \u00fcberlegen uns, mit welchem Startwert wir beginnen: am Anfang wollen wir 6 leerzeichen ausgeben, das sind height-1 viele. Danach ziehen wir von diesem Wert immer so viele ab, wie row gro\u00df ist, also erst -0 , dann -1 , dann -2 usw. Der Startwert ist also height -1 - row . In der letzten Zeile hat row den Wert 6 . Dann w\u00e4re unser Startwert height -1 - 6 == 7 - 1 - 6 == 0 . In der letzten Zeile wollen wir aber gar kein Leerzeichen mehr ausgeben, also muss dort schon unsere Bedingung false sein. Also setzen wir die Bedingung auf >0 . Die Schleife f\u00fcr die Ausgabe der Leerzeichen ist dann wie folgt: 1 2 3 4 for ( int spaces = height - 1 - row ; spaces > 0 ; spaces -- ) { System . out . print ( \" \" ); } F\u00fcr viele ist eine solche Schleife schwer zu lesen, da sich der Wert der ALufvariablen reduziert und die Ermittlung des Initialwertes gleich 2 Subtraktionen enth\u00e4lt. Wir haben ja bereits eingangs gesagt, dass eine solche Schleife auch \u00e4quivalent in anderer Form geschrieben werden kann. Das gleiche Ergebnis erhalten wir mit der folgenden Implementierung: 1 2 3 4 for ( int spaces = 1 ; spaces < height - row ; spaces ++ ) { System . out . print ( \" \" ); } \u00dcbung Schleife, initaile Werte und Bedingungen Warum sind die beiden oberen Schleifen identisch? Warum sind die beiden folgenden Schleifen nur fast identisch? Was ist der Unterschied in den Beispielen? 1 2 3 4 for ( int i = 0 ; i < 5 ; i ++ ) { System . out . println ( i ); } 1 2 3 4 for ( int i = 5 ; i > 0 ; i -- ) { System . out . println ( i ); } Die gesamte Methode sieht dann so aus: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public static void printTriangleR ( int height ) { for ( int row = 0 ; row < height ; row ++ ) { for ( int spaces = 1 ; spaces < height - row ; spaces ++ ) { System . out . print ( \" \" ); } for ( int col = 0 ; col <= row ; col ++ ) { System . out . print ( \"*\" ); } System . out . println (); } } \u00dcbung linksb\u00fcndiges Dreieck Schreiben Sie die Methode printTriangle(int height) so um, dass bei z.B. printTriangle(7); nicht folgende Ausgabe ensteht: * ** *** **** ***** ****** ******* sondern folgende: * * * * * * * * * * * * * * * * * * * * * * * * * * * * \u00dcbung rechtsb\u00fcndiges Dreieck Schreiben Sie die Methode printTriangleR(int height) so um, dass bei z.B. printTriangleR(7); nicht folgende Ausgabe ensteht: * ** *** **** ***** ****** ******* sondern folgende: * * * * * * * * * * * * * * * * * * * * * * * * * * * * Success Wir haben for -Schleifen kennengelernt und k\u00f6nnen damit nun auch Iterationen implementieren. for -Schleifen verwenden wir, wenn wir einen Anweisungsblock eine bestimmte Anzahl oft wiederholt ausf\u00fchren m\u00f6chten. Wir haben auch for -Schleifen verschachtelt, um variabel in mehrere Dimensionen zu sein. und wir haben mehrere for -Schleifen innerhalb einer for -Schleife verwendet. Nun lernen wir noch zwei weitere Schleifen kennen. Die while -Schleife. \u00b6 W\u00e4hrend die Anzahl der Ausf\u00fchrungen einer for -Schleife von einem numerischen Wert festgelegt wird, ist die Anzahl der Ausf\u00fchrungen einer while -Schleife von einem logischen Ausdruck abh\u00e4ngig. Prinzipiell muss man jedoch sagen, dass es auch v\u00f6llig gen\u00fcgen w\u00fcrde, wenn man nur for -Schleifen oder nur while -Schleifen in einer Programmiersprache zur Verf\u00fcgung h\u00e4tte. Man kann mit beiden Schleifenarten (und sp\u00e4ter auch mit der do..while -Schleife) alle Iterationen implemnetieren, die programmierbar sind. Schauen wir uns zun\u00e4chst die allgemeine Syntax einer while -Schleife an: while ( BEDINGUNG ) { /* * Anweisungsblock, der wiederholt * werden soll */ } Eine while -Schleife ist also auf den ersten Blick weniger komplex als eine for -Schleife. Da wir aber gesagt haben, dass man mit beiden Schleifenarten die gleichen Programme umsetzen kann, schauen wir uns die ersten Beispiele der for -Schleife mal als while -Schleife an: 1 2 3 4 5 6 int i = 0 ; while ( i < 5 ) { System . out . println ( i ); i ++ ; } Diese while -Schleife macht genau das gleiche, wie unser erstes Beispiel f\u00fcr die for -Schleife. Es wird eine Variable i deklariert und mit 0 initialisiert. Als Bedingung unserer while -Schleife wird gepr\u00fcft, ob der Wert von i kleiner als 5 ist. Wenn ja, wird dieser Wert ausgegeben und der Wert von i um 1 erh\u00f6ht. Nun wird wieder gepr\u00fcft, ob der Wert von i immer noch kleiner als 5 ist. Wenn ja, wird der Wert ausgegeben und um 1 erh\u00f6ht usw. Es scheint zun\u00e4chst, als w\u00e4re diese beiden Schleifenarten v\u00f6llig redundant. Was bedeutet es nun, dass eine for -Schleife von einer bestimmten Anzahl und eine while -Schleife von einer Bedingung abh\u00e4ngig ist? Sehen wir uns dazu nochmal unsere beiden Beispielalgorithmen vom Anfang an: der Euklidische Algrorithmus und die (3n+1)-Vermutung (Collatz-Problem) Die Beschreibung der Iteration beim Eukidischen Algorithmus war solange a ungleich b ist, wiederhole . Das bedeutet, dass die Bedingung f\u00fcr die Schleifenwiederholung a ungleich b ist. Nach wieviel Wiederholungen (also nach welcher Anzahl ) l\u00e4sst sich nicht sagen. Es l\u00e4sst sich aber leicht die Bedingung formulieren, die gelten soll, damit die Schleife erneut ausgef\u00fchrt wird, n\u00e4mlich (a!=b) . Das gleiche gilt f\u00fcr die (3n+1)-Vermutung. Dort lautet die Beschreibung der Iteration solange n ungleich 1 ist, wiederhole . Nach wieviel Wiederholungen (also nach welcher Anzahl ) l\u00e4sst sich vorher nicht sagen, aber die Bedingung daf\u00fcr, dass die Schleife erneut wiederholt werden soll, l\u00e4sst sich leicht formulieren, n\u00e4mlich (n!=1) . Implementierung des Euklidischen Algorithmus \u00b6 Mithilfe der while -Schleife implementieren wir nun mal beide Allgorithmen. Zuerst den Euklidischen Algorithmus: Berechnung des ggT nach Euklid 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public static void berechneGGT ( int a , int b ) { while ( a != b ) { if ( a > b ) { a = a - b ; } else { b = b - a ; } } System . out . println ( \"ggT: \" + a ); } Die Ausgabe f\u00fcr z.B. berechneGGT(24, 40); ist 8 . Ver\u00e4nderung der Werte von Parametern in Methoden In unserer Methode zur Berechnung des gr\u00f6\u00dften gemeinsamen Teilers nach Euklid haben wir die Werte der Parameter a und b innerhalb unserer Methode ge\u00e4ndert (siehe a = a -b; und b = b - a; ). Das ist kein guter Stil! So haben wir z.B. nicht die M\u00f6glichkeit, am Ende der Methode eine Ausgabe der Form Der ggT von 24 und 40 ist 8. zu erstellen, da wir auf die Werte 24 (von a ) und 40 (von b ) keinen Zugriff mehr haben. Wir sollten uns angew\u00f6hnen, die Parameterwerte in Methoden nicht zu \u00e4ndern, sondern lieber mit Kopien der Werte zu rechnen. Sp\u00e4ter werden wir unsere Parameter als Konstanten definieren, dann ist eine \u00c4nderung gar nicht m\u00f6glich. Das folgende Beispiel zeigt eine bessere L\u00f6sung: Berechnung des ggT nach Euklid (ohne \u00c4nderung der Parameterwerte) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public static void berechneGGT ( int a , int b ) { int nr1 = a ; int nr2 = b ; while ( nr1 != nr2 ) { if ( nr1 > nr2 ) { nr1 = nr1 - nr2 ; } else { nr2 = nr2 - nr1 ; } } System . out . println ( \"Der ggT von \" + a + \" und \" + b + \" ist \" + nr1 ); } Die Ausgabe f\u00fcr z.B. berechneGGT(24, 40); ist nun Der ggT von 24 und 40 ist 8 . Implementierung der (3n+1)-Vermutung \u00b6 Mithilfe der while -Schleife k\u00f6nnen wir nun auch die (3n+1)-Vermutung (Collatz-Problem) geeignet implementieren: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public static void printCollatzFolge ( int n ) { int number = n ; while ( number != 1 ) { System . out . print ( number + \" \" ); if ( number % 2 == 0 ) { number = number / 2 ; } else { number = 3 * number + 1 ; } } System . out . println ( number ); } Auch hier kopieren wir zun\u00e4chst den Wert des Parameters, um diesen nicht zu \u00e4ndern. Mithilfe von number%2 == 0 pr\u00fcfen wir, ob number gerade oder ungerade ist. Ist number gerade, teilen wir den Wert durch 2 , ist number ungerade, multiplizieren wir den Wert mit 3 und addieren 1 , um jeweils den Nachfolger zu ermitteln. Solange dieser NAchfolger ungleich 1 ist, wird der n\u00e4chste Nachfolger berechnet usw. Die Ausf\u00fchrung der methode mit z.B. printCollatzFolge(17); erzeugt folgende Ausgabe: 17 52 26 13 40 20 10 5 16 8 4 2 1 . Wir beginnen mit 17 . Diese Zahl ist ungerade, also ist der Nachfolger 52 . Diese Zahl und auch der Nachfolger 26 sind gerade. Der n\u00e4chste Nachfolger 13 ist ungerade, dann kommen drei gerade Zahlen 40 , 20 und 10 und erst dann wieder eine ungerade Zahl 5 . 16 ist dann aber schon eine Potenz von 2 und somit endet die Folge mit der 1 . \u00dcbungen while -Schleife Nat\u00fcrlich kann eine while -Schleife genau wie die for -Schleife verschachtelt werden. Implementieren Sie das Rechteck das linksb\u00fcndige Dreieck und das rechtsb\u00fcndige Dreieck mithilfe von verschachtelten while -Schleifen. Die do...while -Schleife \u00b6 Wir haben ja bereits bei den for - und while -Schleifen erw\u00e4hnt, dass eines der beiden Konzepte gen\u00fcgt h\u00e4tte, um alle Iterationen zu implementieren. Da man aber ganz gute Unterscheidungsm\u00f6glichkeiten hat, um sich entweder f\u00fcr die for -Schleife (bestimmte Anzahl) oder f\u00fcr die while -Schleife (bestimmte Bedingung) zu entscheiden, haben beide Schleifenarten ihre Berechtigungsexistenz. F\u00fcr die do ... while f\u00e4llt die Abgrenzung zur while -Schleife noch schwerer. Generell l\u00e4sst sich sagen, dass eine while -Schleife nicht unebdingt ausgef\u00fchrt werden muss (n\u00e4mlich dann, wenn die Bedingung bereits ganz zu Anfang schon false ist), eine do ... while -Schleife wird aber zumindest ein Mal ausgef\u00fchrt, da die Pr\u00fcfung der Bedingung erst nach dem Schleifendurchlauf erfolgt. Die allgemeine Syntax einer do ... while -Schleife ist wie folgt: do { /* * Anweisungsblock, der wiederholt * werden soll */ } while ( BEDINGUNG ); Beachten Sie das Semikolon hinter der Bedingung! Es gibt Beispiele f\u00fcr den sinnvollen Einsatz von do ... while -Schleifen, z.B. wenn innerhalb der Schleife eine Eingabe erfolgt und die Bedingung pr\u00fcft, ob es sich um eine korrekte Eingabe handelt. Wir werden uns aber zun\u00e4chst nicht weiter um diese Schleife k\u00fcmmern, da sie nicht wirklich notwendig ist und wir uns haupts\u00e4chlich mit for - und while -Schleifen besch\u00e4ftigen werden. break und continue \u00b6 break und continue In (fast) allen Java-B\u00fcchern liest man in dem Kapitel \u00fcber Schleifen auch davon, dass es die beiden Anweisungen break; und continue; gibt. Ich will hier gar nicht darauf eigehen, was diese beiden Anweisungen machen, nur so viel: sie springen aus Schleifen heraus. Solche Art von \"Spr\u00fcngen\" ( go to statements ) geh\u00f6ren nicht in moderne, gute Programme. Wir nutzen diese Anweisungen nicht!!! Stattdessen sei in diesem Zusammenhang ein ber\u00fchmtes Papier von Edsger W. Dijkstra empfohlen: Go To Statement Considered Harmful . Siehe dazu auch hier .","title":"Iteration"},{"location":"iteration/#iteration","text":"Die Iteration ist eine der drei Programmablaufstrukturen , die es gibt. Die Nacheinanderausf\u00fchrung von Anweisungen, die Sequenz ist einfach und wir benutzen es st\u00e4ndig. Die Selektion haben wir uns hier genauer angeschaut. Nun geht es um die letzte Programmstruktur, die wir kennenlernen, die Iteration . Unter einer Iteration verstehen wir die wiederholte Ausf\u00fchrung eines Anweisungsblocks. Die Programmkonstrukte, mit denen wir eine Iteration umsetzen, werden Schleifen genannt. Wir werden drei Schleifen kennenlernen: die for -Schleife und die while -Schleife. die do...while -Schleife","title":"Iteration"},{"location":"iteration/#die-for-schleife","text":"Die for -Schleife verwenden wir, wenn wir eine oder mehrere Anweisungen abz\u00e4hlbar oft wiederholen wollen, wenn wir also die Anzahl der Ausf\u00fchrungen kennen. Die Idee bei der for -Schleife ist die, dass wir uns eine Laufvariable (typischerweise vom Datentyp int ) deklarieren und initialisieren ( INITIALISIERUNG ), eine Bedingung angeben, f\u00fcr welche Werte der Laufvariablen die Schleife wiederholt werden soll ( BEDINGUNG ) und wie sich der Wert der Laufvariablen nach jedem Schleifendurchlauf \u00e4ndern soll ( \u00c4NDERUNG ). Die allgemeine Syntax f\u00fcr eine solche Vorschleife sieht so aus: for ( INITIALISIERUNG ; BEDINGUNG ; \u00c4NDERUNG ) { /* * Anweisungsblock, der wiederholt * werden soll */ } Wir betrachten ein einfaches Beispiel: 1 2 3 4 for ( int i = 0 ; i < 5 ; i ++ ) { System . out . println ( i ); } Der Ablauf dieser Schleife sieht wie folgt aus: Zuerst wird die Laufvariable i deklariert und mit dem Wert 0 initialisiert. Das passiert genau ein Mal. Dann wird gepr\u00fcft, ob die Bedingung i<5 den Wert true ergibt. Das passiert vor jedem Schleifendurchlauf. Wenn der Wert true ist, wird der Schleifenk\u00f6rper, also der Anweisungsblock ausgef\u00fchrt. i<5 ist true , also wird System.out.println(i); ausgef\u00fchrt. Der Wert von i ist 0 , also wird eine 0 auf die Konsole ausgegeben. Mehr Anweisungen gibt es nicht im Anweisungsblock, somit sind wir am Ende der Schleife. Nun wird der Wert von i ge\u00e4ndert. Dazu wird i++ ausgef\u00fchrt. Der Wert von i ist nun 1 . Nun wird erneut gepr\u00fcft, ob die Bedingung i<5 den Wert true ergibt. i<5 ist true , also wird System.out.println(i); ausgef\u00fchrt. Der Wert von i ist 1 , also wird eine 1 auf die Konsole ausgegeben. Nun wird wieder der Wert von i ge\u00e4ndert. Dazu wird i++ ausgef\u00fchrt. Der Wert von i ist nun 2 . Es wird erneut gepr\u00fcft, ob die Bedingung i<5 den Wert true ergibt. i<5 ist true , also wird System.out.println(i); ausgef\u00fchrt. Der Wert von i ist 2 , also wird eine 2 auf die Konsole ausgegeben. i++ \u2192 Wert von i ist 3 i<5 ist true \u2192 Anweisungsblock System.out.println(i); der Wert von i ist 3 \u2192 Ausgabe 3 i++ \u2192 Wert von i ist 4 i<5 ist true \u2192 Anweisungsblock System.out.println(i); der Wert von i ist 4 \u2192 Ausgabe 4 i++ \u2192 Wert von i ist 5 i<5 ist nun false \u2192 Deshalb wird der Anweisungsblock nicht mehr ausgef\u00fchrt! Wir verlassen die Schleife und f\u00fchren die n\u00e4chste Anweisung aus, die nach der Schleife kommt. Oberes Beispiel erzeugt also folgende Ausgabe auf der Konsole: 0 1 2 3 4 In den meisten for -Schleifen wird die Initialisierung wie oben aussehen, also eine Laufvariable (hier i ) wird auf 0 am Anfang gesetzt und die \u00c4nderung des Wertes erfolgt dann durch die Erh\u00f6hung des Wertes um 1 (hier i++ ). Das kann aber auch anders sein, z.B.: 1 2 3 4 for ( int i = 5 ; i > 0 ; i -- ) { System . out . println ( i ); } Hier ist der initiale Wert der Laufvariablen 5 . Die Bedingung pr\u00fcft, ob i gr\u00f6\u00dfer ist als 0 . nach jedem Schleifendurchlauf wird der Wert der Laufvriablen i um 1 rediziert. Es entsteht folgende Ausgabe: 5 4 3 2 1 F\u00fcr die \u00c4nderung des Wertes der Laufvariablen k\u00f6nnen Sie auch jeden der in verk\u00fcrzte Schreibweisen f\u00fcr arithmetische Operatoren eingef\u00fchrten Operatoren verenden, z.B. for ( int i = 1 ; i < 10 ; i += 2 ) { System . out . println ( i ); // 1 3 5 7 9 } for ( int i = 1 ; i < 10 ; i *= 2 ) { System . out . println ( i ); // 1 2 4 8 } Deklaration von Variablen in der for -Schleife In dem oberen Beispiel ist die Laufvariable i zwei Mal deklariert, einmal f\u00fcr die erste for -Schleife und ein weiteres Mal f\u00fcr die zweite for -Schleife. Eigentlich hatten wir ja gesagt, dass eine Variable immer nur genau ein Mal deklariert wird. Korrekt ist es, dass eine Variable immer nur in dem Anweisungsblock existiert, in dem sie deklariert wird. Au\u00dferhalb dieses Anweisungsblockes existiert sie nicht. Wir hatten das auch schon bei Methoden erw\u00e4hnt. Dort hatten wir gesagt, dass die Variablen, die in zwei verschiedenen Methoden deklariert werden, miteinander nichts zu tun haben, sondern dass es sich dabei um verschiedene Variablen handelt. Wenn wir eine Variable innerhalb der for -Schleife deklarieren, dann exitiert sie f\u00fcr die for -Schleife. Davor und danch existiert die Variable nicht (mehr). Deshalb m\u00fcssen wir i in der zweiten for -Schleife auch erneut deklarieren. Wir kommen darauf nochmal ausf\u00fchrlicher zu sprechen, wenn es um die Lebensdauer und Sichtbarkeit von Variablen geht.","title":"Die for-Schleife"},{"location":"iteration/#weitere-beispiele-fur-einfache-for-schleifen","text":"Wir betrachten noch einige Beispiele f\u00fcr einfache for -Schleifen, um uns mit dem Konzept weiter vertraut zu machen.","title":"Weitere Beispiele f\u00fcr einfache for-Schleifen"},{"location":"iteration/#summe-1-bis-n","text":"Ausgabe der Summe von 1 bis n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public static void computeSumFrom1ToN ( int n ) { int sum = 0 ; String s = \"1\" ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i > 1 ) { s += \" + \" + i ; } sum = sum + i ; System . out . println ( s + \" = \" + sum ); } } In der Methode computeSumFrom1ToN(int n) wird die Summe von 1 + 2 + ... + n berechnet, wobai n als Parameterwert der Methode \u00fcbergeben wird. Jeder einzelne Schritt wird ausgegeben. Dazu wird ein String s erzeugt, der initial den Wert \"1\" hat. F\u00fcr jede Weitere Addition kommt \" + 2\" , \" + 3\" usw. zu diesem String hinzu. Beachten Sie, dass wir die Variable s au\u00dferhalb der for -Schleife deklariert haben. W\u00e4re sie innerhalb der for -Schleife deklariert, dann w\u00fcrde sie bei jedem Schleifendurchlauf neu erzeugt werden. So wird ihr Wert bei jedem Schleifendurchlauf aktualisiert. Die Selektion wurde eingef\u00fcgt, damit beim ersten Schleifendurchlauf (f\u00fcr i==1 ) nichts an den String s angeh\u00e4ngt wird, sondern nur f\u00fcr alle weiteren Schleifendurchl\u00e4ufe. Beachten Sie auch, dass die Laufvariable i von 1 bis einschlie\u00dflich n la\u00e4uft und wir dadurch die Summe von 1 + 2 + ... + n erzeugen. Wird als Parameterwert eine Zahl kleiner als 1 \u00fcbergeben, erfolgt keine Ausgabe, denn dann ist die Bedingung 1<=n bereits vor dem ersten Schleifendurchlauf false . Ausgabe f\u00fcr den Aufruf `computeSumFrom1ToN(10)` 1 = 1 1 + 2 = 3 1 + 2 + 3 = 6 1 + 2 + 3 + 4 = 10 1 + 2 + 3 + 4 + 5 = 15 1 + 2 + 3 + 4 + 5 + 6 = 21 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 = 36 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = 55","title":"Summe 1 bis n"},{"location":"iteration/#fakultat-von-n","text":"Die Fakult\u00e4t von n ist definiert als n! = 1 * 2 * ... * n f\u00fcr alle Nat\u00fcrlichen Zahlen n>=1 . Wir schreiben uns daf\u00fcr eine Methode und \u00fcbergeben ein n : Fakult\u00e4t von n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public static void fakultaetVonN ( int n ) { int product = 1 ; String s = \"!\" ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i == 2 ) { s += \" = 1 * 2\" ; } else if ( i > 2 ) { s += \" * \" + i ; } product *= i ; System . out . println ( i + s + \" = \" + product ); } } In der Variablen product speichern wir das Produkt aus den Faktoren 1 * 2 * ... * n . beachten Sie, dass product am Anfang den Wert 1 haben muss, um nicht immer mit 0 zu multiplizieren und somit w\u00e4re das Produkt immer 0 . Anstelle von product *= i; h\u00e4tten wir auch product = product * i; schreiben k\u00f6nnen. Weil wir unseren Ausgabestring s noch ein wenig komplizierter gestalttet haben, ist hier sogar eine Fallunterscheidung zwischen i==2 und i>2) notwendig. Ausgabe f\u00fcr den Aufruf `fakultaetVonN(8)` 1 ! = 1 2 ! = 1 * 2 = 2 3 ! = 1 * 2 * 3 = 6 4 ! = 1 * 2 * 3 * 4 = 24 5 ! = 1 * 2 * 3 * 4 * 5 = 120 6 ! = 1 * 2 * 3 * 4 * 5 * 6 = 720 7 ! = 1 * 2 * 3 * 4 * 5 * 6 * 7 = 5040 8 ! = 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 = 40320","title":"Fakult\u00e4t von n"},{"location":"iteration/#fibonacci-folge","text":"\u00dcbung Fibonacci-Folge Schreiben Sie ein Programm, das die Fibonacci-Folge auf der Konsole ausgibt. Die ersten beiden Werte der Fibonacci-Folge sind 0 und 1 . Die Berechnung der Folgezahlen soll in einer Schleife gemacht werden. Eine Fibonacci-Folge sieht wie folgt aus: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, \u2026 . Es gilt: eine Zahl n ist immer die Summe ihrer beiden Vorg\u00e4nger n-1 und n-2 .","title":"Fibonacci-Folge"},{"location":"iteration/#verschachtelte-for-schleifen","text":"In den bisherigen Beispielen haben wir immer genau eine for -Schleife ben\u00f6tigt, da wir \"nur\" etwas aufaddiert oder aufmultipliziert haben, um eine eindimensionale Folge zu berechnen oder auszugeben. Wir wissen aber bereits, dass in dem Anweisungsblock des Schleifenk\u00f6rpers jede beliebige Kontrollstruktur vorkommen kann, also eine Sequenz und/oder eine Iteration und/oder eine Selektion. Selektion und Sequenz haben wir in unseren Beispielen bereits verwendet. Nun wollen wir auch noch eine Schleife innerhalb der Schleife untersuchen.","title":"Verschachtelte for-Schleifen"},{"location":"iteration/#rechteck","text":"Angenommen, wir sollen ein Rechteck aus lauter * -zeichen auf die Konsole ausgeben und sowohl die Breite des Rechtecks als auch dessen H\u00f6he sind variabel. Am Ende soll also so ein Bild herauskommen: *********************** *********************** *********************** *********************** *********************** In diesem Beispiel ist die Breite 23 und die H\u00f6he 5 . Unsere \u00dcberlegungen sind zun\u00e4chst wie folgt: wir k\u00f6nnen nur zeilenweise ausgeben (spaltenweise geht nicht auf der Konsole) wir ben\u00f6tigen eine Schleife, um die 23 Sterne in einer Zeile auszugeben wir ben\u00f6tigen eine Schleife, um die 5 Zeilen auszugeben D.h. wir \u00fcberlegen uns zun\u00e4chst, wie wir eine Zeile ausgeben. Wir nehmen dazu an, wir haben eine int -Variable width , die uns die Breite des Rechtecks vorgibt (z.B. 23 ): 1 2 3 4 for ( int col = 0 ; col < width ; col ++ ) { System . out . print ( \"*\" ); } Wir geben also in einer Schleife eine Anzahl width von Sternen aus. Beachten Sie, dass die Laufvariable col (f\u00fcr column) mit 0 initialisert wird. Deshalb ist die Schleifenbedingung col < width . H\u00e4tten wir col <= width geschrieben, w\u00fcrde ein Stern zu viel ausgegeben (au\u00dfer, wir h\u00e4tten col mit 1 initialisiert). Sie m\u00fcssen die Initialisierung und die Bedingung immer gut aufeinander abstimmen! dass wir zur Ausgabe print(\"*\") statt println(\"*\") verwenden, weil sonst nach jedem Stern ein Zeilenumbruch erfolgen w\u00fcrde, die Sterne also nicht nebeneinander sondern untereinander ausgegeben w\u00fcrden. Nun \u00fcberlegen wir uns, wie wir die Zeilen ausgeben. Dazu nehmen wir an, wir haben eine int -Variable height , die uns die H\u00f6he des Rechtecks vorgibt (z.B. 5 ): 1 2 3 4 for ( int row = 0 ; row < height ; row ++ ) { // Hier soll jetzt eine Zeile ausgegeben werden } Wir geben also in einer Schleife eine Anzahl height von Zeilen aus aus. In jeder Zeile soll die Anzahl width von Sternen ausgegeben werden. Wir m\u00fcssen also die Schleife f\u00fcr die Sterne in die Schleife f\u00fcr die Zeilen einsetzen: 1 2 3 4 5 6 7 for ( int row = 0 ; row < height ; row ++ ) { for ( int col = 0 ; col < width ; col ++ ) { System . out . print ( \"*\" ); } } Jetzt heben wir nur noch ein kleines Problem. Nachdem wir unsere Zeile mit Sternen ausgegeben haben, steht der Kursor noch hinter dem zuletzt ausgegebenen Stern. Er sollte danach aber an den Anfang der neuen Zeile wandern. Wir m\u00fcssen also noch f\u00fcr einen Zeilenumbruch sorgen. das erledigen wir mit System.out.println(); . Diese Anweisung kommt nach der inneren Schleife in die \u00e4u\u00dfere Schleife. Die gesamte Methode sieht dann so aus: 1 2 3 4 5 6 7 8 9 10 11 public static void printRectangle ( int width , int height ) { for ( int row = 0 ; row < height ; row ++ ) { for ( int col = 0 ; col < width ; col ++ ) { System . out . print ( \"*\" ); } System . out . println (); } } Die Zeilen 3-10 beschreiben die \u00e4u\u00dfere for -Schleife und die Zeilen 5-8 die innere for -Schleife. Wir \"laufen\" einmal durch den Beginn unseres Programms durch. Angenommen, unsere Methode wird mit der Anweisung printRectangle(23,5); aufgerufen, d.h. die Variable width bekommt den Wert 23 und die Variable height den Wert 5 zugewiesen. Die Laufvariable row bekommt initial den Wert 0 . 0 ist kleiner als 5 und somit ist die Bedingung row < height true . Wir betreten also den Anweisungsblock der \u00e4u\u00dferen Schleife. Die erste Anweisung in diesem Anweisungsblock ist die innere for -Schleife. Diese wird nun vollst\u00e4ndig abgearbeitet, d.h. die Laufvariable col nimmt alle Werte von 0 bis 22 an und gibt jedes Mal (also 23 Mal) einen * aus. Wenn der Wert von col auf 23 gesetzt wurde, ist die Bedingung col < width nicht mehr true sondern false und die Abarbeitung der Schleife ist beendet. Es wird Zeile 9 und somit ein Zeilenumbruch ausgef\u00fchrt. Dann wird der Wert von row um 1 erh\u00f6ht ( row++ ) und hat somit den Wert 1 . Die Bedingung row < height ist true und somit wird erneut der Anweisungsblock der \u00e4u\u00dferen Schleife ausgef\u00fchrt. Wieder ist die erste Anweisung in diesem Anweisungsblock die innere for -Schleife. Diese wird nun wieder vollst\u00e4ndig abgearbeitet, d.h. die Laufvariable col nimmt alle Werte von 0 bis 22 an und gibt jedes Mal (also 23 Mal) einen * aus. Wenn der Wert von col auf 23 gesetzt wurde, ist die Bedingung col < width nicht mehr true sondern false und die Abarbeitung der Schleife ist beendet. Es wird Zeile 9 und somit ein Zeilenumbruch ausgef\u00fchrt. Dann wird der Wert von row um 1 erh\u00f6ht ( row++ ) und hat somit den Wert 2 . Die Bedingung row < height ist true und somit wird erneut der Anweisungsblock der \u00e4u\u00dferen Schleife ausgef\u00fchrt. usw. bis der Wert von row 5 ist. Dann wird die \u00e4u\u00dfere for -Schleife verlassen und die Abarbeitung der Methode ist beendet. Wichtig ist, dass die innere Schleife jedes Mal vollst\u00e4ndig abgearbeitet wird, ehe der Zeilenumbruch erfolgt und dann der Wert von row erh\u00f6ht wird. Wir \u00e4ndern die Ausgabe unserer Methode mal ein wenig, um das Prinzip besser zu erkennen: 1 2 3 4 5 6 7 8 9 10 11 12 public static void printRectangle ( int width , int height ) { for ( int row = 0 ; row < height ; row ++ ) { System . out . print ( \"(row = \" + row + \"): \" ); for ( int col = 0 ; col < width ; col ++ ) { System . out . print ( \"[col = \" + col + \"]\" ); } System . out . println (); } } F\u00fcr den Aufruf der Methode printRectangle(10,5); erhalten wir dann folgende Ausgabe: ( row = 0 ) : [ col = 0 ][ col = 1 ][ col = 2 ][ col = 3 ][ col = 4 ][ col = 5 ][ col = 6 ][ col = 7 ][ col = 8 ][ col = 9 ] ( row = 1 ) : [ col = 0 ][ col = 1 ][ col = 2 ][ col = 3 ][ col = 4 ][ col = 5 ][ col = 6 ][ col = 7 ][ col = 8 ][ col = 9 ] ( row = 2 ) : [ col = 0 ][ col = 1 ][ col = 2 ][ col = 3 ][ col = 4 ][ col = 5 ][ col = 6 ][ col = 7 ][ col = 8 ][ col = 9 ] ( row = 3 ) : [ col = 0 ][ col = 1 ][ col = 2 ][ col = 3 ][ col = 4 ][ col = 5 ][ col = 6 ][ col = 7 ][ col = 8 ][ col = 9 ] ( row = 4 ) : [ col = 0 ][ col = 1 ][ col = 2 ][ col = 3 ][ col = 4 ][ col = 5 ][ col = 6 ][ col = 7 ][ col = 8 ][ col = 9 ] Durch die Verschachtelung der for -Schleife erzeugen wir somit eine 2-dimensionale Ausgabe. Die innere Schleife entwickelt die horizontale Dimension (eine Zeile mit width Sternen) und die \u00e4u\u00dfere for -Schleife entwickelt entwickelt die vertikale Dimension ( height viele Zeilen). Wir schauen uns noch ein Beispiel an. Nun ist die Bedingung der inneren Schleife vom Wert der Alufvariablen der \u00e4u\u00dferen Schleife abh\u00e4ngig.","title":"Rechteck"},{"location":"iteration/#dreieck","text":"Angenommen, wir wollen ein gleichschenkliges rechteckiges Dreieck erzeugen. Dazu \u00fcbergeben wir die H\u00f6he des Dreiecks als Wert. Angenommen, wir wollen ein Dreieck der H\u00f6he 7 , dann soll folgende Ausgabe erscheinen: * ** *** **** ***** ****** ******* Unsere \u00e4u\u00dfere Schleife wird sicherlich so aussehen, wie unsere \u00e4u\u00dfere Schleife beim Rechteck. Angenommen, unsere H\u00f6he ist in der Variablen height gespeichert, dann m\u00fcssen wir height viele Zeilen ausgeben: 1 2 3 4 for ( int row = 0 ; row < height ; row ++ ) { // Hier soll jetzt eine Zeile ausgegeben werden } Daran hat sich also nichts ge\u00e4ndert, aber die innere Schleife sieht sicherlich anders aus, denn wir haben keine width -Variable mehr. Die Anzahl der Sterne in einer Zeile ist nicht konstant, sondern h\u00e4ngt davon ab, in welcher Zeile wir uns befinden: Zeile 1 : row == 0 : 1 Stern ausgeben Zeile 2 : row == 1 : 2 Sterne ausgeben Zeile 3 : row == 2 : 3 Sterne ausgeben Zeile 4 : row == 3 : 4 Sterne ausgeben Zeile 5 : row == 4 : 5 Sterne ausgeben Zeile 6 : row == 5 : 6 Sterne ausgeben Zeile 7 : row == 6 : 7 Sterne ausgeben Das bedeutet, die Bedingung der inneren Schleife muss sich \u00e4ndern. Sie muss abh\u00e4ngig sein vom Wert von row : 1 2 3 4 for ( int col = 0 ; col <= row ; col ++ ) { System . out . print ( \"*\" ); } Wenn row den Wert 0 hat, wird die Schleife 1 Mal durchlaufen, Wert 1 hat, wird die Schleife 2 Mal durchlaufen, Wert 2 hat, wird die Schleife 3 Mal durchlaufen, usw. Die gesamte Methode sieht dann so aus: 1 2 3 4 5 6 7 8 9 10 11 public static void printTriangle ( int height ) { for ( int row = 0 ; row < height ; row ++ ) { for ( int col = 0 ; col <= row ; col ++ ) { System . out . print ( \"*\" ); } System . out . println (); } }","title":"Dreieck"},{"location":"iteration/#2-schleifen-in-einer-schleife","text":"Wir betrachten noch ein letztes Beispiel. Wir k\u00f6nnten Schleifen nat\u00fcrlich noch weiter verschachteln, also noch eine weitere Schleife in der inneren Schleife implementieren. Das ist m\u00f6glich, wird aber schnell un\u00fcbersichtlich. Prinzipiell ist die Verschachtelungstiefe aber unbegrenzt endlich. Stattdessen wollen wir uns in unserem letzten Beispiel aber einmal \u00fcberlegen, wie wir erneut ein gleichschenkliges rechtwinkliges Dreieck erzeugen k\u00f6nnten. Dieses Mal soll es aber nicht \"linksb\u00fcndig\", sondern \"rechtsb\u00fcndig\" sein, also so: * ** *** **** ***** ****** ******* Der Unterschied zum oberen Beispiel ist der, dass wir nun immer erst eine bestimmte Anzahl an Leerzeichen ausgeben m\u00fcssen, ehe wir den ersten Stern ausgeben. Dazu \u00fcberlegen wir uns wieder die Abh\u00e4ngigkeiten f\u00fcr ein Dreieck der H\u00f6he 7 : Zeile 1 : row == 0 : 6 Leerzeichen ausgeben + 1 Stern ausgeben ( height == 7 ) Zeile 2 : row == 1 : 5 Leerzeichen ausgeben + 2 Sterne ausgeben ( height == 7 ) Zeile 3 : row == 2 : 4 Leerzeichen ausgeben + 3 Sterne ausgeben ( height == 7 ) Zeile 4 : row == 3 : 3 Leerzeichen ausgeben + 4 Sterne ausgeben ( height == 7 ) Zeile 5 : row == 4 : 2 Leerzeichen ausgeben + 5 Sterne ausgeben ( height == 7 ) Zeile 6 : row == 5 : 1 Leerzeichen ausgeben + 6 Sterne ausgeben ( height == 7 ) Zeile 7 : row == 6 : 0 Leerzeichen ausgeben + 7 Sterne ausgeben ( height == 7 ) Die \u00e4u\u00dfere Schleife bleibt wieder so wie vorher: 1 2 3 4 for ( int row = 0 ; row < height ; row ++ ) { // Hier soll jetzt eine Zeile ausgegeben werden } Allerdings ist die Ausgabe einer Zeile nun in 2 Aufgaben zerlegt. Zuerst eine bestimmte Anzahl von Leerzeichen ausgeben und dann eine bestimmte Anzahl von Sternen: 1 2 3 4 5 6 for ( int row = 0 ; row < height ; row ++ ) { // zuerst muss eine bestimmte Anzahl von Leerzeichen ausgegeben werden // dann wird eine bestimmte Anzahl von Sternen ausgegeben } F\u00fcr die Anzahl von Sternen haben wir bereits eine L\u00f6sung, die wir verwenden k\u00f6nnen: 1 2 3 4 for ( int col = 0 ; col <= row ; col ++ ) { System . out . print ( \"*\" ); } Diese Schleife k\u00f6nnen wir schonmal in unsere \u00e4u\u00dfere Schleife einsetzen: 1 2 3 4 5 6 7 8 9 for ( int row = 0 ; row < height ; row ++ ) { // zuerst muss eine bestimmte Anzahl von Leerzeichen ausgegeben werden for ( int col = 0 ; col <= row ; col ++ ) { System . out . print ( \"*\" ); } } So wie die Anzahl von Sternen abh\u00e4ngig von der Zeile ist, in der wir die Sterne ausgeben, so ist auch die Anzahl der Leerzeichen davon abh\u00e4ngig. Allerdings beginnen wir mit einem gr\u00f6\u00dferen Wert und werden dann immer kleiner (von 6 bis 0 bei der H\u00f6he height==7 ). Die Anzahl der auszugebenden Leerzeichen ist also einerseits abh\u00e4ngig von der Gesamth\u00f6he ( height ) und andererseits von der aktuellen Zeile row . Wir \u00fcberlegen uns, mit welchem Startwert wir beginnen: am Anfang wollen wir 6 leerzeichen ausgeben, das sind height-1 viele. Danach ziehen wir von diesem Wert immer so viele ab, wie row gro\u00df ist, also erst -0 , dann -1 , dann -2 usw. Der Startwert ist also height -1 - row . In der letzten Zeile hat row den Wert 6 . Dann w\u00e4re unser Startwert height -1 - 6 == 7 - 1 - 6 == 0 . In der letzten Zeile wollen wir aber gar kein Leerzeichen mehr ausgeben, also muss dort schon unsere Bedingung false sein. Also setzen wir die Bedingung auf >0 . Die Schleife f\u00fcr die Ausgabe der Leerzeichen ist dann wie folgt: 1 2 3 4 for ( int spaces = height - 1 - row ; spaces > 0 ; spaces -- ) { System . out . print ( \" \" ); } F\u00fcr viele ist eine solche Schleife schwer zu lesen, da sich der Wert der ALufvariablen reduziert und die Ermittlung des Initialwertes gleich 2 Subtraktionen enth\u00e4lt. Wir haben ja bereits eingangs gesagt, dass eine solche Schleife auch \u00e4quivalent in anderer Form geschrieben werden kann. Das gleiche Ergebnis erhalten wir mit der folgenden Implementierung: 1 2 3 4 for ( int spaces = 1 ; spaces < height - row ; spaces ++ ) { System . out . print ( \" \" ); } \u00dcbung Schleife, initaile Werte und Bedingungen Warum sind die beiden oberen Schleifen identisch? Warum sind die beiden folgenden Schleifen nur fast identisch? Was ist der Unterschied in den Beispielen? 1 2 3 4 for ( int i = 0 ; i < 5 ; i ++ ) { System . out . println ( i ); } 1 2 3 4 for ( int i = 5 ; i > 0 ; i -- ) { System . out . println ( i ); } Die gesamte Methode sieht dann so aus: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public static void printTriangleR ( int height ) { for ( int row = 0 ; row < height ; row ++ ) { for ( int spaces = 1 ; spaces < height - row ; spaces ++ ) { System . out . print ( \" \" ); } for ( int col = 0 ; col <= row ; col ++ ) { System . out . print ( \"*\" ); } System . out . println (); } } \u00dcbung linksb\u00fcndiges Dreieck Schreiben Sie die Methode printTriangle(int height) so um, dass bei z.B. printTriangle(7); nicht folgende Ausgabe ensteht: * ** *** **** ***** ****** ******* sondern folgende: * * * * * * * * * * * * * * * * * * * * * * * * * * * * \u00dcbung rechtsb\u00fcndiges Dreieck Schreiben Sie die Methode printTriangleR(int height) so um, dass bei z.B. printTriangleR(7); nicht folgende Ausgabe ensteht: * ** *** **** ***** ****** ******* sondern folgende: * * * * * * * * * * * * * * * * * * * * * * * * * * * * Success Wir haben for -Schleifen kennengelernt und k\u00f6nnen damit nun auch Iterationen implementieren. for -Schleifen verwenden wir, wenn wir einen Anweisungsblock eine bestimmte Anzahl oft wiederholt ausf\u00fchren m\u00f6chten. Wir haben auch for -Schleifen verschachtelt, um variabel in mehrere Dimensionen zu sein. und wir haben mehrere for -Schleifen innerhalb einer for -Schleife verwendet. Nun lernen wir noch zwei weitere Schleifen kennen.","title":"2 Schleifen in einer Schleife"},{"location":"iteration/#die-while-schleife","text":"W\u00e4hrend die Anzahl der Ausf\u00fchrungen einer for -Schleife von einem numerischen Wert festgelegt wird, ist die Anzahl der Ausf\u00fchrungen einer while -Schleife von einem logischen Ausdruck abh\u00e4ngig. Prinzipiell muss man jedoch sagen, dass es auch v\u00f6llig gen\u00fcgen w\u00fcrde, wenn man nur for -Schleifen oder nur while -Schleifen in einer Programmiersprache zur Verf\u00fcgung h\u00e4tte. Man kann mit beiden Schleifenarten (und sp\u00e4ter auch mit der do..while -Schleife) alle Iterationen implemnetieren, die programmierbar sind. Schauen wir uns zun\u00e4chst die allgemeine Syntax einer while -Schleife an: while ( BEDINGUNG ) { /* * Anweisungsblock, der wiederholt * werden soll */ } Eine while -Schleife ist also auf den ersten Blick weniger komplex als eine for -Schleife. Da wir aber gesagt haben, dass man mit beiden Schleifenarten die gleichen Programme umsetzen kann, schauen wir uns die ersten Beispiele der for -Schleife mal als while -Schleife an: 1 2 3 4 5 6 int i = 0 ; while ( i < 5 ) { System . out . println ( i ); i ++ ; } Diese while -Schleife macht genau das gleiche, wie unser erstes Beispiel f\u00fcr die for -Schleife. Es wird eine Variable i deklariert und mit 0 initialisiert. Als Bedingung unserer while -Schleife wird gepr\u00fcft, ob der Wert von i kleiner als 5 ist. Wenn ja, wird dieser Wert ausgegeben und der Wert von i um 1 erh\u00f6ht. Nun wird wieder gepr\u00fcft, ob der Wert von i immer noch kleiner als 5 ist. Wenn ja, wird der Wert ausgegeben und um 1 erh\u00f6ht usw. Es scheint zun\u00e4chst, als w\u00e4re diese beiden Schleifenarten v\u00f6llig redundant. Was bedeutet es nun, dass eine for -Schleife von einer bestimmten Anzahl und eine while -Schleife von einer Bedingung abh\u00e4ngig ist? Sehen wir uns dazu nochmal unsere beiden Beispielalgorithmen vom Anfang an: der Euklidische Algrorithmus und die (3n+1)-Vermutung (Collatz-Problem) Die Beschreibung der Iteration beim Eukidischen Algorithmus war solange a ungleich b ist, wiederhole . Das bedeutet, dass die Bedingung f\u00fcr die Schleifenwiederholung a ungleich b ist. Nach wieviel Wiederholungen (also nach welcher Anzahl ) l\u00e4sst sich nicht sagen. Es l\u00e4sst sich aber leicht die Bedingung formulieren, die gelten soll, damit die Schleife erneut ausgef\u00fchrt wird, n\u00e4mlich (a!=b) . Das gleiche gilt f\u00fcr die (3n+1)-Vermutung. Dort lautet die Beschreibung der Iteration solange n ungleich 1 ist, wiederhole . Nach wieviel Wiederholungen (also nach welcher Anzahl ) l\u00e4sst sich vorher nicht sagen, aber die Bedingung daf\u00fcr, dass die Schleife erneut wiederholt werden soll, l\u00e4sst sich leicht formulieren, n\u00e4mlich (n!=1) .","title":"Die while-Schleife."},{"location":"iteration/#implementierung-des-euklidischen-algorithmus","text":"Mithilfe der while -Schleife implementieren wir nun mal beide Allgorithmen. Zuerst den Euklidischen Algorithmus: Berechnung des ggT nach Euklid 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public static void berechneGGT ( int a , int b ) { while ( a != b ) { if ( a > b ) { a = a - b ; } else { b = b - a ; } } System . out . println ( \"ggT: \" + a ); } Die Ausgabe f\u00fcr z.B. berechneGGT(24, 40); ist 8 . Ver\u00e4nderung der Werte von Parametern in Methoden In unserer Methode zur Berechnung des gr\u00f6\u00dften gemeinsamen Teilers nach Euklid haben wir die Werte der Parameter a und b innerhalb unserer Methode ge\u00e4ndert (siehe a = a -b; und b = b - a; ). Das ist kein guter Stil! So haben wir z.B. nicht die M\u00f6glichkeit, am Ende der Methode eine Ausgabe der Form Der ggT von 24 und 40 ist 8. zu erstellen, da wir auf die Werte 24 (von a ) und 40 (von b ) keinen Zugriff mehr haben. Wir sollten uns angew\u00f6hnen, die Parameterwerte in Methoden nicht zu \u00e4ndern, sondern lieber mit Kopien der Werte zu rechnen. Sp\u00e4ter werden wir unsere Parameter als Konstanten definieren, dann ist eine \u00c4nderung gar nicht m\u00f6glich. Das folgende Beispiel zeigt eine bessere L\u00f6sung: Berechnung des ggT nach Euklid (ohne \u00c4nderung der Parameterwerte) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public static void berechneGGT ( int a , int b ) { int nr1 = a ; int nr2 = b ; while ( nr1 != nr2 ) { if ( nr1 > nr2 ) { nr1 = nr1 - nr2 ; } else { nr2 = nr2 - nr1 ; } } System . out . println ( \"Der ggT von \" + a + \" und \" + b + \" ist \" + nr1 ); } Die Ausgabe f\u00fcr z.B. berechneGGT(24, 40); ist nun Der ggT von 24 und 40 ist 8 .","title":"Implementierung des Euklidischen Algorithmus"},{"location":"iteration/#implementierung-der-3n1-vermutung","text":"Mithilfe der while -Schleife k\u00f6nnen wir nun auch die (3n+1)-Vermutung (Collatz-Problem) geeignet implementieren: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public static void printCollatzFolge ( int n ) { int number = n ; while ( number != 1 ) { System . out . print ( number + \" \" ); if ( number % 2 == 0 ) { number = number / 2 ; } else { number = 3 * number + 1 ; } } System . out . println ( number ); } Auch hier kopieren wir zun\u00e4chst den Wert des Parameters, um diesen nicht zu \u00e4ndern. Mithilfe von number%2 == 0 pr\u00fcfen wir, ob number gerade oder ungerade ist. Ist number gerade, teilen wir den Wert durch 2 , ist number ungerade, multiplizieren wir den Wert mit 3 und addieren 1 , um jeweils den Nachfolger zu ermitteln. Solange dieser NAchfolger ungleich 1 ist, wird der n\u00e4chste Nachfolger berechnet usw. Die Ausf\u00fchrung der methode mit z.B. printCollatzFolge(17); erzeugt folgende Ausgabe: 17 52 26 13 40 20 10 5 16 8 4 2 1 . Wir beginnen mit 17 . Diese Zahl ist ungerade, also ist der Nachfolger 52 . Diese Zahl und auch der Nachfolger 26 sind gerade. Der n\u00e4chste Nachfolger 13 ist ungerade, dann kommen drei gerade Zahlen 40 , 20 und 10 und erst dann wieder eine ungerade Zahl 5 . 16 ist dann aber schon eine Potenz von 2 und somit endet die Folge mit der 1 . \u00dcbungen while -Schleife Nat\u00fcrlich kann eine while -Schleife genau wie die for -Schleife verschachtelt werden. Implementieren Sie das Rechteck das linksb\u00fcndige Dreieck und das rechtsb\u00fcndige Dreieck mithilfe von verschachtelten while -Schleifen.","title":"Implementierung der (3n+1)-Vermutung"},{"location":"iteration/#die-dowhile-schleife","text":"Wir haben ja bereits bei den for - und while -Schleifen erw\u00e4hnt, dass eines der beiden Konzepte gen\u00fcgt h\u00e4tte, um alle Iterationen zu implementieren. Da man aber ganz gute Unterscheidungsm\u00f6glichkeiten hat, um sich entweder f\u00fcr die for -Schleife (bestimmte Anzahl) oder f\u00fcr die while -Schleife (bestimmte Bedingung) zu entscheiden, haben beide Schleifenarten ihre Berechtigungsexistenz. F\u00fcr die do ... while f\u00e4llt die Abgrenzung zur while -Schleife noch schwerer. Generell l\u00e4sst sich sagen, dass eine while -Schleife nicht unebdingt ausgef\u00fchrt werden muss (n\u00e4mlich dann, wenn die Bedingung bereits ganz zu Anfang schon false ist), eine do ... while -Schleife wird aber zumindest ein Mal ausgef\u00fchrt, da die Pr\u00fcfung der Bedingung erst nach dem Schleifendurchlauf erfolgt. Die allgemeine Syntax einer do ... while -Schleife ist wie folgt: do { /* * Anweisungsblock, der wiederholt * werden soll */ } while ( BEDINGUNG ); Beachten Sie das Semikolon hinter der Bedingung! Es gibt Beispiele f\u00fcr den sinnvollen Einsatz von do ... while -Schleifen, z.B. wenn innerhalb der Schleife eine Eingabe erfolgt und die Bedingung pr\u00fcft, ob es sich um eine korrekte Eingabe handelt. Wir werden uns aber zun\u00e4chst nicht weiter um diese Schleife k\u00fcmmern, da sie nicht wirklich notwendig ist und wir uns haupts\u00e4chlich mit for - und while -Schleifen besch\u00e4ftigen werden.","title":"Die do...while-Schleife"},{"location":"iteration/#break-und-continue","text":"break und continue In (fast) allen Java-B\u00fcchern liest man in dem Kapitel \u00fcber Schleifen auch davon, dass es die beiden Anweisungen break; und continue; gibt. Ich will hier gar nicht darauf eigehen, was diese beiden Anweisungen machen, nur so viel: sie springen aus Schleifen heraus. Solche Art von \"Spr\u00fcngen\" ( go to statements ) geh\u00f6ren nicht in moderne, gute Programme. Wir nutzen diese Anweisungen nicht!!! Stattdessen sei in diesem Zusammenhang ein ber\u00fchmtes Papier von Edsger W. Dijkstra empfohlen: Go To Statement Considered Harmful . Siehe dazu auch hier .","title":"break und continue"},{"location":"methoden/","text":"Methoden \u00b6 Bis jetzt haben wir unseren Programmcode stets in die main() -Methode geschrieben. Das wird auf Dauer viel zu un\u00fcbersichtlich. Au\u00dferdem versto\u00dfen wir so gegen zwei wichtige Prinzipien der Programmierung: dem Single Responsibility Principle (SRP) und Don't repeat yourself (DRY) . Die urspr\u00fcngliche Formulierung des SRP stammt von Robert C. Martin , der es als ein Prinzip der Objektorientierung einf\u00fchrte und es ein wenig anders meinte, als wir es hier verwenden. Dazu kommen wir, wenn wir uns mit Objektorientierung besch\u00e4ftigen. Wir k\u00f6nnen uns aber als wesentliche Prinzipien schonmal merken, dass eine Variable genau eine Bedeutung haben soll und niemals f\u00fcr verschiedene Bedeutungen benutzt werden sollte (zwei Bedeutungen == zwei Variablen) und eine Methode genau eine Sache erledigen sollte. Zun\u00e4chst schauen wir uns an, was eine Methode \u00fcberhaupt ist und wie wir sie definieren und verwenden. Angenommen, wir haben ein Programm in der folgenden Form: public class Methods { public static void main ( String [] args ) { int summand1 = 3 ; int summand2 = 4 ; int summe = summand1 + summand2 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summe ); // 3 + 4 = 7 summand1 = 5 ; summand2 = 9 ; summe = summand1 + summand2 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summe ); // 5 + 9 = 14 summand1 = - 115 ; summand2 = 999 ; summe = summand1 + summand2 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summe ); // -115 + 999 = 884 } } In dieser main() -Methode machen wir drei Mal das Gleiche, wir addieren 2 Summanden und geben das Ergebnis der Berechnung aus. Wir sehen insbesondere doppelten (sogar dreifachen) Code, d.h. wir wiederholen uns. Au\u00dferdem geben die vergebenen Namen nur an, wof\u00fcr die Variablen da sind, aber es gibt keine namentliche Beschreibung von dem, WAS wir tun. Methodendefinition \u00b6 Das wollen wir \u00e4ndern und laden den sich wiederholenden Code in eine Methode aus. Diese Methode nennen wir add() : 1 2 3 4 5 public static void add ( int summand1 , int summand2 ) { int summe = summand1 + summand2 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summe ); } Betrachten wir diese Definition einer Methode genauer: In Zeile 1 sehen wir den Methodenkopf : Das Schl\u00fcsselwort public besagt, dass diese Methode von allen anderen Klassen (die wir noch nicht haben) aufgerufen werden kann. Es handelt sich um eine \u00f6ffentliche Methode. Wir gehen darauf genauer ein, wenn wir uns mit Sichtbarkeitsmodifizierern besch\u00e4ftigen. Das Schl\u00fcsselwort static besagt, dass wir diese Methode verwenden (aufrufen) k\u00f6nnen, ohne eine Objekt der Klasse Methods erzeugen zu m\u00fcssen. Wir k\u00f6nnen derzeit eh noch keine Objekte erzeugen, also definieren wir zun\u00e4chst alle unsere Methoden als static ( statisch , Klassenmethode ). Das Schl\u00fcsselwort void steht daf\u00fcr, dass der Aufruf unserer Methode keinen Wert hat, d.h. der Aufruf dieser Methode ist eine Anweisung ohne Nebeneffekt. Wenn die Methode einen Wert haben soll, dann wird hier ein Datentyp eingetragen (sehen wir im n\u00e4chsten Beispiel). add ist der Methodenname. Hier gelten die Bedingungen, die wir an Bezeichner in Java haben. Methodennamen beginnen stets mit einem Kleinbuchstaben. Nach dem Methodennamen kommen runde Klammern und darin sogenannte Parameter . Parameter sind Variablen. Parameter werden in der Methodendefinition deklariert, aber nicht initialisiert. Parameter werden beim Aufruf der Methode initialisiert. In den Zeilen 2-5 steht der Methodenk\u00f6rper : Der Methodenk\u00f6rper ist ein Anweisungsblock. Er beginnt mit einer \u00f6ffnenden geschweiften Klammer { (Zeile 2 ) und endet mit einer schlie\u00dfenden geschweiften Klammer } (Zeile 5 ). Innerhalb dieses Anweisungsblocks k\u00f6nnen beliebig viele Anweisungen stehen. In Zeile 3 wird unter Verwendung der Werte der Variablen (Parameter) summand1 und summand2 eine Summe gebildet und in der Variablen summe vom Typ int gespeichert. Die Werte der Parameter und der Summe werden in Zeile 4 geeignet auf die Konsole ausgegeben. Die Definition einer Methode erfolgt immer innerhalb einer Klasse und au\u00dferhalb jeder anderen Methode. Methodenaufruf \u00b6 In der main() -Methode wird unsere Methode nun aufgerufen. Wichtig ist es zu beachten, dass wir exakt den gleichen Namen f\u00fcr die Methode verwenden, wie in der Methodendefinition angegeben (Gro\u00df- und Kleinschreibung beachten!) und dass der Methode in den runden Klammern Werte f\u00fcr die Parameter \u00fcbergeben werden. Dabei m\u00fcssen die Anzahl der Parameter und der jeweilige Typ der Parameter mit dem Aufruf \u00fcbereinstimmen. Hier nochmal die gesamte Klasse Methods mit den Aufrufen der add() -Methode in main() : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Methods { public static void add ( int summand1 , int summand2 ) { int summe = summand1 + summand2 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summe ); } public static void main ( String [] args ) { add ( 3 , 4 ); add ( 5 , 9 ); add ( - 115 , 999 ); } } In der main() -Methode wird nun drei Mal unsere neue add() -Methode aufgerufen. Bei jedem Aufruf werden Werte f\u00fcr die Parameter \u00fcbergeben. Der Aufruf der Methode entspricht einer Anweisung (Semikolon am Ende). Der Aufruf der add() -Methode entspricht keinem Ausdruck, da der Aufruf dieser Methode ohne Wert ist. Dies liegt daran, dass in der Methodendefinition angegeben wurde, dass der Wert der Methode void ist - also kein Wert, kein Typ. Beachten Sie, dass in der Klasse Methods nun zwei Methoden definiert sind, main() und add() . Die main() -Methode ist die Programmmethode , die automatisch ausgef\u00fchrt wird, sobald wir das Programm starten. Damit die add() -Methode ausgef\u00fchrt wird, muss sie aufgerufen werden. Beachte Es werden nur alle Anweisungen ausgef\u00fchrt, die in der main() -Methode enthalten sind! Wird add() nie in main() aufgerufen, wird add() auch niemals ausgef\u00fchrt. Die Definition der Methode allein sorgt noch nicht f\u00fcr dessen Ausf\u00fchrung! Ausf\u00fchrung des Programms im Detail \u00b6 Wir schauen uns die Ausf\u00fchrung des obigen Programms nochmal im Detail an, um die Aufrufe genauer zu analysieren: durch das Starten des Programms wird die main() -Methode aufgerufen (Zeile 9 ) die erste Anweisung in der main() -Methode ist add(3,4); (Zeile 11 ) dadurch wird die add() -Methode aufgerufen (Zeile 3 ) durch den Aufruf werden die Parameter der Methode deklariert und initialisiert, d.h. int summand1 = 3 und int summand2 = 4 (Zeile 3 ) die erste Anweisung in der Methode add() ist int summe = summand1 + summand2; . dadurch wird die Variable summe deklariert und bekommt den Wert des Ausdrucks summand1 + summand2 initial zugewiesen. Dieser Wert ist 7 . (Zeile 5 ) Es wird die Methode System.out.println() aufgerufen. Der auszugebene String ergibt sich aus summand1 + \" + \" + summand2 + \" = \" + summe . Der Wert (vom Typ String ) dieses Ausdrucks ergibt sich aus: summand1 + \" + \" ist ein Konkatenation; das Ergebnis ist \"3 + \" . \"3 + \" + summand2 ist ebenfalls eine Konkatenation; das Ergebnis ist \"3 + 4\" . \"3 + 4\" + \" = \" ist ebenfalls eine Konkatenation; das Ergebnis ist \"3 + 4 = \" . \"3 + 4 = \" + summe ist ebenfalls eine Konkatenation; das Ergebnis ist \"3 + 4 = 7\" . Nach Ausgabe des Strings in Zeile 6 ist die Abarbeitung der add() -Methode beendet. Diese Methode wird verlassen und es wird zur\u00fcck zur main() -Methode gegangen. die n\u00e4chste Anweisung in der main() -Methode ist add(5,9); (Zeile 12 ) dadurch wird erneut die add() -Methode aufgerufen (Zeile 3 ) durch den Aufruf werden die Parameter der Methode deklariert und initialisiert, d.h. int summand1 = 5 und int summand2 = 9 (Zeile 3 ) die erste Anweisung in der Methode add() ist int summe = summand1 + summand2; . dadurch wird die Variable summe deklariert und bekommt den Wert des Ausdrucks summand1 + summand2 initial zugewiesen. Dieser Wert ist 14 . (Zeile 5 ) Es wird die Methode System.out.println() aufgerufen. Der auszugebene String ergibt sich aus summand1 + \" + \" + summand2 + \" = \" + summe . Der Wert (vom Typ String ) dieses Ausdrucks ist \"5 + 9 = 14\" . Nach Ausgabe des Strings in Zeile 6 ist die Abarbeitung der add() -Methode beendet. Diese Methode wird verlassen und es wird zur\u00fcck zur main() -Methode gegangen. die n\u00e4chste Anweisung in der main() -Methode ist add(-115,999); (Zeile 13 ) dadurch wird erneut die add() -Methode aufgerufen (Zeile 3 ) durch den Aufruf werden die Parameter der Methode deklariert und initialisiert, d.h. int summand1 = -115 und int summand2 = 999 (Zeile 3 ) die erste Anweisung in der Methode add() ist int summe = summand1 + summand2; . dadurch wird die Variable summe deklariert und bekommt den Wert des Ausdrucks summand1 + summand2 initial zugewiesen. Dieser Wert ist 884 . (Zeile 5 ) Es wird die Methode System.out.println() aufgerufen. Der auszugebene String ergibt sich aus summand1 + \" + \" + summand2 + \" = \" + summe . Der Wert (vom Typ String ) dieses Ausdrucks ist \"-115 + 999 = 884\" . Nach Ausgabe des Strings in Zeile 6 ist die Abarbeitung der add() -Methode beendet. Diese Methode wird verlassen und es wird zur\u00fcck zur main() -Methode gegangen. in der main() -Methode gibt es keine weitere Anweisung mehr. Das Programm ist beendet. Methode gibt einen Wert zur\u00fcck \u00b6 Unsere Methode add() hat keinen Wert zur\u00fcckgegeben. Das wurde im Methodenkopf festgelegt, wo wir mit void definiert haben, dass der Aufruf der Methode keinem Wert entspricht. Dies ist typisch f\u00fcr Methoden, die etwas auf die Konsole ausgeben. Alle Methoden, deren Aufgabe es ist, etwas auszugeben, sind (sollten sein) vom R\u00fcckgabetyp 1 void . Jetzt erstellen wir eine Methode computeSum() , die das gleiche macht wie add() , aber mit dem Unterschied, dass diese Methode nichts auf die Konsole ausgibt, sondern die Summe der beiden Parameter an den Aufrufer der Methode zur\u00fcckgibt . Die Definition dieser Methode sieht dann so aus: 1 2 3 4 5 public static int computeSum ( int summand1 , int summand2 ) { int summe = summand1 + summand2 ; return summe ; } Zwei ganz wesentliche Unterschiede zur Definition von add() fallen auf: Diese Methode hat einen R\u00fcckgabetyp ( int ). Dort, wo bei add() noch void stand, steht bei computeSum() im Methodenkopf int . Damit wird festgelegt, dass der Aufruf der Methode einem Wert entspricht, welcher vom Typ int ist. Der Aufruf dieser Methode ist somit ein Ausdruck! Die letzte Anweisung der Methode computeSum() ist eine Anweisung, die mit dem Schl\u00fcsselwort return beginnt. Jede Methode, die einen R\u00fcckgabetyp hat (also genau nicht void ), muss ein solches return enthalten. Dieses return muss die letzte Anweisung in der Methode sein und es muss einen Wert zur\u00fcckgeben, der von dem Typ ist, der f\u00fcr die Methode als R\u00fcckgabetyp definiert wurde. Hier ist es der Wert von summe . summe ist vom Typ int und somit ist return summe; korrekt, da die Methode ja ein int zur\u00fcckgeben soll. Aufruf einer Methode, die einen Wert zur\u00fcckgibt \u00b6 Unsere Methode computeSum() k\u00f6nnte nun in der main() -Methode wie folgt aufgerufen werden: computeSum ( 3 , 4 ); // korrekt, aber sinnlos Ein solcher Aufruf macht aber gar keinen Sinn, weil die Methode selbst ja z.B. nichts ausgibt und somit hat diese Methode gar keinen Effekt. Sinnvoll eingesetzt werden kann eine solche Methode nur als Ausdruck, z.B.: int sum = computeSum ( 3 , 4 ); // sum wird mit dem Wert 7 initialisiert System . out . println ( computeSum ( 5 , 9 )); // es wird 14 ausgegeben Der Aufruf der Methode ist somit ein arithmetischer Ausdruck und kann auch als solcher behandelt werden, z.B. mit anderen arithmetischen Ausdr\u00fccken mittels arithmetischer Operatoren zu einem weiteren arithmetischen Ausdruck verkn\u00fcpft werden. Hier noch weitere Beispiele f\u00fcr Methoden mit R\u00fcckgabe (hier R\u00fcckgabe vom Typ boolean ): public static boolean areEqual ( int nr1 , int nr2 ) { return ( nr1 == nr2 ); } public static boolean isDivider ( int nr1 , int nr2 ) { return ( nr1 % nr2 == 0 ); } Sie k\u00f6nnen auch Methoden in Methoden aufrufen. Nehmen wir die beiden Methoden areEqual(int, int) und isDivider(int, int) und angenommen, wir wollen f\u00fcr 2 int -Zahlen pr\u00fcfen, ob die eine Teiler der anderen ist, aber beide sollen nicht gleich sein, dann k\u00f6nnen wir folgende Methode schreiben: public static boolean isDividerButNotEqual ( int nr1 , int nr2 ) { return ( isDivider ( nr1 , nr2 ) && ! areEqual ( nr1 , nr2 )); } Das schauen wir uns einmal genauer an: wir definieren wieder eine Methode wie gehabt: wir vergeben einen Namen ( isDividerButNotEqual ) und wir legen fest, dass bei Aufruf der Methode zwei int -Werte \u00fcbergeben werden m\u00fcssen ( (int nr1, int nr2) ). als R\u00fcckgabetyp definieren wir boolean , denn wir wollen ja pr\u00fcfen, ob sich die beiden ganzzahlig teilen, aber nicht gleich sind innerhalb der Methode rufen wir die Methode isDivider(nr1, nr2) auf und \u00fcbergeben dabei unsere Werte f\u00fcr nr1 und nr2 . Der Aufruf dieser Methode entspricht einem boole schen Ausdruck, da diese Methode ein boolean zur\u00fcckgibt ( true , wenn nr2 Teiler von nr1 ist und false` sonst - also, wenn nicht) au\u00dferdem rufen wir die Methode areEqual(nr1, nr2) auf und \u00fcbergeben dabei ebenfalls unsere Werte f\u00fcr nr1 und nr2 . Der Aufruf dieser Methode entspricht ebenfalls einem boole schen Ausdruck, da diese Methode ein boolean zur\u00fcckgibt ( true , wenn nr1 und nr2 gleich sind und false` sonst - also, wenn nicht) wir wollen aber pr\u00fcfen, ob sie nicht gleich sind, also schreiben wir !areEqual(nr1, nr2) - also die Negation dieses Ausdrucks wir wollen pr\u00fcfen, ob isDivider(nr1, nr2) UND NICHT areEqual(nr1, nr2) , also isDivider(nr1, nr2) UND !areEqual(nr1, nr2) , also isDivider(nr1, nr2) && !areEqual(nr1, nr2) diesen Wert geben wir zur\u00fcck 1. \u00dcbung Methoden mit R\u00fcckgabe Schreiben Sie eine Methode isEven(int number) , die ein true zur\u00fcckgibt, wenn number gerade ist und sonst false . 1. \u00dcbung Methoden mit R\u00fcckgabe Schreiben Sie eine Methode isOdd(int number) , die ein true zur\u00fcckgibt, wenn number ungerade ist und sonst false . Dieses Mal verwenden Sie aber die Methode isEven() , um den richtigen Wert zu ermitteln. Success Wir k\u00f6nnen uns nun Methoden selber definieren. Die Definition von Methoden erfolgt innerhalb der Klasse, aber au\u00dferhalb jeder anderen Methode. Eine Methode kann entweder keinen Wert zur\u00fcckgeben. Dann ist der \"R\u00fcckgabetyp\" 1 void . Eine solche void -Methode gibt typischerweise etwas auf die Konsole aus. Oder die Methode gibt einen Wert zur\u00fcck. Dann wird der Datentyp dieses Wertes im Methodenkopf der Methodendefinition angegeben. Die R\u00fcckgabe des Wertes erfolgt durch return . Die return -Anweisung muss die letzte Anweisung in der Methode sein. Der Aufruf einer solchen Methode entspricht dann einem Ausdruck. Einer Methode k\u00f6nnen beliebig viele Parameter \u00fcbergeben werden. Diese lokalen Variablen werden im Methodenkopf in den runden Klammern durch Komma getrennt deklariert. Bei Aufruf der Methode m\u00fcssen diesen Variablen Werte \u00fcbergeben werden (Anzahl und Datentypen m\u00fcssen bei Methodenaufruf passen). void ist kein Datentyp! Man sagt aber, dass Methoden, die keinen Wert zur\u00fcckliefern, vom R\u00fcckgabetyp void sind. Ganz korrekt ist das also nicht, aber es fehlt ein besserer Ausdruck daf\u00fcr. \u21a9 \u21a9","title":"Methoden"},{"location":"methoden/#methoden","text":"Bis jetzt haben wir unseren Programmcode stets in die main() -Methode geschrieben. Das wird auf Dauer viel zu un\u00fcbersichtlich. Au\u00dferdem versto\u00dfen wir so gegen zwei wichtige Prinzipien der Programmierung: dem Single Responsibility Principle (SRP) und Don't repeat yourself (DRY) . Die urspr\u00fcngliche Formulierung des SRP stammt von Robert C. Martin , der es als ein Prinzip der Objektorientierung einf\u00fchrte und es ein wenig anders meinte, als wir es hier verwenden. Dazu kommen wir, wenn wir uns mit Objektorientierung besch\u00e4ftigen. Wir k\u00f6nnen uns aber als wesentliche Prinzipien schonmal merken, dass eine Variable genau eine Bedeutung haben soll und niemals f\u00fcr verschiedene Bedeutungen benutzt werden sollte (zwei Bedeutungen == zwei Variablen) und eine Methode genau eine Sache erledigen sollte. Zun\u00e4chst schauen wir uns an, was eine Methode \u00fcberhaupt ist und wie wir sie definieren und verwenden. Angenommen, wir haben ein Programm in der folgenden Form: public class Methods { public static void main ( String [] args ) { int summand1 = 3 ; int summand2 = 4 ; int summe = summand1 + summand2 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summe ); // 3 + 4 = 7 summand1 = 5 ; summand2 = 9 ; summe = summand1 + summand2 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summe ); // 5 + 9 = 14 summand1 = - 115 ; summand2 = 999 ; summe = summand1 + summand2 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summe ); // -115 + 999 = 884 } } In dieser main() -Methode machen wir drei Mal das Gleiche, wir addieren 2 Summanden und geben das Ergebnis der Berechnung aus. Wir sehen insbesondere doppelten (sogar dreifachen) Code, d.h. wir wiederholen uns. Au\u00dferdem geben die vergebenen Namen nur an, wof\u00fcr die Variablen da sind, aber es gibt keine namentliche Beschreibung von dem, WAS wir tun.","title":"Methoden"},{"location":"methoden/#methodendefinition","text":"Das wollen wir \u00e4ndern und laden den sich wiederholenden Code in eine Methode aus. Diese Methode nennen wir add() : 1 2 3 4 5 public static void add ( int summand1 , int summand2 ) { int summe = summand1 + summand2 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summe ); } Betrachten wir diese Definition einer Methode genauer: In Zeile 1 sehen wir den Methodenkopf : Das Schl\u00fcsselwort public besagt, dass diese Methode von allen anderen Klassen (die wir noch nicht haben) aufgerufen werden kann. Es handelt sich um eine \u00f6ffentliche Methode. Wir gehen darauf genauer ein, wenn wir uns mit Sichtbarkeitsmodifizierern besch\u00e4ftigen. Das Schl\u00fcsselwort static besagt, dass wir diese Methode verwenden (aufrufen) k\u00f6nnen, ohne eine Objekt der Klasse Methods erzeugen zu m\u00fcssen. Wir k\u00f6nnen derzeit eh noch keine Objekte erzeugen, also definieren wir zun\u00e4chst alle unsere Methoden als static ( statisch , Klassenmethode ). Das Schl\u00fcsselwort void steht daf\u00fcr, dass der Aufruf unserer Methode keinen Wert hat, d.h. der Aufruf dieser Methode ist eine Anweisung ohne Nebeneffekt. Wenn die Methode einen Wert haben soll, dann wird hier ein Datentyp eingetragen (sehen wir im n\u00e4chsten Beispiel). add ist der Methodenname. Hier gelten die Bedingungen, die wir an Bezeichner in Java haben. Methodennamen beginnen stets mit einem Kleinbuchstaben. Nach dem Methodennamen kommen runde Klammern und darin sogenannte Parameter . Parameter sind Variablen. Parameter werden in der Methodendefinition deklariert, aber nicht initialisiert. Parameter werden beim Aufruf der Methode initialisiert. In den Zeilen 2-5 steht der Methodenk\u00f6rper : Der Methodenk\u00f6rper ist ein Anweisungsblock. Er beginnt mit einer \u00f6ffnenden geschweiften Klammer { (Zeile 2 ) und endet mit einer schlie\u00dfenden geschweiften Klammer } (Zeile 5 ). Innerhalb dieses Anweisungsblocks k\u00f6nnen beliebig viele Anweisungen stehen. In Zeile 3 wird unter Verwendung der Werte der Variablen (Parameter) summand1 und summand2 eine Summe gebildet und in der Variablen summe vom Typ int gespeichert. Die Werte der Parameter und der Summe werden in Zeile 4 geeignet auf die Konsole ausgegeben. Die Definition einer Methode erfolgt immer innerhalb einer Klasse und au\u00dferhalb jeder anderen Methode.","title":"Methodendefinition"},{"location":"methoden/#methodenaufruf","text":"In der main() -Methode wird unsere Methode nun aufgerufen. Wichtig ist es zu beachten, dass wir exakt den gleichen Namen f\u00fcr die Methode verwenden, wie in der Methodendefinition angegeben (Gro\u00df- und Kleinschreibung beachten!) und dass der Methode in den runden Klammern Werte f\u00fcr die Parameter \u00fcbergeben werden. Dabei m\u00fcssen die Anzahl der Parameter und der jeweilige Typ der Parameter mit dem Aufruf \u00fcbereinstimmen. Hier nochmal die gesamte Klasse Methods mit den Aufrufen der add() -Methode in main() : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Methods { public static void add ( int summand1 , int summand2 ) { int summe = summand1 + summand2 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summe ); } public static void main ( String [] args ) { add ( 3 , 4 ); add ( 5 , 9 ); add ( - 115 , 999 ); } } In der main() -Methode wird nun drei Mal unsere neue add() -Methode aufgerufen. Bei jedem Aufruf werden Werte f\u00fcr die Parameter \u00fcbergeben. Der Aufruf der Methode entspricht einer Anweisung (Semikolon am Ende). Der Aufruf der add() -Methode entspricht keinem Ausdruck, da der Aufruf dieser Methode ohne Wert ist. Dies liegt daran, dass in der Methodendefinition angegeben wurde, dass der Wert der Methode void ist - also kein Wert, kein Typ. Beachten Sie, dass in der Klasse Methods nun zwei Methoden definiert sind, main() und add() . Die main() -Methode ist die Programmmethode , die automatisch ausgef\u00fchrt wird, sobald wir das Programm starten. Damit die add() -Methode ausgef\u00fchrt wird, muss sie aufgerufen werden. Beachte Es werden nur alle Anweisungen ausgef\u00fchrt, die in der main() -Methode enthalten sind! Wird add() nie in main() aufgerufen, wird add() auch niemals ausgef\u00fchrt. Die Definition der Methode allein sorgt noch nicht f\u00fcr dessen Ausf\u00fchrung!","title":"Methodenaufruf"},{"location":"methoden/#ausfuhrung-des-programms-im-detail","text":"Wir schauen uns die Ausf\u00fchrung des obigen Programms nochmal im Detail an, um die Aufrufe genauer zu analysieren: durch das Starten des Programms wird die main() -Methode aufgerufen (Zeile 9 ) die erste Anweisung in der main() -Methode ist add(3,4); (Zeile 11 ) dadurch wird die add() -Methode aufgerufen (Zeile 3 ) durch den Aufruf werden die Parameter der Methode deklariert und initialisiert, d.h. int summand1 = 3 und int summand2 = 4 (Zeile 3 ) die erste Anweisung in der Methode add() ist int summe = summand1 + summand2; . dadurch wird die Variable summe deklariert und bekommt den Wert des Ausdrucks summand1 + summand2 initial zugewiesen. Dieser Wert ist 7 . (Zeile 5 ) Es wird die Methode System.out.println() aufgerufen. Der auszugebene String ergibt sich aus summand1 + \" + \" + summand2 + \" = \" + summe . Der Wert (vom Typ String ) dieses Ausdrucks ergibt sich aus: summand1 + \" + \" ist ein Konkatenation; das Ergebnis ist \"3 + \" . \"3 + \" + summand2 ist ebenfalls eine Konkatenation; das Ergebnis ist \"3 + 4\" . \"3 + 4\" + \" = \" ist ebenfalls eine Konkatenation; das Ergebnis ist \"3 + 4 = \" . \"3 + 4 = \" + summe ist ebenfalls eine Konkatenation; das Ergebnis ist \"3 + 4 = 7\" . Nach Ausgabe des Strings in Zeile 6 ist die Abarbeitung der add() -Methode beendet. Diese Methode wird verlassen und es wird zur\u00fcck zur main() -Methode gegangen. die n\u00e4chste Anweisung in der main() -Methode ist add(5,9); (Zeile 12 ) dadurch wird erneut die add() -Methode aufgerufen (Zeile 3 ) durch den Aufruf werden die Parameter der Methode deklariert und initialisiert, d.h. int summand1 = 5 und int summand2 = 9 (Zeile 3 ) die erste Anweisung in der Methode add() ist int summe = summand1 + summand2; . dadurch wird die Variable summe deklariert und bekommt den Wert des Ausdrucks summand1 + summand2 initial zugewiesen. Dieser Wert ist 14 . (Zeile 5 ) Es wird die Methode System.out.println() aufgerufen. Der auszugebene String ergibt sich aus summand1 + \" + \" + summand2 + \" = \" + summe . Der Wert (vom Typ String ) dieses Ausdrucks ist \"5 + 9 = 14\" . Nach Ausgabe des Strings in Zeile 6 ist die Abarbeitung der add() -Methode beendet. Diese Methode wird verlassen und es wird zur\u00fcck zur main() -Methode gegangen. die n\u00e4chste Anweisung in der main() -Methode ist add(-115,999); (Zeile 13 ) dadurch wird erneut die add() -Methode aufgerufen (Zeile 3 ) durch den Aufruf werden die Parameter der Methode deklariert und initialisiert, d.h. int summand1 = -115 und int summand2 = 999 (Zeile 3 ) die erste Anweisung in der Methode add() ist int summe = summand1 + summand2; . dadurch wird die Variable summe deklariert und bekommt den Wert des Ausdrucks summand1 + summand2 initial zugewiesen. Dieser Wert ist 884 . (Zeile 5 ) Es wird die Methode System.out.println() aufgerufen. Der auszugebene String ergibt sich aus summand1 + \" + \" + summand2 + \" = \" + summe . Der Wert (vom Typ String ) dieses Ausdrucks ist \"-115 + 999 = 884\" . Nach Ausgabe des Strings in Zeile 6 ist die Abarbeitung der add() -Methode beendet. Diese Methode wird verlassen und es wird zur\u00fcck zur main() -Methode gegangen. in der main() -Methode gibt es keine weitere Anweisung mehr. Das Programm ist beendet.","title":"Ausf\u00fchrung des Programms im Detail"},{"location":"methoden/#methode-gibt-einen-wert-zuruck","text":"Unsere Methode add() hat keinen Wert zur\u00fcckgegeben. Das wurde im Methodenkopf festgelegt, wo wir mit void definiert haben, dass der Aufruf der Methode keinem Wert entspricht. Dies ist typisch f\u00fcr Methoden, die etwas auf die Konsole ausgeben. Alle Methoden, deren Aufgabe es ist, etwas auszugeben, sind (sollten sein) vom R\u00fcckgabetyp 1 void . Jetzt erstellen wir eine Methode computeSum() , die das gleiche macht wie add() , aber mit dem Unterschied, dass diese Methode nichts auf die Konsole ausgibt, sondern die Summe der beiden Parameter an den Aufrufer der Methode zur\u00fcckgibt . Die Definition dieser Methode sieht dann so aus: 1 2 3 4 5 public static int computeSum ( int summand1 , int summand2 ) { int summe = summand1 + summand2 ; return summe ; } Zwei ganz wesentliche Unterschiede zur Definition von add() fallen auf: Diese Methode hat einen R\u00fcckgabetyp ( int ). Dort, wo bei add() noch void stand, steht bei computeSum() im Methodenkopf int . Damit wird festgelegt, dass der Aufruf der Methode einem Wert entspricht, welcher vom Typ int ist. Der Aufruf dieser Methode ist somit ein Ausdruck! Die letzte Anweisung der Methode computeSum() ist eine Anweisung, die mit dem Schl\u00fcsselwort return beginnt. Jede Methode, die einen R\u00fcckgabetyp hat (also genau nicht void ), muss ein solches return enthalten. Dieses return muss die letzte Anweisung in der Methode sein und es muss einen Wert zur\u00fcckgeben, der von dem Typ ist, der f\u00fcr die Methode als R\u00fcckgabetyp definiert wurde. Hier ist es der Wert von summe . summe ist vom Typ int und somit ist return summe; korrekt, da die Methode ja ein int zur\u00fcckgeben soll.","title":"Methode gibt einen Wert zur\u00fcck"},{"location":"methoden/#aufruf-einer-methode-die-einen-wert-zuruckgibt","text":"Unsere Methode computeSum() k\u00f6nnte nun in der main() -Methode wie folgt aufgerufen werden: computeSum ( 3 , 4 ); // korrekt, aber sinnlos Ein solcher Aufruf macht aber gar keinen Sinn, weil die Methode selbst ja z.B. nichts ausgibt und somit hat diese Methode gar keinen Effekt. Sinnvoll eingesetzt werden kann eine solche Methode nur als Ausdruck, z.B.: int sum = computeSum ( 3 , 4 ); // sum wird mit dem Wert 7 initialisiert System . out . println ( computeSum ( 5 , 9 )); // es wird 14 ausgegeben Der Aufruf der Methode ist somit ein arithmetischer Ausdruck und kann auch als solcher behandelt werden, z.B. mit anderen arithmetischen Ausdr\u00fccken mittels arithmetischer Operatoren zu einem weiteren arithmetischen Ausdruck verkn\u00fcpft werden. Hier noch weitere Beispiele f\u00fcr Methoden mit R\u00fcckgabe (hier R\u00fcckgabe vom Typ boolean ): public static boolean areEqual ( int nr1 , int nr2 ) { return ( nr1 == nr2 ); } public static boolean isDivider ( int nr1 , int nr2 ) { return ( nr1 % nr2 == 0 ); } Sie k\u00f6nnen auch Methoden in Methoden aufrufen. Nehmen wir die beiden Methoden areEqual(int, int) und isDivider(int, int) und angenommen, wir wollen f\u00fcr 2 int -Zahlen pr\u00fcfen, ob die eine Teiler der anderen ist, aber beide sollen nicht gleich sein, dann k\u00f6nnen wir folgende Methode schreiben: public static boolean isDividerButNotEqual ( int nr1 , int nr2 ) { return ( isDivider ( nr1 , nr2 ) && ! areEqual ( nr1 , nr2 )); } Das schauen wir uns einmal genauer an: wir definieren wieder eine Methode wie gehabt: wir vergeben einen Namen ( isDividerButNotEqual ) und wir legen fest, dass bei Aufruf der Methode zwei int -Werte \u00fcbergeben werden m\u00fcssen ( (int nr1, int nr2) ). als R\u00fcckgabetyp definieren wir boolean , denn wir wollen ja pr\u00fcfen, ob sich die beiden ganzzahlig teilen, aber nicht gleich sind innerhalb der Methode rufen wir die Methode isDivider(nr1, nr2) auf und \u00fcbergeben dabei unsere Werte f\u00fcr nr1 und nr2 . Der Aufruf dieser Methode entspricht einem boole schen Ausdruck, da diese Methode ein boolean zur\u00fcckgibt ( true , wenn nr2 Teiler von nr1 ist und false` sonst - also, wenn nicht) au\u00dferdem rufen wir die Methode areEqual(nr1, nr2) auf und \u00fcbergeben dabei ebenfalls unsere Werte f\u00fcr nr1 und nr2 . Der Aufruf dieser Methode entspricht ebenfalls einem boole schen Ausdruck, da diese Methode ein boolean zur\u00fcckgibt ( true , wenn nr1 und nr2 gleich sind und false` sonst - also, wenn nicht) wir wollen aber pr\u00fcfen, ob sie nicht gleich sind, also schreiben wir !areEqual(nr1, nr2) - also die Negation dieses Ausdrucks wir wollen pr\u00fcfen, ob isDivider(nr1, nr2) UND NICHT areEqual(nr1, nr2) , also isDivider(nr1, nr2) UND !areEqual(nr1, nr2) , also isDivider(nr1, nr2) && !areEqual(nr1, nr2) diesen Wert geben wir zur\u00fcck 1. \u00dcbung Methoden mit R\u00fcckgabe Schreiben Sie eine Methode isEven(int number) , die ein true zur\u00fcckgibt, wenn number gerade ist und sonst false . 1. \u00dcbung Methoden mit R\u00fcckgabe Schreiben Sie eine Methode isOdd(int number) , die ein true zur\u00fcckgibt, wenn number ungerade ist und sonst false . Dieses Mal verwenden Sie aber die Methode isEven() , um den richtigen Wert zu ermitteln. Success Wir k\u00f6nnen uns nun Methoden selber definieren. Die Definition von Methoden erfolgt innerhalb der Klasse, aber au\u00dferhalb jeder anderen Methode. Eine Methode kann entweder keinen Wert zur\u00fcckgeben. Dann ist der \"R\u00fcckgabetyp\" 1 void . Eine solche void -Methode gibt typischerweise etwas auf die Konsole aus. Oder die Methode gibt einen Wert zur\u00fcck. Dann wird der Datentyp dieses Wertes im Methodenkopf der Methodendefinition angegeben. Die R\u00fcckgabe des Wertes erfolgt durch return . Die return -Anweisung muss die letzte Anweisung in der Methode sein. Der Aufruf einer solchen Methode entspricht dann einem Ausdruck. Einer Methode k\u00f6nnen beliebig viele Parameter \u00fcbergeben werden. Diese lokalen Variablen werden im Methodenkopf in den runden Klammern durch Komma getrennt deklariert. Bei Aufruf der Methode m\u00fcssen diesen Variablen Werte \u00fcbergeben werden (Anzahl und Datentypen m\u00fcssen bei Methodenaufruf passen). void ist kein Datentyp! Man sagt aber, dass Methoden, die keinen Wert zur\u00fcckliefern, vom R\u00fcckgabetyp void sind. Ganz korrekt ist das also nicht, aber es fehlt ein besserer Ausdruck daf\u00fcr. \u21a9 \u21a9","title":"Aufruf einer Methode, die einen Wert zur\u00fcckgibt"},{"location":"methodenstack/","text":"Methodenstack \u00b6 Programme und die dazugeh\u00f6rigen Variablen (und deren Werte) befinden sich zur Ausf\u00fchrung im Arbeitsspeicher. Der Speicher ist in Bl\u00f6cke (Bytes) unetrteilt, die jeweils adressierbar sind. So k\u00f6nnte alles jeweils eine Adresse zugeordnet werden und mit einer komplexen Adressverwaltung lie\u00dfen sich die Einzelteile ansprechen. Das ist jedoch viel zu aufwendig und inperformant. Deshalb werden Speichermodelle verwendet, die die Verwaltung der Programmteile erleichtern. Ein solches Speichermodell ist der Stack ( Stapelspeicher ). Bei einem Stack gilt das Last in first out (LIFO) Prinzip, also das, was zuletzt in den Stack kam, muss auch als erstes wieder hinaus. tats\u00e4chlich gibt es nur ganz wenige Funktionalit\u00e4ten, um einen solchen Stack zu verwalten: push : Element oben auf den Stack hinzuf\u00fcgen pop : Element von oben aus dem Stack entfernen top (manchmal auch peek genannt): auf oberes Element zugreifen (lesen, aber im Stack belassen) Folgende Abbildung stellt diese Methoden grafisch dar: F\u00fcr einen solchen Stack gibt es jetzt nur drei M\u00f6glichkeiten: Element E kann gelesen werden (aber im Stack belassen) - top Element E kann aus dem Stack entfernt werden - pop ein neues Element (z.B. F ) kann zum Stack hinzugef\u00fcgt werden - push (dann kann auch E nicht mehr gelesen werden; so wie bereits A - D ) Abarbeitung von Methoden \u00b6 Wir betrachten das Speichermodell Stack , weil die Abarbeitung von Methoden nach diesem Prinzip funktioniert. Methoden, die abgearbeitet (aufgerufen) werden, werden in einem solchen Stack angeordnet. Wir betrachten ein Beispiel: Methodenstack.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class Methodenstack { public static void a ( int vaa ) { int vab = 1 ; System . out . println ( \"+--a() --> va = \" + vaa + \" vb = \" + vab ); b ( vaa , vab ); } public static void b ( int vba , int vbb ) { System . out . println ( \"+----b() --> vba = \" + vba + \" vbb = \" + vbb ); System . out . println (); } public static void main ( String [] args ) { for ( int va = 0 ; va < 3 ; va ++ ) { System . out . println ( \"main() --> va = \" + va ); a ( va ); } } } In diesem Beispiel gibt es drei Methoden: die main() -Methode mit der Variablen va , die a() -Methode mit den Variablen vaa und vab und die b() -Methode mit den Variablen vba und vbb . Die main() -Methode ruft die Methode a() auf und die a() -Methode ruft die b() -Methode auf. Die Ausgabe des Programms ist wie folgt: main () --> va = 0 +--a () --> va = 0 vb = 1 +----b () --> vba = 0 vbb = 1 main () --> va = 1 +--a () --> va = 1 vb = 1 +----b () --> vba = 1 vbb = 1 main () --> va = 2 +--a () --> va = 2 vb = 1 +----b () --> vba = 2 vbb = 1 Die main() -Methode ruft also drei Mal (innerhalb der Schleife) die a() -Methode auf, welche wiederum die b() -Methode aufruft. Bei dem Aufruf von Methoden passiert folgendes: bei jedem Methodenaufruf wird eine Methodeninstanz auf den Stack gelegt eine Methodeninstanz sind alle zur Laufzeit ver\u00e4nderlichen Daten, die zur Methode geh\u00f6ren (Parameter und lokale Variablen) nach Abarbeitung der Methode (oft durch return - muss aber nicht, wie in unserem Beispiel) wird die Methodeninstanz wieder aus dem Stack entfernt (und somit auch alle dazu geh\u00f6renden Daten (Parameter, lokale Variablen und deren Werte)) In unserem Beispiel passiert also folgendes: Die main() -Methode wird ausgef\u00fchrt; die Variable va wird erzeugt und bekommt den Wert 0 . Die main() -Methode erzeugt eine Ausgabe auf die Konsole und ruft dann die Methode a() auf. Die a() -Methode wird ausgef\u00fchrt; die Variablen vaa und vab werden erzeugt und bekommen die Werte 0 und 1 . In der a() -Methode erfolgt eine Ausgabe auf die Konsole. Die a() -Methode ruft die Methode b() auf. Die b() -Methode wird ausgef\u00fchrt; die Variablen vba und vbb werden erzeugt und bekommen die Werte 0 und 1 . In der b() -Methode erfolgt eine Ausgabe auf die Konsole. Danach ist die Ausf\u00fchrung der b() -Methode zu Ende. Alles, was mit der b() -Methode zu tun hat, insb. die Variablen vba und vbb werden aus dem Speicher gel\u00f6scht . Zur\u00fcck zur Ausf\u00fchrung von a() . Keine weitere Anweisung - die Ausf\u00fchrung der a() -Methode zu Ende. Alles, was mit der a() -Methode zu tun hat, insb. die Variablen vaa und vab werden aus dem Speicher gel\u00f6scht . Zur\u00fcck zur Ausf\u00fchrung von main() . Die Variable va bekommt innerhalb der Schleife den neuen Wert 1 . Die Variable va hat nun den Wert 1 . Die main() -Methode erzeugt eine Ausgabe auf die Konsole und ruft dann die Methode a() auf. Die a() -Methode wird ausgef\u00fchrt; die Variablen vaa und vab werden erzeugt und bekommen die Werte 1 und 1 . In der a() -Methode erfolgt eine Ausgabe auf die Konsole. Die a() -Methode ruft die Methode b() auf. Die b() -Methode wird ausgef\u00fchrt; die Variablen vba und vbb werden erzeugt und bekommen die Werte 1 und 1 . In der b() -Methode erfolgt eine Ausgabe auf die Konsole. Danach ist die Ausf\u00fchrung der b() -Methode zu Ende. Alles, was mit der b() -Methode zu tun hat, insb. die Variablen vba und vbb werden aus dem Speicher gel\u00f6scht . Zur\u00fcck zur Ausf\u00fchrung von a() . Keine weitere Anweisung - die Ausf\u00fchrung der a() -Methode zu Ende. Alles, was mit der a() -Methode zu tun hat, insb. die Variablen vaa und vab werden aus dem Speicher gel\u00f6scht . Zur\u00fcck zur Ausf\u00fchrung von main() . Die Variable va bekommt innerhalb der Schleife den neuen Wert 2 . Die Variable va hat nun den Wert 2 . Die main() -Methode erzeugt eine Ausgabe auf die Konsole und ruft dann die Methode a() auf. Die a() -Methode wird ausgef\u00fchrt; die Variablen vaa und vab werden erzeugt und bekommen die Werte 2 und 1 . In der a() -Methode erfolgt eine Ausgabe auf die Konsole. Die a() -Methode ruft die Methode b() auf. Die b() -Methode wird ausgef\u00fchrt; die Variablen vba und vbb werden erzeugt und bekommen die Werte 2 und 1 . In der b() -Methode erfolgt eine Ausgabe auf die Konsole. Danach ist die Ausf\u00fchrung der b() -Methode zu Ende. Alles, was mit der b() -Methode zu tun hat, insb. die Variablen vba und vbb werden aus dem Speicher gel\u00f6scht . Zur\u00fcck zur Ausf\u00fchrung von a() . Keine weitere Anweisung - die Ausf\u00fchrung der a() -Methode zu Ende. Alles, was mit der a() -Methode zu tun hat, insb. die Variablen vaa und vab werden aus dem Speicher gel\u00f6scht . Zur\u00fcck zur Ausf\u00fchrung von main() . Die Variable va bekommt innerhalb der Schleife den neuen Wert 3 . Die Bedingung der Schleife va<3 ist somit false . Die Schleife wird verlassen, keine weitere Anweisung in main() . Die Abarbeitung des Programms ist zu Ende. Alles, was mit der main() -Methode zu tun hat, insb. Variable va wird aus dem Speicher gel\u00f6scht. Lebensdauer und Sichtbarkeit von lokalen Variablen \u00b6 Die Variablen, die wir bis jetzt verwendet haben, wurden in Methoden deklariert oder in Anweisungsbl\u00f6cken, die in Methoden liegen (z.B. in for -Schleifen). Bei solchen Variablen sprechen wir von lokalen Variablen. Wir werden sp\u00e4ter noch globale Variablen kennenlernen. Zun\u00e4chst interessieren uns aber nur die lokalen Variablen. Das obige Beispiel zeigt, dass lokale Variablen, also solche, die in Methoden deklariert werden, nur so lange existieren , wie diese Methode ausgef\u00fchrt wird. Generell gilt: Eine Variable existiert in dem Anweisungsblock, in dem sie deklariert wurde, solange dieser Anweisungsblock ausgef\u00fchrt wird. Schauen wir uns dazu die Situationen in dem oberen Beispiel an: Die Variable va wird in der main() -Methode deklariert. Die main() -Methode wird die ganze Zeit ausgef\u00fchrt. Also existiert auch die Variable va die gesamte Zeit des Programmablaufs. Die Variablen vaa und vab werden in der a() -Methode deklariert. Sie existieren immer nur dann, wenn die a() -Methode ausgef\u00fchrt wird. In unserem Beispiel existieren die Variablen vaa und vab also drei Mal (sie werden drei Mal erzeugt und drei Mal wieder vollst\u00e4ndig gel\u00f6scht). Da die Methode a() die Methode b() aufruft, existieren die Variablen vaa und vab auch w\u00e4hrend der Ausf\u00fchrung von b() , da zur Zeit der Ausf\u00fchrung von b() ja auch a() ausgef\u00fchrt wird (und main() ). Die Variablen vba und vbb werden in der b() -Methode deklariert. Sie existieren immer nur dann, wenn die b() -Methode ausgef\u00fchrt wird. In unserem Beispiel existieren die Variablen vba und vbb also drei Mal (sie werden drei Mal erzeugt und drei Mal wieder vollst\u00e4ndig gel\u00f6scht). Die Lebensdauer eine Variable wird somit von der Ausf\u00fchrungsdauer des Anweisungsblockes bestimmt, in dem die Variable deklariert wurde. Lebensdauer Es ist eine g\u00e4ngige Praxis, alle Variablen, die man in einer Methode verwenden m\u00f6chte, am Anfang der Methode zu deklarieren. Erstens sieht man dann, welche Variablen innerhalb der Methode alle verwendet werden und zweitens kann man diese Variablen in allen Anweisungsbl\u00f6cken innerhalb der Methode verwenden. Einzige Ausnahme stellen Laufvariablen der for -Schleifen dar. Diese werden h\u00e4ufig direkt in der for -Schleife deklariert ( for(int i=0, i<10; i++){} ). Sie existieren dann aber auch nur in dieser for -Schleife! Au\u00dferhalb der for -Schleife existiert diese Variable dann nicht (mehr)! Das bedeutet auch, dass wenn Sie diese Variable in einer anderen for -Schleife verwenden wollen, m\u00fcssen Sie sie dort erneut deklarieren. Unter Sichtbarkeit einer Variablen versteht man die M\u00f6glichkeit, auf diese Variable zuzugreifen (also ihr entweder einen neuen Wert zuzuweisen oder ihren Wert auszulesen). Generell gilt: Eine lokale Variable ist in dem Anweisungsblock sichtbar, in dem sie deklariert wird und in allen Anweisungsbl\u00f6cken, die sich in diesem Anweisungsblock befinden. Au\u00dferhalb des Anweisungsblockes, in dem die Variable deklariert wurde, ist die Variable nicht sichtbar. Das hei\u00dft f\u00fcr unser Beispiel, dass die Variable va nur in der main() -Methode sichtbar ist (also nur dort auf sie zugegriffen werden kann/sie nur dort verwendet werden kann), die Variablen vaa und vab nur in der a() -Methode verwendet werden k\u00f6nnen (sichtbar sind) und die Variablen vba und vbb nur in b() . Sichtbarkeit Der Vorteil dieser lokalen Sichtbarkeit besteht darin, dass man sich z.B. keine Sorgen machen muss, ob eine gleichnamige Variable evtl. bereits in einer anderen Methode deklariert wurde. Eine Variable darf ja immer nur einmal deklariert werden. Da alle anderen Variablen aber nicht in der eigenen Methode sichtbar sind, gibt es keinerlei Konflikte mit anderen lokalen Variablen. Die lokalen Variablen aus anderen Methoden haben mit den Variablen aus der eigenen Methode gar nichts zu tun. Au\u00dferdem ist es auch nicht m\u00f6glich, einfach Werte von Variablen aus anderen Methoden zu schreiben oder zu lesen. Das w\u00fcrde ansonsten gro\u00dfe Sicherheitsprobleme mit sich bringen und man k\u00f6nnte Programme auch leicht zum Absturz bringen.","title":"Methodenstack"},{"location":"methodenstack/#methodenstack","text":"Programme und die dazugeh\u00f6rigen Variablen (und deren Werte) befinden sich zur Ausf\u00fchrung im Arbeitsspeicher. Der Speicher ist in Bl\u00f6cke (Bytes) unetrteilt, die jeweils adressierbar sind. So k\u00f6nnte alles jeweils eine Adresse zugeordnet werden und mit einer komplexen Adressverwaltung lie\u00dfen sich die Einzelteile ansprechen. Das ist jedoch viel zu aufwendig und inperformant. Deshalb werden Speichermodelle verwendet, die die Verwaltung der Programmteile erleichtern. Ein solches Speichermodell ist der Stack ( Stapelspeicher ). Bei einem Stack gilt das Last in first out (LIFO) Prinzip, also das, was zuletzt in den Stack kam, muss auch als erstes wieder hinaus. tats\u00e4chlich gibt es nur ganz wenige Funktionalit\u00e4ten, um einen solchen Stack zu verwalten: push : Element oben auf den Stack hinzuf\u00fcgen pop : Element von oben aus dem Stack entfernen top (manchmal auch peek genannt): auf oberes Element zugreifen (lesen, aber im Stack belassen) Folgende Abbildung stellt diese Methoden grafisch dar: F\u00fcr einen solchen Stack gibt es jetzt nur drei M\u00f6glichkeiten: Element E kann gelesen werden (aber im Stack belassen) - top Element E kann aus dem Stack entfernt werden - pop ein neues Element (z.B. F ) kann zum Stack hinzugef\u00fcgt werden - push (dann kann auch E nicht mehr gelesen werden; so wie bereits A - D )","title":"Methodenstack"},{"location":"methodenstack/#abarbeitung-von-methoden","text":"Wir betrachten das Speichermodell Stack , weil die Abarbeitung von Methoden nach diesem Prinzip funktioniert. Methoden, die abgearbeitet (aufgerufen) werden, werden in einem solchen Stack angeordnet. Wir betrachten ein Beispiel: Methodenstack.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class Methodenstack { public static void a ( int vaa ) { int vab = 1 ; System . out . println ( \"+--a() --> va = \" + vaa + \" vb = \" + vab ); b ( vaa , vab ); } public static void b ( int vba , int vbb ) { System . out . println ( \"+----b() --> vba = \" + vba + \" vbb = \" + vbb ); System . out . println (); } public static void main ( String [] args ) { for ( int va = 0 ; va < 3 ; va ++ ) { System . out . println ( \"main() --> va = \" + va ); a ( va ); } } } In diesem Beispiel gibt es drei Methoden: die main() -Methode mit der Variablen va , die a() -Methode mit den Variablen vaa und vab und die b() -Methode mit den Variablen vba und vbb . Die main() -Methode ruft die Methode a() auf und die a() -Methode ruft die b() -Methode auf. Die Ausgabe des Programms ist wie folgt: main () --> va = 0 +--a () --> va = 0 vb = 1 +----b () --> vba = 0 vbb = 1 main () --> va = 1 +--a () --> va = 1 vb = 1 +----b () --> vba = 1 vbb = 1 main () --> va = 2 +--a () --> va = 2 vb = 1 +----b () --> vba = 2 vbb = 1 Die main() -Methode ruft also drei Mal (innerhalb der Schleife) die a() -Methode auf, welche wiederum die b() -Methode aufruft. Bei dem Aufruf von Methoden passiert folgendes: bei jedem Methodenaufruf wird eine Methodeninstanz auf den Stack gelegt eine Methodeninstanz sind alle zur Laufzeit ver\u00e4nderlichen Daten, die zur Methode geh\u00f6ren (Parameter und lokale Variablen) nach Abarbeitung der Methode (oft durch return - muss aber nicht, wie in unserem Beispiel) wird die Methodeninstanz wieder aus dem Stack entfernt (und somit auch alle dazu geh\u00f6renden Daten (Parameter, lokale Variablen und deren Werte)) In unserem Beispiel passiert also folgendes: Die main() -Methode wird ausgef\u00fchrt; die Variable va wird erzeugt und bekommt den Wert 0 . Die main() -Methode erzeugt eine Ausgabe auf die Konsole und ruft dann die Methode a() auf. Die a() -Methode wird ausgef\u00fchrt; die Variablen vaa und vab werden erzeugt und bekommen die Werte 0 und 1 . In der a() -Methode erfolgt eine Ausgabe auf die Konsole. Die a() -Methode ruft die Methode b() auf. Die b() -Methode wird ausgef\u00fchrt; die Variablen vba und vbb werden erzeugt und bekommen die Werte 0 und 1 . In der b() -Methode erfolgt eine Ausgabe auf die Konsole. Danach ist die Ausf\u00fchrung der b() -Methode zu Ende. Alles, was mit der b() -Methode zu tun hat, insb. die Variablen vba und vbb werden aus dem Speicher gel\u00f6scht . Zur\u00fcck zur Ausf\u00fchrung von a() . Keine weitere Anweisung - die Ausf\u00fchrung der a() -Methode zu Ende. Alles, was mit der a() -Methode zu tun hat, insb. die Variablen vaa und vab werden aus dem Speicher gel\u00f6scht . Zur\u00fcck zur Ausf\u00fchrung von main() . Die Variable va bekommt innerhalb der Schleife den neuen Wert 1 . Die Variable va hat nun den Wert 1 . Die main() -Methode erzeugt eine Ausgabe auf die Konsole und ruft dann die Methode a() auf. Die a() -Methode wird ausgef\u00fchrt; die Variablen vaa und vab werden erzeugt und bekommen die Werte 1 und 1 . In der a() -Methode erfolgt eine Ausgabe auf die Konsole. Die a() -Methode ruft die Methode b() auf. Die b() -Methode wird ausgef\u00fchrt; die Variablen vba und vbb werden erzeugt und bekommen die Werte 1 und 1 . In der b() -Methode erfolgt eine Ausgabe auf die Konsole. Danach ist die Ausf\u00fchrung der b() -Methode zu Ende. Alles, was mit der b() -Methode zu tun hat, insb. die Variablen vba und vbb werden aus dem Speicher gel\u00f6scht . Zur\u00fcck zur Ausf\u00fchrung von a() . Keine weitere Anweisung - die Ausf\u00fchrung der a() -Methode zu Ende. Alles, was mit der a() -Methode zu tun hat, insb. die Variablen vaa und vab werden aus dem Speicher gel\u00f6scht . Zur\u00fcck zur Ausf\u00fchrung von main() . Die Variable va bekommt innerhalb der Schleife den neuen Wert 2 . Die Variable va hat nun den Wert 2 . Die main() -Methode erzeugt eine Ausgabe auf die Konsole und ruft dann die Methode a() auf. Die a() -Methode wird ausgef\u00fchrt; die Variablen vaa und vab werden erzeugt und bekommen die Werte 2 und 1 . In der a() -Methode erfolgt eine Ausgabe auf die Konsole. Die a() -Methode ruft die Methode b() auf. Die b() -Methode wird ausgef\u00fchrt; die Variablen vba und vbb werden erzeugt und bekommen die Werte 2 und 1 . In der b() -Methode erfolgt eine Ausgabe auf die Konsole. Danach ist die Ausf\u00fchrung der b() -Methode zu Ende. Alles, was mit der b() -Methode zu tun hat, insb. die Variablen vba und vbb werden aus dem Speicher gel\u00f6scht . Zur\u00fcck zur Ausf\u00fchrung von a() . Keine weitere Anweisung - die Ausf\u00fchrung der a() -Methode zu Ende. Alles, was mit der a() -Methode zu tun hat, insb. die Variablen vaa und vab werden aus dem Speicher gel\u00f6scht . Zur\u00fcck zur Ausf\u00fchrung von main() . Die Variable va bekommt innerhalb der Schleife den neuen Wert 3 . Die Bedingung der Schleife va<3 ist somit false . Die Schleife wird verlassen, keine weitere Anweisung in main() . Die Abarbeitung des Programms ist zu Ende. Alles, was mit der main() -Methode zu tun hat, insb. Variable va wird aus dem Speicher gel\u00f6scht.","title":"Abarbeitung von Methoden"},{"location":"methodenstack/#lebensdauer-und-sichtbarkeit-von-lokalen-variablen","text":"Die Variablen, die wir bis jetzt verwendet haben, wurden in Methoden deklariert oder in Anweisungsbl\u00f6cken, die in Methoden liegen (z.B. in for -Schleifen). Bei solchen Variablen sprechen wir von lokalen Variablen. Wir werden sp\u00e4ter noch globale Variablen kennenlernen. Zun\u00e4chst interessieren uns aber nur die lokalen Variablen. Das obige Beispiel zeigt, dass lokale Variablen, also solche, die in Methoden deklariert werden, nur so lange existieren , wie diese Methode ausgef\u00fchrt wird. Generell gilt: Eine Variable existiert in dem Anweisungsblock, in dem sie deklariert wurde, solange dieser Anweisungsblock ausgef\u00fchrt wird. Schauen wir uns dazu die Situationen in dem oberen Beispiel an: Die Variable va wird in der main() -Methode deklariert. Die main() -Methode wird die ganze Zeit ausgef\u00fchrt. Also existiert auch die Variable va die gesamte Zeit des Programmablaufs. Die Variablen vaa und vab werden in der a() -Methode deklariert. Sie existieren immer nur dann, wenn die a() -Methode ausgef\u00fchrt wird. In unserem Beispiel existieren die Variablen vaa und vab also drei Mal (sie werden drei Mal erzeugt und drei Mal wieder vollst\u00e4ndig gel\u00f6scht). Da die Methode a() die Methode b() aufruft, existieren die Variablen vaa und vab auch w\u00e4hrend der Ausf\u00fchrung von b() , da zur Zeit der Ausf\u00fchrung von b() ja auch a() ausgef\u00fchrt wird (und main() ). Die Variablen vba und vbb werden in der b() -Methode deklariert. Sie existieren immer nur dann, wenn die b() -Methode ausgef\u00fchrt wird. In unserem Beispiel existieren die Variablen vba und vbb also drei Mal (sie werden drei Mal erzeugt und drei Mal wieder vollst\u00e4ndig gel\u00f6scht). Die Lebensdauer eine Variable wird somit von der Ausf\u00fchrungsdauer des Anweisungsblockes bestimmt, in dem die Variable deklariert wurde. Lebensdauer Es ist eine g\u00e4ngige Praxis, alle Variablen, die man in einer Methode verwenden m\u00f6chte, am Anfang der Methode zu deklarieren. Erstens sieht man dann, welche Variablen innerhalb der Methode alle verwendet werden und zweitens kann man diese Variablen in allen Anweisungsbl\u00f6cken innerhalb der Methode verwenden. Einzige Ausnahme stellen Laufvariablen der for -Schleifen dar. Diese werden h\u00e4ufig direkt in der for -Schleife deklariert ( for(int i=0, i<10; i++){} ). Sie existieren dann aber auch nur in dieser for -Schleife! Au\u00dferhalb der for -Schleife existiert diese Variable dann nicht (mehr)! Das bedeutet auch, dass wenn Sie diese Variable in einer anderen for -Schleife verwenden wollen, m\u00fcssen Sie sie dort erneut deklarieren. Unter Sichtbarkeit einer Variablen versteht man die M\u00f6glichkeit, auf diese Variable zuzugreifen (also ihr entweder einen neuen Wert zuzuweisen oder ihren Wert auszulesen). Generell gilt: Eine lokale Variable ist in dem Anweisungsblock sichtbar, in dem sie deklariert wird und in allen Anweisungsbl\u00f6cken, die sich in diesem Anweisungsblock befinden. Au\u00dferhalb des Anweisungsblockes, in dem die Variable deklariert wurde, ist die Variable nicht sichtbar. Das hei\u00dft f\u00fcr unser Beispiel, dass die Variable va nur in der main() -Methode sichtbar ist (also nur dort auf sie zugegriffen werden kann/sie nur dort verwendet werden kann), die Variablen vaa und vab nur in der a() -Methode verwendet werden k\u00f6nnen (sichtbar sind) und die Variablen vba und vbb nur in b() . Sichtbarkeit Der Vorteil dieser lokalen Sichtbarkeit besteht darin, dass man sich z.B. keine Sorgen machen muss, ob eine gleichnamige Variable evtl. bereits in einer anderen Methode deklariert wurde. Eine Variable darf ja immer nur einmal deklariert werden. Da alle anderen Variablen aber nicht in der eigenen Methode sichtbar sind, gibt es keinerlei Konflikte mit anderen lokalen Variablen. Die lokalen Variablen aus anderen Methoden haben mit den Variablen aus der eigenen Methode gar nichts zu tun. Au\u00dferdem ist es auch nicht m\u00f6glich, einfach Werte von Variablen aus anderen Methoden zu schreiben oder zu lesen. Das w\u00fcrde ansonsten gro\u00dfe Sicherheitsprobleme mit sich bringen und man k\u00f6nnte Programme auch leicht zum Absturz bringen.","title":"Lebensdauer und Sichtbarkeit von lokalen Variablen"},{"location":"selektion/","text":"Selektion \u00b6 In Programmablaufstrukturen haben wir uns die drei Kontrollstrukturen angeschaut, die in Programmen vorkommen k\u00f6nnen: die Sequenz , die Iteration und die Selektion . Wir betrachten nun die Selektion genauer und schauen uns an, wie wir sie in Java umsetzen. if...else \u00b6 Bei der Selektion ist die Ausf\u00fchrung von Anweisungen von einer Bedingung abh\u00e4ngig. Angenommen, wir wollen erreichen, dass eine Zahl number halbiert wird, wenn sie gerade ist oder sie wird mit 3 multipliziert und 1 addiert, wenn sie ungerade ist. Es findet also eine Selektion der Anwesiungen statt, je nachdem ob number gerade ist oder nicht. Als \"Pseudocode\" sieht das so aus: wenn ( number ist gerade ) dann teile number durch 2 sonst multipliziere number mit 3 und addiere 1 In Java gibt es daf\u00fcr die if ... else -Anweisung: if ( number % 2 == 0 ) { number = number / 2 ; } else { number = 3 * number + 1 ; } Das hei\u00dft, es wird zun\u00e4chst eine Bedingung (ein Ausdruck vom Typ boolean ) gepr\u00fcft. Ist der Wert dieser Bedingung true , dann wird der erste Anweisungsblock ausgef\u00fchrt. Ist der Wert der Bedingung jedoch false , dann wird der zweite Anweisungsblock (der nach dem else ) ausgef\u00fchrt. Es wird also genau einer der beiden Anweisungsbl\u00f6cke ausgef\u00fchrt - entweder der eine oder der andere (je nach Wert der Bedingung). Noch ein Beispiel aus dem euklidischen Algorithmus : if ( a > b ) { a = a - b ; } else { b = b - a ; } Innerhalb der Anweisungsbl\u00f6cke k\u00f6nnen nat\u00fcrlich jeweils mehrere Anweisungen stehen. Als Information sei hier gesagt, dass es theoretisch m\u00f6glich ist, bei nur einer Anweisung die Klammern wegzulassen, also z.B. if ( a > b ) a = a - b ; else b = b - a ; Aber wir machen das nicht, da solche Programme nicht gut erweiterbar sind! Es gibt gen\u00fcgend Beispiele, in denen so etwas schief lief (z.B. bei Apple ). Die allgemeine Syntax einer solchen Selektion sieht also wie folgt aus: if ( bedingung ) { /* * Anweisungsblock, der ausgef\u00fchrt wird, * wenn die bedingung true ist. * das k\u00f6nnen beliebig viele Anweisungen sein: * Sequenzen, Iterationen und/oder Selektionen */ } else { /* * Anweisungsblock, der ausgef\u00fchrt wird, * wenn die bedingung false ist. * das k\u00f6nnen beliebig viele Anweisungen sein: * Sequenzen, Iterationen und/oder Selektionen * dieser else -Block kann aber auch ganz weg- * gelassen werden - sehen wir gleich */ } Bedingungen \u00b6 Bevor wir uns noch weitere Varianten der if...else -Anweisung anschauen, gehen wir nochmal darauf ein, was eine Bedingung ist. Eine Bedingung ist ein logischer Ausdruck, - d.h. der Datentyp des Wertes einer Bedingung ist `boolean`, - d.h. der Wert einer Bedingung ist entweder `true` oder `false` Wir betrachten einige Beispiele von Bedingungen (wir nehmen an, dass die Methoden isOdd(int) und notZero(int) existieren und ein boolean zur\u00fcckgeben): boolean cond1 = true ; // kann genutzt werden als if(cond1) oder if(true) boolean cond2 = cond1 ; // kann genutzt werden als if(cond2) oder if(cond1) boolean cond3 = cond1 && true ; // kann genutzt werden als if(cond3) oder if(cond1 && true) boolean cond4 = ( 7 >= 4 ); // kann genutzt werden als if(cond4) oder if(7 >= 4) boolean cond5 = ( 7 >= 4 ) && ( 3 < 5 ); // kann genutzt werden als if(cond5) oder if((7 >= 4) && (3 < 5)) boolean cond6 = cond5 || cond3 ; // kann genutzt werden als if(cond6) oder if(cond5 || cond3) boolean cond7 = isOdd ( 3 ) && notZero ( 3 ); // kann genutzt werden als if(cond7) oder if(isOdd(3) && notZero(3)) Wichtig ist also, dass alle Werte, die vom Typ boolean sind, als Bedingungen verwendet werden k\u00f6nnen. Achten Sie auch darauf, dass die Ausdr\u00fccke selbst (also die Bedingungen) kein Semikolon am Ende haben - Ausdr\u00fccke sind keine Anweisungen. Beachte Vergleichen Sie logische Ausdr\u00fccke nicht mit true ! Man sieht h\u00e4ufig so etwas wie isOdd(3) == true . Das ist unn\u00f6tig! Angenommen, der Wert von isOdd(3) ist true , dann ist auch der Vergleich isOdd(3) == true true . Angenommen, der Wert von isOdd(3) ist false , dann ist auch der Vergleich isOdd(3) == true false . Das bedeutet, der Wert des Vergleiches entspricht exakt dem Wert von isOdd(3) , also benutzen wir nur isOdd(3) . if...else ohne else -Block \u00b6 Der else -Block ist nicht zwingend n\u00f6tig. Es gibt Beispiele, in denen etwas getan werden soll, wenn eine bestimmte Bedingung gilt, aber wenn sie nicht gilt, dann muss auch nichts getan werden, z.B. (Methoden ausgedacht): if ( fileOpen ( file )) { closeFile ( file ); } if ( connectionEstablished ( database )) { disconnect ( database ); } if ( divisor == 0 ) { System . out . println ( \"Divsion durch 0 nicht m\u00f6glich!\" ); } Verschachtelte Selektionen \u00b6 Die Anweisungsbl\u00f6cke sowohl im true -Zweig als auch im else -Zweig k\u00f6nnen beliebige Kontrollstrukturen enthalten: nur eine Anweisung oder Sequenzen von Anweisungen und/oder Iterationen und/oder Selektionen. Ist eine Selektion innerhalb einer Selektion, spricht man auch von verschachtelten Selektionen. Angenommen, wir haben drei int -Variablen a , b , c und wollen diese der Gr\u00f6\u00dfe nach sortieren (und wollen auch noch pr\u00fcfen, ob die Werte evenzuell gleich sind): // a, b, c vom Typ `int` if ( a > b ) { if ( b > c ) { System . out . println ( \"a > b > c\" ); } else // c >= b { if ( c > b ) { if ( a > c ) { System . out . println ( \"a > c > b\" ); } else // c >= a { if ( c > a ) { System . out . println ( \"c > a > b\" ); } else // c == a { System . out . println ( \"c = a > b\" ); } } } else // c == b { System . out . println ( \"a > b = c\" ); } } } else // b >= a { if ( b > a ) { if ( b > c ) { if ( a > c ) { System . out . println ( \"b > a > c\" ); } else // c >= a { if ( c > a ) { System . out . println ( \"b > c > a\" ); } else // a == c { System . out . println ( \"b > a = c\" ); } } } else // c >= b { if ( c == b ) { System . out . println ( \"b = c > a\" ); } else // c > b { System . out . println ( \"c > b > a\" ); } } } else // b == a { if ( b > c ) { System . out . println ( \"a = b > c\" ); } else // c >= b { if ( c == b ) { System . out . println ( \"a = b = c\" ); } else // c > b { System . out . println ( \"c > b = a\" ); } } } } Sie sehen, so etwas wird sehr schnell sehr un\u00fcbersichtlich. Wir sollten versuchen, solche Verschachtelungen nur auf sehr geringe Verschachtelungstiefen zu beschr\u00e4nken. Die beste M\u00f6glichkeit, solche Verschachtelungstiefen zu vermeiden, besteht darin, die Bedingungen komplexer zu gestalten indem wir logische Operatoren verwenden, z.B. if(a > b) && (b > c)) . Wir zeigen das mal am obigen Beispiel, in dem wir gar keine Verschachtelungstiefe haben: // a, b, c vom Typ `int` if ( a > b && b > c ) { System . out . println ( \"a > b > c\" ); } if ( a > b && c > b && a > c ) { System . out . println ( \"a > c > b\" ); } if ( a > b && c > b && c > a ) { System . out . println ( \"c > a > b\" ); } if ( a > b && c > b && c == a ) { System . out . println ( \"a = c > b\" ); } if ( a > b && b == c ) { System . out . println ( \"a > b = c\" ); } if ( a == b && b == c ) { System . out . println ( \"a = b = c\" ); } if ( a == b && b > c ) { System . out . println ( \"a = b > c\" ); } if ( a == b && c > b ) { System . out . println ( \"c > a = b\" ); } if ( b > a && a > c ) { System . out . println ( \"b > a > c\" ); } if ( b > a && c > a && b > c ) { System . out . println ( \"b > c > a\" ); } if ( b > a && c > a && b == c ) { System . out . println ( \"b = c > a\" ); } if ( b > a && c == a ) { System . out . println ( \"b > c = a\" ); } if ( b > a && c > b ) { System . out . println ( \"c > b > a\" ); } \u00dcbung Bei welchem der beiden oberen Programme werden (im Durchschnitt) mehr Vergleiche durchgef\u00fchrt und warum? Das Problem mit komplexen Bedingungen besteht darin, dass diese recht schwer zu verstehen sind. F\u00fcr komplexe Bedingungen sollten wir stets eigene Methoden definieren (die ein boolean zur\u00fcckgeben) und die mit ihrem Namen verraten, was die Bedingung pr\u00fcft. Darauf kommen wir sp\u00e4ter nochmal zur\u00fcck. switch -Anweisung \u00b6 Die switch -Anweisung war in Java lange ungl\u00fccklich gel\u00f6st. Die switch -Anweisung kann verwendet werden, wenn Sie viele Fallunterscheidungen haben. Wir geben zun\u00e4chst ein Beispiel in der alten Form der switch -Anweisung, die immer noch funktioniert und die Sie so wahrscheinlich auch noch sehr h\u00e4ufig antreffen werden: // monat vom Typ `int` switch ( monat ) { case 1 : System . out . println ( \"Januar\" ); break ; case 2 : System . out . println ( \"Februar\" ); break ; case 3 : System . out . println ( \"M\u00e4rz\" ); break ; case 4 : System . out . println ( \"April\" ); break ; case 5 : System . out . println ( \"Mai\" ); break ; case 6 : System . out . println ( \"Juni\" ); break ; case 7 : System . out . println ( \"Juli\" ); break ; case 8 : System . out . println ( \"August\" ); break ; case 9 : System . out . println ( \"September\" ); break ; case 10 : System . out . println ( \"Oktober\" ); break ; case 11 : System . out . println ( \"November\" ); break ; case 12 : System . out . println ( \"Dezember\" ); break ; default : System . out . println ( \"kein Monat\" ); } Betrachten wir die Anweisung zun\u00e4chst etwas genauer. Die Fallunterscheidungen betreffen den Wert der int -Variablen monat . Das bedeutet schonmal, dass in den runden Klammern der switch() -Anweisung keine Bedingung steht, sondern ein Ausdruck, der von verschiedenen Datentypen sein kann, z.B. byte , short , int und String . Der Ablauf einer switch() -Anweisung ist nun so, dass f\u00fcr den entsprechenden Wert der case gesucht wird, also z.B. wenn month den Wert 6 hat, dann ist case 6: der \"Einsprungspunkt\". Dort werden nun alle Anweisungen abgearbeitet, bis entweder ein break; kommt oder die switch() -Anweisung beendet ist. break; stoppt also die Abarbeitung. W\u00fcrde in unserem Beispiel kein break enthalten sien und w\u00e4re month z.B. 6 , dann w\u00fcrden alle Monate ab und inkl. Juli ausgegeben werden. Der default: -Fall ist daf\u00fcr, falls keine der case passt. Der default: -Fall ist optional. Dass die Anweisungen nach case x: nicht in Anweisungsbl\u00f6cken stehen und dass die Verwendung von break; erforderlich ist, um die Ausf\u00fchrung von Anweisungen zu stoppen, macht diese alte Syntax der switch() -Anweisung unsch\u00f6n. Wir betrachten noch ein Beispiel in der alten Syntax, um den Unterschied zur neuen noch besser zu erl\u00e4utern: // monat vom Typ `int` int anzahlTageImMonat = 0 ; switch ( monat ) { case 1 : case 3 : case 5 : case 7 : case 8 : case 10 : case 12 : anzahlTageImMonat = 31 ; break ; case 4 : case 6 : case 9 : case 11 : anzahlTageImMonat = 30 ; break ; case 2 : anzahlTageImMonat = 28 ; } Ab Java 12 wurde die switch() -Anweisung gr\u00fcndlich \u00fcberarbeitet. Wir betrachten das so eben gezeigte Beispiel nun in der neuen Schreibweise: int anzahlTageImMonat = switch ( monat ) { case 1 , 3 , 5 , 7 , 8 , 10 , 12 -> 31 ; case 4 , 6 , 9 , 11 -> 30 ; case 2 -> 28 ; default -> 0 ; }; Mehrere Dinge fallen auf: kann eine switch() -Anweisung nun auch als Ausdruck verwendet werden und somit z.B. einer Variablen einen Wert zu weisen (das machen wir hier) hat sich die Schreibweise beim case ge\u00e4ndert. Aus dem Doppelpunkt wurde ein Pfeil und es k\u00f6nnen mit einem case auch mehrere durch Komma getrennte Werte aufgef\u00fchrt werden und - besonders gut - wir ben\u00f6tigen kein break mehr. Es wird immer nur der case ausgef\u00fchrt. Die Abarbeitung der dort beschriebenen Anweisungen stoppt beim n\u00e4chsten case bzw. bei default oder am Ende der switch() -Anweisung Success Wir haben 2 M\u00f6glichkeiten kennengelernt, die Selktion in Java zu implementieren. Die eine (und bedeutendste) M\u00f6glichkeit ist die if...else -Anweisung. Dort wird in Abh\u00e4ngigkeit vom Wahreheitswert einer Bedingung entweder der eine oder der andere Anweisungsblock ausgef\u00fchrt. Der else -Block kann auch weggelassen werden. Innerhalb eines Anweisungsblockes k\u00f6nnen beliebige Kontrollstrukturen stehen: Sequenzen, Iterationen und Selektionen. Die zweite M\u00f6glichkeit ist die switch() -Anweisung, die seit Java 12 auch selbst ein Ausdruck sein kann. Wir haben die alte Syntax der switch() -Anweisung kritisch betrachtet und die neue Syntax kennengelernt.","title":"Selektion"},{"location":"selektion/#selektion","text":"In Programmablaufstrukturen haben wir uns die drei Kontrollstrukturen angeschaut, die in Programmen vorkommen k\u00f6nnen: die Sequenz , die Iteration und die Selektion . Wir betrachten nun die Selektion genauer und schauen uns an, wie wir sie in Java umsetzen.","title":"Selektion"},{"location":"selektion/#ifelse","text":"Bei der Selektion ist die Ausf\u00fchrung von Anweisungen von einer Bedingung abh\u00e4ngig. Angenommen, wir wollen erreichen, dass eine Zahl number halbiert wird, wenn sie gerade ist oder sie wird mit 3 multipliziert und 1 addiert, wenn sie ungerade ist. Es findet also eine Selektion der Anwesiungen statt, je nachdem ob number gerade ist oder nicht. Als \"Pseudocode\" sieht das so aus: wenn ( number ist gerade ) dann teile number durch 2 sonst multipliziere number mit 3 und addiere 1 In Java gibt es daf\u00fcr die if ... else -Anweisung: if ( number % 2 == 0 ) { number = number / 2 ; } else { number = 3 * number + 1 ; } Das hei\u00dft, es wird zun\u00e4chst eine Bedingung (ein Ausdruck vom Typ boolean ) gepr\u00fcft. Ist der Wert dieser Bedingung true , dann wird der erste Anweisungsblock ausgef\u00fchrt. Ist der Wert der Bedingung jedoch false , dann wird der zweite Anweisungsblock (der nach dem else ) ausgef\u00fchrt. Es wird also genau einer der beiden Anweisungsbl\u00f6cke ausgef\u00fchrt - entweder der eine oder der andere (je nach Wert der Bedingung). Noch ein Beispiel aus dem euklidischen Algorithmus : if ( a > b ) { a = a - b ; } else { b = b - a ; } Innerhalb der Anweisungsbl\u00f6cke k\u00f6nnen nat\u00fcrlich jeweils mehrere Anweisungen stehen. Als Information sei hier gesagt, dass es theoretisch m\u00f6glich ist, bei nur einer Anweisung die Klammern wegzulassen, also z.B. if ( a > b ) a = a - b ; else b = b - a ; Aber wir machen das nicht, da solche Programme nicht gut erweiterbar sind! Es gibt gen\u00fcgend Beispiele, in denen so etwas schief lief (z.B. bei Apple ). Die allgemeine Syntax einer solchen Selektion sieht also wie folgt aus: if ( bedingung ) { /* * Anweisungsblock, der ausgef\u00fchrt wird, * wenn die bedingung true ist. * das k\u00f6nnen beliebig viele Anweisungen sein: * Sequenzen, Iterationen und/oder Selektionen */ } else { /* * Anweisungsblock, der ausgef\u00fchrt wird, * wenn die bedingung false ist. * das k\u00f6nnen beliebig viele Anweisungen sein: * Sequenzen, Iterationen und/oder Selektionen * dieser else -Block kann aber auch ganz weg- * gelassen werden - sehen wir gleich */ }","title":"if...else"},{"location":"selektion/#bedingungen","text":"Bevor wir uns noch weitere Varianten der if...else -Anweisung anschauen, gehen wir nochmal darauf ein, was eine Bedingung ist. Eine Bedingung ist ein logischer Ausdruck, - d.h. der Datentyp des Wertes einer Bedingung ist `boolean`, - d.h. der Wert einer Bedingung ist entweder `true` oder `false` Wir betrachten einige Beispiele von Bedingungen (wir nehmen an, dass die Methoden isOdd(int) und notZero(int) existieren und ein boolean zur\u00fcckgeben): boolean cond1 = true ; // kann genutzt werden als if(cond1) oder if(true) boolean cond2 = cond1 ; // kann genutzt werden als if(cond2) oder if(cond1) boolean cond3 = cond1 && true ; // kann genutzt werden als if(cond3) oder if(cond1 && true) boolean cond4 = ( 7 >= 4 ); // kann genutzt werden als if(cond4) oder if(7 >= 4) boolean cond5 = ( 7 >= 4 ) && ( 3 < 5 ); // kann genutzt werden als if(cond5) oder if((7 >= 4) && (3 < 5)) boolean cond6 = cond5 || cond3 ; // kann genutzt werden als if(cond6) oder if(cond5 || cond3) boolean cond7 = isOdd ( 3 ) && notZero ( 3 ); // kann genutzt werden als if(cond7) oder if(isOdd(3) && notZero(3)) Wichtig ist also, dass alle Werte, die vom Typ boolean sind, als Bedingungen verwendet werden k\u00f6nnen. Achten Sie auch darauf, dass die Ausdr\u00fccke selbst (also die Bedingungen) kein Semikolon am Ende haben - Ausdr\u00fccke sind keine Anweisungen. Beachte Vergleichen Sie logische Ausdr\u00fccke nicht mit true ! Man sieht h\u00e4ufig so etwas wie isOdd(3) == true . Das ist unn\u00f6tig! Angenommen, der Wert von isOdd(3) ist true , dann ist auch der Vergleich isOdd(3) == true true . Angenommen, der Wert von isOdd(3) ist false , dann ist auch der Vergleich isOdd(3) == true false . Das bedeutet, der Wert des Vergleiches entspricht exakt dem Wert von isOdd(3) , also benutzen wir nur isOdd(3) .","title":"Bedingungen"},{"location":"selektion/#ifelse-ohne-else-block","text":"Der else -Block ist nicht zwingend n\u00f6tig. Es gibt Beispiele, in denen etwas getan werden soll, wenn eine bestimmte Bedingung gilt, aber wenn sie nicht gilt, dann muss auch nichts getan werden, z.B. (Methoden ausgedacht): if ( fileOpen ( file )) { closeFile ( file ); } if ( connectionEstablished ( database )) { disconnect ( database ); } if ( divisor == 0 ) { System . out . println ( \"Divsion durch 0 nicht m\u00f6glich!\" ); }","title":"if...else ohne else-Block"},{"location":"selektion/#verschachtelte-selektionen","text":"Die Anweisungsbl\u00f6cke sowohl im true -Zweig als auch im else -Zweig k\u00f6nnen beliebige Kontrollstrukturen enthalten: nur eine Anweisung oder Sequenzen von Anweisungen und/oder Iterationen und/oder Selektionen. Ist eine Selektion innerhalb einer Selektion, spricht man auch von verschachtelten Selektionen. Angenommen, wir haben drei int -Variablen a , b , c und wollen diese der Gr\u00f6\u00dfe nach sortieren (und wollen auch noch pr\u00fcfen, ob die Werte evenzuell gleich sind): // a, b, c vom Typ `int` if ( a > b ) { if ( b > c ) { System . out . println ( \"a > b > c\" ); } else // c >= b { if ( c > b ) { if ( a > c ) { System . out . println ( \"a > c > b\" ); } else // c >= a { if ( c > a ) { System . out . println ( \"c > a > b\" ); } else // c == a { System . out . println ( \"c = a > b\" ); } } } else // c == b { System . out . println ( \"a > b = c\" ); } } } else // b >= a { if ( b > a ) { if ( b > c ) { if ( a > c ) { System . out . println ( \"b > a > c\" ); } else // c >= a { if ( c > a ) { System . out . println ( \"b > c > a\" ); } else // a == c { System . out . println ( \"b > a = c\" ); } } } else // c >= b { if ( c == b ) { System . out . println ( \"b = c > a\" ); } else // c > b { System . out . println ( \"c > b > a\" ); } } } else // b == a { if ( b > c ) { System . out . println ( \"a = b > c\" ); } else // c >= b { if ( c == b ) { System . out . println ( \"a = b = c\" ); } else // c > b { System . out . println ( \"c > b = a\" ); } } } } Sie sehen, so etwas wird sehr schnell sehr un\u00fcbersichtlich. Wir sollten versuchen, solche Verschachtelungen nur auf sehr geringe Verschachtelungstiefen zu beschr\u00e4nken. Die beste M\u00f6glichkeit, solche Verschachtelungstiefen zu vermeiden, besteht darin, die Bedingungen komplexer zu gestalten indem wir logische Operatoren verwenden, z.B. if(a > b) && (b > c)) . Wir zeigen das mal am obigen Beispiel, in dem wir gar keine Verschachtelungstiefe haben: // a, b, c vom Typ `int` if ( a > b && b > c ) { System . out . println ( \"a > b > c\" ); } if ( a > b && c > b && a > c ) { System . out . println ( \"a > c > b\" ); } if ( a > b && c > b && c > a ) { System . out . println ( \"c > a > b\" ); } if ( a > b && c > b && c == a ) { System . out . println ( \"a = c > b\" ); } if ( a > b && b == c ) { System . out . println ( \"a > b = c\" ); } if ( a == b && b == c ) { System . out . println ( \"a = b = c\" ); } if ( a == b && b > c ) { System . out . println ( \"a = b > c\" ); } if ( a == b && c > b ) { System . out . println ( \"c > a = b\" ); } if ( b > a && a > c ) { System . out . println ( \"b > a > c\" ); } if ( b > a && c > a && b > c ) { System . out . println ( \"b > c > a\" ); } if ( b > a && c > a && b == c ) { System . out . println ( \"b = c > a\" ); } if ( b > a && c == a ) { System . out . println ( \"b > c = a\" ); } if ( b > a && c > b ) { System . out . println ( \"c > b > a\" ); } \u00dcbung Bei welchem der beiden oberen Programme werden (im Durchschnitt) mehr Vergleiche durchgef\u00fchrt und warum? Das Problem mit komplexen Bedingungen besteht darin, dass diese recht schwer zu verstehen sind. F\u00fcr komplexe Bedingungen sollten wir stets eigene Methoden definieren (die ein boolean zur\u00fcckgeben) und die mit ihrem Namen verraten, was die Bedingung pr\u00fcft. Darauf kommen wir sp\u00e4ter nochmal zur\u00fcck.","title":"Verschachtelte Selektionen"},{"location":"selektion/#switch-anweisung","text":"Die switch -Anweisung war in Java lange ungl\u00fccklich gel\u00f6st. Die switch -Anweisung kann verwendet werden, wenn Sie viele Fallunterscheidungen haben. Wir geben zun\u00e4chst ein Beispiel in der alten Form der switch -Anweisung, die immer noch funktioniert und die Sie so wahrscheinlich auch noch sehr h\u00e4ufig antreffen werden: // monat vom Typ `int` switch ( monat ) { case 1 : System . out . println ( \"Januar\" ); break ; case 2 : System . out . println ( \"Februar\" ); break ; case 3 : System . out . println ( \"M\u00e4rz\" ); break ; case 4 : System . out . println ( \"April\" ); break ; case 5 : System . out . println ( \"Mai\" ); break ; case 6 : System . out . println ( \"Juni\" ); break ; case 7 : System . out . println ( \"Juli\" ); break ; case 8 : System . out . println ( \"August\" ); break ; case 9 : System . out . println ( \"September\" ); break ; case 10 : System . out . println ( \"Oktober\" ); break ; case 11 : System . out . println ( \"November\" ); break ; case 12 : System . out . println ( \"Dezember\" ); break ; default : System . out . println ( \"kein Monat\" ); } Betrachten wir die Anweisung zun\u00e4chst etwas genauer. Die Fallunterscheidungen betreffen den Wert der int -Variablen monat . Das bedeutet schonmal, dass in den runden Klammern der switch() -Anweisung keine Bedingung steht, sondern ein Ausdruck, der von verschiedenen Datentypen sein kann, z.B. byte , short , int und String . Der Ablauf einer switch() -Anweisung ist nun so, dass f\u00fcr den entsprechenden Wert der case gesucht wird, also z.B. wenn month den Wert 6 hat, dann ist case 6: der \"Einsprungspunkt\". Dort werden nun alle Anweisungen abgearbeitet, bis entweder ein break; kommt oder die switch() -Anweisung beendet ist. break; stoppt also die Abarbeitung. W\u00fcrde in unserem Beispiel kein break enthalten sien und w\u00e4re month z.B. 6 , dann w\u00fcrden alle Monate ab und inkl. Juli ausgegeben werden. Der default: -Fall ist daf\u00fcr, falls keine der case passt. Der default: -Fall ist optional. Dass die Anweisungen nach case x: nicht in Anweisungsbl\u00f6cken stehen und dass die Verwendung von break; erforderlich ist, um die Ausf\u00fchrung von Anweisungen zu stoppen, macht diese alte Syntax der switch() -Anweisung unsch\u00f6n. Wir betrachten noch ein Beispiel in der alten Syntax, um den Unterschied zur neuen noch besser zu erl\u00e4utern: // monat vom Typ `int` int anzahlTageImMonat = 0 ; switch ( monat ) { case 1 : case 3 : case 5 : case 7 : case 8 : case 10 : case 12 : anzahlTageImMonat = 31 ; break ; case 4 : case 6 : case 9 : case 11 : anzahlTageImMonat = 30 ; break ; case 2 : anzahlTageImMonat = 28 ; } Ab Java 12 wurde die switch() -Anweisung gr\u00fcndlich \u00fcberarbeitet. Wir betrachten das so eben gezeigte Beispiel nun in der neuen Schreibweise: int anzahlTageImMonat = switch ( monat ) { case 1 , 3 , 5 , 7 , 8 , 10 , 12 -> 31 ; case 4 , 6 , 9 , 11 -> 30 ; case 2 -> 28 ; default -> 0 ; }; Mehrere Dinge fallen auf: kann eine switch() -Anweisung nun auch als Ausdruck verwendet werden und somit z.B. einer Variablen einen Wert zu weisen (das machen wir hier) hat sich die Schreibweise beim case ge\u00e4ndert. Aus dem Doppelpunkt wurde ein Pfeil und es k\u00f6nnen mit einem case auch mehrere durch Komma getrennte Werte aufgef\u00fchrt werden und - besonders gut - wir ben\u00f6tigen kein break mehr. Es wird immer nur der case ausgef\u00fchrt. Die Abarbeitung der dort beschriebenen Anweisungen stoppt beim n\u00e4chsten case bzw. bei default oder am Ende der switch() -Anweisung Success Wir haben 2 M\u00f6glichkeiten kennengelernt, die Selktion in Java zu implementieren. Die eine (und bedeutendste) M\u00f6glichkeit ist die if...else -Anweisung. Dort wird in Abh\u00e4ngigkeit vom Wahreheitswert einer Bedingung entweder der eine oder der andere Anweisungsblock ausgef\u00fchrt. Der else -Block kann auch weggelassen werden. Innerhalb eines Anweisungsblockes k\u00f6nnen beliebige Kontrollstrukturen stehen: Sequenzen, Iterationen und Selektionen. Die zweite M\u00f6glichkeit ist die switch() -Anweisung, die seit Java 12 auch selbst ein Ausdruck sein kann. Wir haben die alte Syntax der switch() -Anweisung kritisch betrachtet und die neue Syntax kennengelernt.","title":"switch-Anweisung"},{"location":"start/","text":"Unser erstes Programm \u00b6 Bevor wir uns mit der Funktionsweise von Java auseinandersetzen, schreiben wir einfach einmal unser erstes Programm. Wir \u00f6ffnen dazu Eclipse und erstellen uns ein Klasse HelloFIW . Dazu erstellen wir uns ein Java-Projekt (falls noch nicht geschehen): Men\u00fcpunkt File --> New --> Java Project , geben dort z.B. WiSe20 ein und wenn wir gefragt, werden, ob wir eine module-info.java erstellen wollen, w\u00e4hlen wir Don't create . erstellen wir uns ein Paket: Men\u00fcpunkt File --> New --> Package und geben themen.eins.start ein. erstellen wir uns eine Klasse: Wir w\u00e4hlen das Paket themen.eins.start aus und w\u00e4hlen den Men\u00fcpunkt File --> New --> Class , geben in dem Fenster den Klassennamen HelloFIW ein und setzen bei public static void main(Strg[] args) ein H\u00e4kchen: Im Editor-Fenster von Eclipse erscheint: Schauen wir uns diesen Code zun\u00e4chst an: in Zeile 1 sehen wir, in welchem Paket sich unsere Klasse befindet. Die Anweisung package themen.eins.start; definiert, dass wir uns im Paket themen.eins.start` befinden. Mit Paketen werden wir uns in K\u00fcrze ausf\u00fchrlich auseinandersetzen. in Zeile 3 steht unsere Klassendefinition. Diese erkennen wir am Schl\u00fcsselwort class gefolgt von dem Namen der Klasse HelloFIW . Das Schl\u00fcsselwort public beschreibt, dass es sich um eine \u00f6ffentliche Klasse handelt, die von allen genutzt werden kann. Dieses Schl\u00fcsselwort ist ein sogenannter Sichtbarkeitsmodifierer (auch Zugriffsmodifizierer ). Mit Sichtbarkeitsmodifizierern werden wir uns ebenfalls noch ausf\u00fchrlich auseinandersetzen. Wichtig ist, dass die Klasse nicht nur aus dem Klassenkopf ( public class HelloFIW ) besteht, sondern aus allem, was diese Klassen enth\u00e4lt (dem Klassenrumpf). Der Klassenrumpf beginnt mit einer \u00f6ffnenden geschweiften Klammer { (Zeile 4 ) und endet mit einer schlie\u00dfenden geschweiften Klammer } (Zeile 12 ). eine Klasse kann beliebig viele Methoden enthalten. Unsere Klasse enth\u00e4lt bis jetzt eine Methode, die Methode namens main() . Methoden erkennen wir an den runden Klammern nach dem Methodennamen. Hier ist der Name main gefolgt von runden Klammern, in denen Parameter (auch Argumente genannt) definiert sein k\u00f6nnen (hier ein Parameter namens \u00e0rgs vom Typ String-Array: Strg[] args ). Wie bei den Klassen auch, bestehen Methoden aus einem Methodenkopf und einem Methodenrumpf. Wie bei den Klassen auch, beginnt der Methodenrumpf mit einer \u00f6ffnenden geschweiften Klammer (Zeile 7 ) und endet mit einer schlie\u00dfenden geschweiften Klammer (Zeile 10`). Der Methodenkopf beginnt erneut mit einem Sichtbarkeitsmodifizierer. Dieser ist hier wieder public und gibt an, dass diese Methode \u00f6ffentlich ist und von allen ausgef\u00fchrt werden kann. Danach kommt das Schl\u00fcsselwort static . Dieses Schl\u00fcsselwort besagt, dass es sich bei dieser Methode um eine Klassenmethode handelt. Das Gegenst\u00fcck zu einer Klassenmethode ist die Objektmethode . Wir werden uns mit der Unterscheidung zwischen Klassen- und Objektmnethoden ausf\u00fchrlich auseinandersetzen. Wir k\u00f6nnen uns aber schon merken (wenn \u00fcberhaupt), dass wir eine Klassenmethode aufrufen k\u00f6nnen ohne ein Objekt der Klasse erstellen zu m\u00fcssen. Danach kommt das Schl\u00fcsselwort void . Dieses Schl\u00fcsslwort gibt an, dass die Methode nichts zur\u00fcckgibt. An dieser Stelle steht der R\u00fcckgabetyp eine Methode - wenn die Methode etwas zur\u00fcckgibt. Unsere Methode gibt nichts zur\u00fcck, deshalb hier void . Wir werden uns mit Methodenr\u00fcckgaben ausf\u00fchrlich besch\u00e4ftigen. Jetzt kommt der Name der Methode, hier main . Die main() -Methode ist eine ganz besondere Methode. Sie existiert in einem Programm genau einmal und wird aufgerufen, wenn das Programm aufgerufen wird - die sogenannte Programmmethode . Wenn wir ein Programm ausf\u00fchren, wird alles das ausgef\u00fchrt, was in dem Rumpf der main() -Methode definiert ist (derzeit noch nichts). In den runden Klammern stehen Parameter (auch Argumente genannt). In unserem Fall ist ein Parameter namens args definiert. Der Datentyp dieses Parameters ist Strg[] , d.h. dass der Parameter einem Array von Zeichenketten Strings entspricht. Wir k\u00fcmmern uns um Parameter sp\u00e4ter ausf\u00fchrlich. In unserer Methode gibt es derzeit nur einen einzigen Eintrag (Zeile 8 ). Dabei handelt es sich um einen Kommentar , genauer hier um einen Zeilenkommentar . Zeilenkommentare beginnen mit einem Doppelslash // . Hinter diesen Doppelslash k\u00f6nnen Sie schreiben, was Sie m\u00f6chten - bis an das Zeilenende. Kommentare dienen Ihnen dazu, den Code verst\u00e4ndlicher zu gestalten oder Ihnen Hinweise zu geben. Hier steht der Hinweis, dass die Methode automatisch durch Eclipse erstellt wurde und Sie noch das ToDo haben, die Methode zu bef\u00fcllen. Das machen wir jetzt auch! Wir l\u00f6schen den Kommentar und f\u00fcgen nun die Anweisung System.out.println(\"HelloFIW !\"); in unseren Methodenrumpf ein. Unsere Klasse sieht nun so aus (die neuhinzugekommene Zeile ist markiert): HelloFIW.java 1 2 3 4 5 6 7 8 9 10 11 12 package themen.eins.start ; public class HelloFIW { public static void main ( String [] args ) { System . out . println ( \"Hello FIW!\" ); } } Jetzt w\u00e4hlen wir entweder im Men\u00fc Run --> Run oder klicken auf den kleinen gr\u00fcnen Kreis mit dem wei\u00dfen Pfeil in der Mitte in der Werkzeugleiste. Sie werden gefragt, ob Sie Ihr Programm zun\u00e4chst speichern wollen. Bevor Sie das best\u00e4tigen, sollten Sie ein H\u00e4kchen setzen, um zu sagen, dass Sie das gar nicht mehr gefragt werden wollen, sondern das Programm immer gespeichert werden soll, bevor Sie es ausf\u00fchren. In der Konsole erscheint: Success Herzlichen Gl\u00fcckwunsch! Sie haben Ihr erstes Java-Programm geschrieben und ausgef\u00fchrt! System.out.println(\"Hello FIW!\"); \u00b6 Schauen wir uns System.out.println(\"Hello FIW!\"); zun\u00e4chst etwas genauer an. Wir verwenden hier eine Klasse, n\u00e4mlcih die Klasse System . Diese Klasse existiert bereits und wurde von den Java-Entwicklern f\u00fcr uns gesschrieben. Sie geh\u00f6rt zum Standardpaket von Java, existiert bereits seit der ersten Version von Java und befindet sich im Paket java.lang . Diese Klasse hat eine interssante Klassenvariable, die wir verwenden, n\u00e4mlich out . Diese Variable stellt in unserem (Betriebs-)System die Verbindung zu unserem Standardausgabeger\u00e4t bereit, in unserem Fall die Konsole. Um nun eine Ausgabe auf diese Konsole zu generieren verwenden wir die Methode println() . Wir sehen hier eine typische Notation in Java, die sogenannte Punktnotation . Mithilfe dieser Punktnotation greifen wir auf Eigenschaften von Klassen und Objekten zu. In unserem Beispiel greifen wir mit System.out auf das Standardausgabeger\u00e4t zu und mit System.out.println() auf die println() -Methode des Ausgabeger\u00e4tes 1 . Die Methode println() erzeugt also eine Ausgabe auf unsere Konsole. Jetzt m\u00fcssen wir nur noch sagen, WAS ausgegeben werden sollen. Dazu \u00fcbergeben wir dieser Methode eine Zeichenkette (einen String ). Eine Zeichenkette erkennt man an den doppelten Anf\u00fchrungsstrichen \"das ist eine Zeichekette\" . Innerhalb dieser Anf\u00fchrungsstriche k\u00f6nnen Sie schreiben, was Sie m\u00f6chten (au\u00dfer \" ). Wir haben uns f\u00fcr \"Hello FIW!\" entschieden und genau diese Zeichenkette (ohne die Anf\u00fchrungsstriche) wird ausgegeben. Die Zeichnkette, die wir ausgeben m\u00f6chten, schreiben wir in die runden Klammern der println() -Methode, also println(\"Hello FIW!\") . Bei System.out.println(\"Hello FIW!\"); handelt es sich um eine Anweisung . Eine Anweisung endet in Java immer mit einem Semikolon ; . Dieses d\u00fcrfen wir nicht vergessen, ansonsten haben wir einen Syntaxfehler und unser Programm kann nicht compiliert und nicht ausgef\u00fchrt werden. Tipp Wir m\u00fcssen System.out.println() von nun an recht h\u00e4ufig schreiben. Deshalb gibt es in Eclipse daf\u00fcr einen Shortcut. Schreiben Sie einfach syso und klicken dann die Control ( Strg )-Taste zusammen mit der Leertaste und dann Enter . Aus dem syso macht Eclipse dann automatisch System.out.println() . println() vs. print() \u00b6 In unserem ersten Programm haben wir die Methode println() verwendet, um etwas auf der Konsole auszugeben. Es gibt noch eine andere M\u00f6glichkeit f\u00fcr die Ausgabe auf die Konsole, n\u00e4mlich die Methode print() , also ohne ln . Das ln steht f\u00fcr Line und gibt an, dass nach der Ausgabe ein Zeilenumbruch erfolgt. Wir \u00e4ndern zun\u00e4chst unser Programm, indem wir die Anweisung System.out.println(\"Hello FIW!\"); kopieren und weitere 2x einf\u00fcgen. main()-Methode mit println() 1 2 3 4 5 6 7 8 9 10 11 12 13 package themen.eins.start ; public class HelloFIW { public static void main ( String [] args ) { System . out . println ( \"Hello FIW!\" ); System . out . println ( \"Hello FIW!\" ); System . out . println ( \"Hello FIW!\" ); } } Wir f\u00fchren das Programm erneut aus (gr\u00fcner Pfeil) und erhalten auf der Konsole die Ausgabe: Hello FIW! Hello FIW! Hello FIW! Das hei\u00dft, dass jede der Ausgaben mithilfe der println() -Methode in einer neuen Zeile erfolgt. Nach jeder Ausgabe erfolgt also ein Zeilenumbruch, der Ausgabecursor wird in die n\u00e4chste Zeile gesetzt. Die n\u00e4chste Ausgabe beginnt am Anfang der neuen Zeile. Wir wollen nun unser Programm \u00e4ndern und verwenden nicht mehr die println() - Methode, sondern print() : main()-Methode mit print() 1 2 3 4 5 6 7 8 9 10 11 12 13 package themen.eins.start ; public class HelloFIW { public static void main ( String [] args ) { System . out . print ( \"Hello FIW!\" ); System . out . print ( \"Hello FIW!\" ); System . out . print ( \"Hello FIW!\" ); } } Wir f\u00fchren das Programm erneut aus (gr\u00fcner Pfeil ) und erhalten auf der Konsole die Ausgabe: Hello FIW!Hello FIW!Hello FIW! Die print() -Methode gibt also nur die Zeichenkette aus, f\u00fchrt aber danach keinen Zeilenumbruch durch. Der Ausgabecursor bleibt hinter dem letzten ausgegebenen Zeichen stehen. Unsere drei Zeichenketten werden in der Konsole deshalb hintereinander ausgegeben. \u00dcbung Was m\u00fcssen Sie im Programm \u00e4ndern, damit zwischen ! und H jeweils ein Leerzeichen ist, also anstelle von Hello FIW!Hello FIW!Hello FIW! besser Hello FIW! Hello FIW! Hello FIW! ausgegeben wird? Wir \u00e4ndern nun unser Programm erneut und f\u00fcgen folgende Anweisungen hinzu: System.out.println() . Wir rufen also die println() -Methode auf, ohne eine Zeichenkette zu \u00fcbergeben, die ausgegeben werden soll. Diese Anweisung sorgt einfach daf\u00fcr, dass ein Zeilenumbruch erfolgt. Es wird also nichts ausgegeben, aber der Ausgabecursor an den Beginn der n\u00e4chsten Zeile gesetzt. main()-Methode mit print() und println() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package themen.eins.start ; public class HelloFIW { public static void main ( String [] args ) { System . out . print ( \"Hello FIW!\" ); System . out . println (); System . out . print ( \"Hello FIW!\" ); System . out . println (); System . out . print ( \"Hello FIW!\" ); System . out . println (); } } Wir f\u00fchren das Programm erneut aus (gr\u00fcner Pfeil ) und erhalten auf der Konsole die Ausgabe: Hello FIW! Hello FIW! Hello FIW! \u00dcbung Erzeugen Sie folgende Ausgabe auf der Konsole: Hello FIW! Hello FIW! Hello FIW! Eine m\u00f6gliche L\u00f6sung 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package themen.eins.start ; public class HelloFIW { public static void main ( String [] args ) { System . out . println ( \"Hello FIW!\" ); System . out . println (); System . out . println ( \"Hello FIW!\" ); System . out . println (); System . out . println ( \"Hello FIW!\" ); System . out . println (); } } Syntaxfehler \u00b6 Programmieren bedeutet auch, Fehler zu machen. Wichtig ist, dass Sie die Fehlerausschriften lesen und die Fehler analysieren. Haben Sie einen Syntaxfehler, so ist ein Bereich Ihres Programmcodes rot unterstrichen und an der Seite erscheint ein rotes Kreuz. Fahren Sie mit der Maus \u00fcber das rote Kreuz, um die Fehlerausschrift zu erhalten. Bei einem Syntaxfehler l\u00e4sst sich das Programm nicht compilieren. Sie k\u00f6nnen es trotzdem versuchen und erhalten die Fehlerausschrift dann auf der Konsole. Das folgende Bild zeigt einen Fehler: Es erscheint die Fehlermeldung Syntax error, insert \";\" to complete BlockStatements - ein Hinweis darauf, dass ein Semikolon fehlt - n\u00e4mlcih am Ende der Anweisung. In vielen F\u00e4llen bietet Eclipse einen sogenannten Quickfix an. Meistens k\u00f6nnen Sie diesen Vorschlag einfach annehmen (durch Mausclick auf den Vorschlag). Die folgende Abbildung zeigt einen solchen Quickfix f\u00fcr den Fehler, dass die Methode prntln() nicht existiert (es fehlt das i ). Success Wir haben unser erstes Java-Programm geschrieben und ausgef\u00fchrt! Wir haben gelernt, wie wir mithilfe der Methoden println() und print() Zeichenketten auf die Konsole ausgeben k\u00f6nnen und wir haben uns angeschaut, wie wir Fehlerausschriften lesen. Nun schauen wir uns einmal an, was im Hintergrund passiert, wenn wir das Programm ausf\u00fchren. Kommentare \u00b6 In Ihren Quellcode (Ihr Programm) k\u00f6nnen Sie an allen beliebigen Stellen Kommentare schreiben. Kommentare werden vom Compiler ignoriert, d.h. Sie k\u00f6nnen dort hineinschreiben, was und wie Sie m\u00f6chten. Es gibt drei Arten von Kommentaren in Java: Zeilenkommentare : Diese beginnen mit // und danach kommt der Kommentar bis zum Zeilenende. Die neue Zeile ist dann wieder \"normaler\" Quellcode System . out . println ( \"Ausgabe1\" ); // hier ist ein Zeilenkommentar bis zum Ende der Zeile System . out . println ( \"Ausgabe2\" ); // hier ist noch ein Zeilenkommentar Blockkommentare : Diese beginnen mit /* und danach kommt der Kommentar. Er kann sich \u00fcber mehrere Zeilen erstrecken. Ein Blockkommentar endet mit */ . Nach diesem Ende ist sofort wieder \"normaler\" Quellcode. System . out . println ( \"Ausgabe1\" ); /* hier ist ein Blockkommentar er kann \u00fcber beliebig viele Zeilen gehen Er endet erst mit */ System . out . println ( \"Ausgabe2\" ); Java-Doc-Kommentare : javadoc ist ein Programm aus dem Java Development Kit (JDK) . Es wird eingesetzt, um den Code zu dokumentieren. Wir werden javadoc noch ausf\u00fchrlich behandeln. Mit javadoc kommentierte Klassen finden Sie hier . Java-Doc-Kommentare beginnen mit /** und enden mit */ . Java-Doc-Kommentare verhalten sich wie Blockkommentare. Sie erstrecken sich \u00fcber mehrere Zeilen und nach dem */ ist, wie bei Blockkommentaren, wieder \"normaler\" Quellcode. package uebungen.uebung0 ; /** * * @author jornfreiheit * * Das ist die erste Klasse, die wir geschrieben haben. * Sie erzeugt einfache Ausgaben von Zeichenketten auf * die Konsole. * */ public class MyFirstClass { // Hier die Implementierung unserer Klasse - nicht gezeigt } Compilieren und Ausf\u00fchren \u00b6 Wir haben nun unser erstes einfaches Programm geschrieben - in der Programmiersprache Java . Wie wir in Werkzeuge -> Java bereits bei der Installation von Java erl\u00e4utert haben, ist Java nicht nur eine Programmiersprache, sondern auch ein Programm, in dem wir Java-Programme ausf\u00fchren k\u00f6nnen - die Laufzeitumgebung von Java. Wir werden zun\u00e4chst erl\u00e4utern, was im Hintergrund passiert, wenn wir ein selbstgeschriebenes Java-Programm ausf\u00fchren. Zum besseren Verst\u00e4ndnis erzeugen wir uns zun\u00e4chst ein Verzeichnis test irgendwo auf unserem Rechner: mkdir test cd test Dieses Verzeichnis werden wir sp\u00e4ter wieder l\u00f6schen. Nun erzeugen wir uns mithilfe von vi oder vim eine Datei Test.java : vim Test.java Die Datei \u00f6ffnet sich zum Schreiben und nach Eingabe von i k\u00f6nnen wir in diese Datei Text einf\u00fcgen. Wir f\u00fcgen folgendes Programm ein (Kopieren Sie das Programm und f\u00fcgen es mit Strg+V in die Datei Test.java ein: Test.java 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Test { public static void main ( String [] args ) { System . out . print ( \"Hello \" ); for ( String s : args ) { System . out . print ( s + \" \" ); } System . out . println ( \"!\" ); } } Beenden Sie den Einf\u00fcgemodus von vim durch Dr\u00fccken der Taste Esc und speichern die Datei und beenden vim unter Eingabe von ZZ . In unserem Ordner test befindet sich nun die Datei Test.java : ls -la zeigt den Inhalt unseres Verzeichnisses test an (z.B.): total 8 drwxr-xr-x@ 3 jornfreiheit staff 96 3 Aug 14 :17 . drwxr-xr-x@ 39 jornfreiheit staff 1248 1 Nov 2018 .. -rw-r--r-- 1 jornfreiheit staff 189 3 Aug 14 :17 Test.java Wir haben eine Klasse Test in der Datei erstellt, die genauso hei\u00dft, wie die Klasse, n\u00e4mlich Test.java . Wir werden in Zukunft immer die Klasse in der gleichnamigen Datei speichern, die die Dateiendung .java hat - das macht Eclipse f\u00fcr uns automatisch. Compilieren der Klasse \u00b6 Ein Computer kann keine Datei ausf\u00fchren, die in einer Programmiersprache geschrieben wurde, egal um welche Programmiersprache es sich handelt. Computer verstehen nur Folgen von Nullen und Einsen, also so etwas wie 1000111110101011... . In eine solche Maschinensprache muss unser Programm \u00fcbersetzt werden. Das \u00dcbersetzen erfolgt durch einen Compiler 2 . Der Java-Compiler hei\u00dft javac . Wir haben den Java-Compiler zusammen mit dem Java Development Kit (JDK) installiert (siehe hier ). Mithilfe des Compilers \u00fcbersetzen wir nun unsere Klasse: javac Test . java Wenn wir uns nun erneut den Inhalt unseres Verzeichnisses ansehen ls -la dann entdecken wir, dass eine Datei Test.class erzeugt wurde. total 16 drwxr-xr-x@ 4 jornfreiheit staff 128 7 Aug 11 :02 . drwxr-xr-x@ 39 jornfreiheit staff 1248 1 Nov 2018 .. -rw-r--r-- 1 jornfreiheit staff 1001 7 Aug 11 :02 Test.class -rw-r--r-- 1 jornfreiheit staff 189 3 Aug 14 :17 Test.java Unser Java-Compiler hat unser Programm, das in Test.java enthalten ist, in sogenannten Bytecode \u00fcbersetzt. Das ist ein Zwischenschritt, den es in Java gibt. Das Programm wird nicht direkt in Maschinencode \u00fcbersetzt, sondern in Bytecode. Ausf\u00fchren des Programms \u00b6 Dieser Bytecode kann nun von der Java-Laufzeitumgebung (Java Runtime Environment - JRE) ausgef\u00fchrt werden. Diese Laufzeitumgebung ist selbst ein Programm, eine sogenannte Virtuelle Maschine 3 . Die Ausf\u00fchrung unseres Programms erfolgt mithilfe der Java-Laufzeitumgebung java : java Test Beachten Sie, dass Sie nicht die Dateiendung .class f\u00fcr Ihr Programm angeben (m\u00fcssen/d\u00fcrfen). Auf unserer Konsole erscheint die Ausgabe Hello ! Diese Ausgabe erfolgt durch die Anweisung System.out.print(\"Hello \"); (in Zeile 6 ), gefolgt von der Anweisung System.out.println(\"!\"); (in Zeile 11 ). In den Zeilen 7 - 10 stehen Anweisungen, die wir noch nicht verstehen. Das macht nichts, wir kommen sp\u00e4ter darauf zur\u00fcck. Es ist jedoch so, dass wir dadurch unserem Programm Argumente \u00fcbergeben k\u00f6nnen. Betrac hten wir zum Beispiel die Anweisung ls -la . ls w\u00e4re z.B. ein \"Programm\" und -la ein Argument ( -l sorgt daf\u00fcr, dass ein langes Listenformat erscheint, also alle Angaben zu den Dateien und Ordnern erscheinen und -a sorgt daf\u00fcr, dass auch die Dateien und Ordner angezeigt werden, die mit . beginnen). Versuchen wir also einmal, umserem Programm Test ein Argument zu \u00fcbergeben (ohne - ): java Test FIW Es erscheint die Ausgabe: Hello FIW ! Wir k\u00f6nnen sogar mehrere Argumente \u00fcbergeben: java Test FIW HTW Berlin Welt Es erscheint die Ausgabe: Hello FIW HTW Berlin Welt ! Es erscheint zun\u00e4chst aufwendig, das Programm zun\u00e4chst in Bytecode zu \u00fcbersetzen und dann den Bytecode nochmal interpretieren und ausf\u00fchren zu lassen. Warum wird nicht direkt in Maschinencode \u00fcbersetzt? Die Antwort ist, dass der Java-Compiler so beriebssystemunabh\u00e4ngig arbeiten kann. Alle, egal, ob Windows-, iOS- oder Linux-Nutzerinnen k\u00f6nnen den gleichen Compiler verwenden. Die Programme k\u00f6nnen v\u00f6llig systemunabh\u00e4ngig geschrieben und von allen compiliert werden. Erst die Java-Laufzeitumgebung ist beriebssystemabh\u00e4ngig, d.h. diese wird entsprechend dem Betriebssystem installiert. Alle Java-Programme und auch ihre Compilierung sind jedoch v\u00f6llig losgel\u00f6st vom verwendeten Betriebssystem und k\u00f6nnen deshalb \u00fcberall ausgef\u00fchrt werden. Success Wir haben uns angeschaut, was passiert, wenn wir das Programm \u00fcbersetzen und ausf\u00fchren. Die \u00dcbersetzung erfolgt durch den Java-Compiler javac . Dieser erzeugt Java-Bytecode . Die Ausf\u00fchrung dieses Bytcodes \u00fcbernimmt die Java-Laufzeitumgebung java . Diese interpretiert den Bytecode und f\u00fchrt ihn sequentiell (also nacheinander, Anweisung f\u00fcr Anweisung) aus. Was ist Programmieren? \u00b6 Ehe wir uns weiter mit Java und Programmierkonzepten besch\u00e4ftigen, wollen wir uns bewusst werden, was Programmieren \u00fcberhaupt ist. Prinzipiell l\u00f6sen wir beim Programmieren ein Problem mithilfe einer Programmiersprache. Dabei stellt sich die Frage, welche Probleme mithilfe eines Computers l\u00f6sbar sind und welche nicht. Dazu gibt es umfangreiche theoretische Untersuchungen - viele davon werden Sie in den \"Grundlegenden Konzepten der Informatik\" diskutieren. Ein wesentlicher Begriff dabei ist Algorithmus . Ein Algorithmus ist eine eindeutige Handlungsvorschrift, die aus endlich vielen einzelnen Schritten besteht und ein Problem l\u00f6st. Algorithmen sind also auch Kochrezepte oder Bauanleitungen, wenn sie denn \"eindeutig\" sind. Wir kennen alle das Problem, dass Handlungsanweisungen nicht immer eindeutig sind - man kann es manchmal so oder so machen. In der Programmierung darf eine solche Mehrdeutigkeit nat\u00fcrlich nicht vorkommen. Der Algorithmusbegriff wurde deshalb detailliert und folgende Eigenschaften m\u00fcssen f\u00fcr eine Handlungsanweisung f\u00fcr einen Computer gelten, um ein Algrithmus zu sein: Finitheit Das Verfahren muss in einem endlichen Text (Programm) eindeutig beschreibbar sein. Ausf\u00fchrbarkeit Jeder einzelne Schritt des Verfahrens muss auch tats\u00e4chlich ausf\u00fchrbar sein. Dynamische Finitheit Das Verfahren darf zu jedem Zeitpunkt nur endlich viel Speicherplatz ben\u00f6tigen. Terminierung Das Verfahren muss irgendwann enden, d.h. darf nur endlich viele Ausf\u00fchrungsschritte ben\u00f6tigen. Determiniertheit Das Verfahren muss bei denselben Voraussetzungen das gleiche Ergebnis liefern. Determinismus Die n\u00e4chste anzuwendende Regel im Verfahren ist zu jedem Zeitpunkt (in jedem Zustand) eindeutig definiert. Beispiel: Euklidischer Algorithmus \u00b6 Mit dem euklidischen Algorithmus 4 kann der gr\u00f6\u00dfte gemeinsame Teiler (ggT) zweier Zahlen berechnet werden. In seinen Elementen hat er diesen Algorithmus ungef\u00e4hr so formuliert: Euklidischer Algorithmus Wenn CD aber AB nicht misst, und man nimmt bei AB, CD abwechselnd immer das kleinere vom gr\u00f6\u00dferen weg, dann muss (schlie\u00dflich) eine Zahl \u00fcbrig bleiben, die die vorangehende misst. Hm, das ist recht schwierig zu verstehen. Euklid betrachtet die beiden Zahlen, von denen der gr\u00f6\u00dfte gemeinsame Teiler ermittelt werden soll, als Strecken ( AB und CD ). Er zieht wiederholt die kleinere der beiden Strecken von der gr\u00f6\u00dferen ab. Er wiederholt dies solange, bis die beiden Strecken gleich lang sind - genauer: er wiederholt dies solange, solange die beiden Strecken nicht gleich lang sind ( ... CD aber AB nicht misst... ). Beispiel: ggT von 24 und 40 AB: 40, CD: 24, AB gr\u00f6\u00dfer als CD \u2192 40 - 24 = 16 AB: 16, CD: 24, CD gr\u00f6\u00dfer als AB \u2192 24 - 16 = 8 AB: 16, CD: 8, AB gr\u00f6\u00dfer als CD \u2192 16 - 8 = 8 AB: 8, CD: 8, AB gleich CD \u2192 Ende \u2192 ggT ist 8 Wir versuchen, den Algorithmus in einer verst\u00e4ndlicheren und genaueren Sprache zu \u00fcberf\u00fchren, ohne bereits eine Programmiersprache zu verwenden. Wir benutzen sogenannten Pseudocode : Angenommen, die beiden Zahlen, von denen wir den ggT berechnen wollen, sind a und b : 1 2 3 4 5 6 7 solange a ungleich b ist, wiederhole wenn a gr\u00f6\u00dfer ist als b, dann: ziehe b von a ab und weise das Ergebnis a zu andernfalls: ziehe a von b ab und weise das Ergebnis b zu wenn a gleich b ist, dann: a ( oder auch b ) ist der gesuchte ggT Wichtig ist, dass das Einr\u00fccken hier eine Bedeutung hat (eine Semantik ). In Zeile 1 formulieren wir, dass sich etwas wiederholen soll, solange eine bestimmte Bedingung gilt. Das, was sich wiederholen soll, ist in den Zeilen 2 bis 5 formuliert. Zeile 1 formuliert eine Schleife und in den Zeilen 2 - 5 befindet sich der Schleifeninhalt . Die Zeilen 2 - 5 formulieren eine eigenes Konstrukt, n\u00e4mlich eine Auswahl zwischen Alternativen, abh\u00e4ngig von einer Bedingung. Die Bedingung ist, ob a gr\u00f6\u00dfer ist als b . Wenn das der Fall ist, dann wird die Alternative ziehe b von a ab und weise das Ergebnis a zu ausgef\u00fchrt. Ist jedoch a nicht gr\u00f6\u00dfer als b , dann wird die Alternative ziehe a von b ab und weise das Ergebnis b zu ausgef\u00fchrt. Ein solches Konstrukt wird Selektion (oder auch bedingte Alternative ) genannt. Nachdem entweder Zeile 3 oder Zeile 5 ausgef\u00fchrt wurde (es wird genau eins von beiden ausgef\u00fchrt), wird erneut in Zeile 1 gepr\u00fcft, ob a ungleich b ist. Wenn ja, wird die Selektion wiederholt. Wenn nicht, dann ist die Schleife beendet und Zeile 6 wird ausgef\u00fchrt. Die in Zeile 6 formulierte Bedingung wenn a gleich b ist , ist eigentlich unn\u00f6tig. Frage Warum ist die Bedingung wenn a gleich b ist in Zeile 6 unn\u00f6tig? Wir betrachten nochmals die im obigen Algorithmus betrachteten Konstrukte (wir sprechen vom Kontrollfluss von Anweisungen ): Iteration : die Schleife, die in Zeile 1 formuliert wird und die als Schleifeninhalt die Zeilen 2 - 5 hat, beschreibt einen iterativen (sich wiederholenden) Kontrollfluss . Selektion : die bedingte Alternative , die eine Bedingung pr\u00fcft (Zeile 2 ) und dann, je nachdem, ob die Bedingung richtig oder falsch ist, jeweils eine alternative Anweisung ausf\u00fchrt (entweder Zeile 3 oder Zeile 4 ), wird Selektion genannt (siehe Zeilen 2 - 5 ). Sequenz : die Anweisungen werden hintereinander ausgef\u00fchrt, erst Zeile 1 , dann Zeile 2 , dann entweder Zeile 3 oder Zeile 4 usw. Das Hintereinanderausf\u00fchren von Anweisungen wird Sequenz genannt. Schauen wir uns f\u00fcr unseren Algorithmus nochmal die Eigenschaften eines Algorithmus an: Finitheit unsere Beschreibung des Algorithmus ist endlich (siehe oben). Ausf\u00fchrbarkeit jeder einzelne Schritt kann ausgef\u00fchrt werden. Dynamische Finitheit \u00fcber den Speicherplatz k\u00f6nnen wir noch nicht viel sagen, aber wir m\u00fcssen nur einige wenige Zahlen speichern. Das sollte klappen. Terminierung Wann endet unser Algorithmus? Was muss gelten? Wissen wir, ob der Algorithmus irgendwann stoppt? Determiniertheit Es ist sicherlich nicht so leicht zu sehen, ob bei gleicher Eingabe (die Zahlen a und b ) auch stets der gleiche gr\u00f6\u00dfte gemneinsame Teiler berechnet wird. Dazu m\u00fcssten wir uns erstmal \u00fcberlegen, wie wir das pr\u00fcfen k\u00f6nnen. Determinismus Wir werden unseren Algorithmus nochmal an einem Beispiel durchspielen , um ein Gef\u00fchl daf\u00fcr zu bekommen, dass wir stets wissen, welche Anweisung als n\u00e4chstes ausgef\u00fchrt wird. Beispielzahlen f\u00fcr den euklidischen Algorithmus \u00b6 Wir nehmen die Zahlen a=40 und b=24 und spielen damit unseren Algorithmus durch: Zeile 1 : a (40) ist ungleich b (24) , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : a ist gr\u00f6\u00dfer als b , also wird Zeile 3 ausgef\u00fchrt (und genau nicht Zeilen 4 und 5 ) Zeile 3 : das Ergebnis von a-b ist 16. Der neue Wert von a ist 16. Zeile 1 : wegen wiederhole (Iteration): a (16) ist ungleich b (24) , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : a ist nicht gr\u00f6\u00dfer als b , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von b-a ist 8. Der neue Wert von b ist 8. Zeile 1 : wegen wiederhole (Iteration): a (16) ist ungleich b (8) , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : a ist gr\u00f6\u00dfer als b , also wird Zeile 3 ausgef\u00fchrt (und genau nicht Zeile 5 ) Zeile 3 : das Ergebnis von a-b ist 8. Der neue Wert von a ist 8. Zeile 1 : wegen wiederhole (Iteration): a (8) ist nicht ungleich b (8) , also wird der Schleifeninhalt nicht ausgef\u00fchrt Zeile 6 : a (8) ist gleich b (8) Zeile 7 : der gesuchte ggT ist 8 Ende F\u00fcr dieses Beispiel war stets eindeutig, welche Anweisung als n\u00e4chstes ausgef\u00fchrt wird. Der Algrorithmus hat auch terminiert, d.h. er wurde beendet und es sollte auch klar sein, dass das Ergebnis f\u00fcr die die Eingabe a=40 und b=24 stets 8 ist. Fragen Was \u00e4ndert sich, wenn am Anfang a=24 und b=40 sind? Was \u00e4ndert sich, wenn am Anfang a=-40 und b=24 sind? Was \u00e4ndert sich, wenn am Anfang a=-40 und b=-24 sind? Was \u00e4ndert sich, wenn am Anfang a=24 und b=24 sind? Beispiel: (3n+1)-Vermutung (Collatz-Problem) \u00b6 Wir betrachten noch einen weiteren Algorithmus: Als Eingabe bekommen wir eine positive nat\u00fcrliche Zahl, z.B. 5 . Der Algorithmus berechnet eine Folge von Zahlen und zwar nach folgender Vorschrift: ist die Zahl ungerade, dann wird ihr Nachfolger dadurch berechnet, dass die Zahl mit 3 multipliziert und dann 1 addiert wird. Ist die Zahl gerade, dann wird ihr Nachfolger dadurch berechnet, dass die Zahl durch 2 geteilt wird. Der Algorithmus stoppt, wenn der Nachfolger 1 ist. Angenommen, die eingegebene positive nat\u00fcrliche Zahl ist n : 1 2 3 4 5 solange n ungleich 1 ist, wiederhole wenn n ungerade, dann: berechne 3 *n +1 und weise das Ergebnis n zu andernfalls: berechne n/2 und weise das Ergebnis n zu Wir begeben uns also in eine Schleife und berechnen so lange einen Nachfolger f\u00fcr die Zahl bis der NAchfolger 1 ist. Betrachten wir den Algorithmus f\u00fcr die EIngabe von n=5 : Zeile 1 : n (5) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist ungerade , also wird Zeile 3 ausgef\u00fchrt (und genau nicht Zeilen 4 und 5 ) Zeile 3 : das Ergebnis von 3*5+1 ist 16 . Der neue Wert von n ist 16. Zeile 1 : wegen wiederhole (Iteration): n (16) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist nicht ungerade , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 3 : das Ergebnis von 16/2 ist 8 n. Der neue Wert von n ist 8. Zeile 1 : wegen wiederhole (Iteration): n (8) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist nicht ungerade , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 3 : das Ergebnis von 8/2 ist 4 . Der neue Wert von n ist 4. Zeile 1 : wegen wiederhole (Iteration): n (4) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist nicht ungerade , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 3 : das Ergebnis von 4/2 ist 2 . Der neue Wert von n ist 2. Zeile 1 : wegen wiederhole (Iteration): n (2) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist nicht ungerade , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 3 : das Ergebnis von 2/2 ist 1 . Der neue Wert von n ist 1. Zeile 1 : wegen wiederhole (Iteration): n (1) ist nicht ungleich 1 , also wird der Schleifeninhalt nicht ausgef\u00fchrt Ende Auch f\u00fcr dieses Beispiel war erneut stets eindeutig, welche Anweisung als n\u00e4chstes ausgef\u00fchrt wird. Der Algrorithmus hat auch terminiert, d.h. er wurde beendet und es sollte auch klar sein, dass das Ergebnis f\u00fcr die die Eingabe n=5 stets 1 ist. Fragen Spielen Sie den Algorithmus ruhig einmal f\u00fcr n=7 durch oder auch f\u00fcr andere n Denken Sie, dass der Algorithmus f\u00fcr jede beliebige positive nat\u00fcrliche Zahl n terminiert? Wenn ein Algorithmus f\u00fcr eine konkrete Eingabe stets ein eindeutiges Ergebnis (und zwar immer das gleiche)liefert, wie k\u00f6nnen dann Zufallszahlen berechnet werden? Success Wir haben ein Verst\u00e4ndnis \u00fcber den Algorithmus -Begriff erlangt und wissen, was Finitheit , Determiniertheit , Determinismus und * Terminierung* bedeuten. Programmablaufstrukturen \u00b6 Interessanterweise gibt es nur drei verschiedene Ablaufstrukturen in Programmen bzw. Algorithmen. Alle drei haben wir bereits verwendet. Mit Ablaufstrukturen meinen wir die Abarbeitungsreihenfolge von Anweisungen. Man sagt auch Kontrollfluss dazu. Die drei Ablaufstrukturen, die es gibt, sind: die Sequenz : die Anweisungen werden in sequenzieller Abfolge, d.h. hintereinander ausgef\u00fchrt die Iteration : die Abl\u00e4ufe werden wiederholt ausgef\u00fchrt, also in einer Schleife die Selektion : die Abl\u00e4ufe werden selektiv , d.h. unter einer bestimmten Bedingung ausgef\u00fchrt. Man nennt diese Struktur auch Verzweigung oder bedingte Alternative Wir schauen uns alle drei Kontrollstrukturen einmal genauer an. Die Sequenz \u00b6 Bei der Sequenz handelt es sich einfach um hintereinander ausgef\u00fchrte Anweisungen. Es wird stets erst die eine Anweisung vollst\u00e4ndig abgearbeitet, ehe die andere begonnen wird. Sequenz von 3 Anweisungen Anweisung1 Anweisung2 Anweisung3 Ein Beispiel (mit 2 Anweisungen) w\u00e4re: berechne 3 *n und weise das Ergebnis n zu berechne n+1 und weise das Ergebnis n zu Zur Visulaisierung von Kontrollstrukturen werden auch sogannnte Programmablaufdiagramme oder Programmablaufpl\u00e4ne verwendet. F\u00fcr eine Sequenz s\u00e4he ein solches Ablaufidagramm so aus: So ein Diagramm wird von oben nach unten gelsen. Es wird also erst Anweisung1 ausgef\u00fchrt, dann Anweisung2 und zuletzt Anweisung3 . Innerhalb einer Sequenz gilt immer single entry / single exit , d.h. keine der Anweisungen innerhalb einer Sequenz kann mehrer Ausg\u00e4nge oder mehrere Eing\u00e4nge haben. Es w\u00e4re ansonsten nicht-determinsitisch und somit ein Versto\u00df gegen unseren Algorithmusbegriff. Die Iteration \u00b6 Bei der Iteration handelt es sich um eine wiederholte Ausf\u00fchrung einer Anweisung bzw. einer Sequenz von Anweisungen. Wie oft eine Iteration ausgef\u00fchrt wird, h\u00e4ngt von einer Bedingung ab. In der Programmierung sprechen wir bei der Iteration auch von einer Schleife . Bedingungen f\u00fcr eine solche Schleife haben wir bereits kennengelernt: solange a ungleich b ist, wiederhole hier die Anweisung oder die Anweisungen, die wiederholt werden, solange die Bedingung gilt bzw. solange n ungleich 1 ist, wiederhole hier die Anweisung oder die Anweisungen, die wiederholt werden, solange die Bedingung gilt Wichtig ist, dass es auch hier eine strikte Reihenfolge der Abarbeitung der Anweisungen gibt: es wird zun\u00e4chst gepr\u00fcft, ob die Bedingung erf\u00fcllt (wahr) ist, also ob z.B. a ungleich b ist oder ob n ungleich 1 . Wenn diese Bedingung erf\u00fcllt (also wahr) ist, dann werden die Anweisung(en) innerhalb der Schleife nacheinander (sequenziell) abgearbeitet. Erst wenn alle Anweisungen innerhalb der Schleife abgearbeitet wurden, wird die Schleifenbedingung erneut gepr\u00fcft. Ist sie wieder wahr, werden die Anweisungen innerhalb der Schleife erneut abgearbeitet usw. Ist sie nicht wahr, also wenn z.B. a gleich b ist oder n gleich 1 ist , dann wird die Schleife beendet und die Anweisungen innerhalb der Schleife nicht (erneut) abgearbeitet. Das Ablaufdiagramm einer Schleife (Iteration) sieht so aus: Die eigentliche Iteration ist gr\u00fcn dargestellt. Wir kommen von einer anderen Anweisung und pr\u00fcfen die Bedingung. Ist sie wahr, wird Anweisung1 ausgef\u00fchrt. Beachte Anweisung1 muss nicht zwingend nur genau eine Anweisung sein. Bei Anweisung1 kann es sich auch um eine Sequenz von Anweisungen oder eine Selektion oder sogar selbst um eine Iteration (Schleife in der Schleife - verschachtelte Schleife) handeln! Nach jeder Ausf\u00fchrung von Anweisung1 wird die Bedingung erneut gepr\u00fcft. Ist sie (immernoch) wahr, wird Anweisung1 erneut ausgef\u00fchrt. Ist die Bedingung jedoch falsch, dann wird Anweisung1 nicht (mehr) ausgef\u00fchrt, sondern die Schleife wird verlassen und die Anweisung, die der Schleife folgt, wird ausgef\u00fchrt ( Anweisung2 ) oder das Programm ist dann zu Ende. Beachte Es kann sein, dass Anweisung1 gar nicht ausgef\u00fchrt wird, weil die Bedingung bereits bei der ersten Pr\u00fcfung falsch ist. Es ist also nicht gesagt, dass sich eine Iteration wirklich wiederholt . Es kann sein, dass Anweisung1 gar nicht oder nur genau ein Mal ausgef\u00fchrt wird (wenn die Bedingung nach der ersten Ausf\u00fchrung falsch ist). Das ist kein Problem! Ein Problem ist es jedoch, wenn die Bedingung niemals falsch wird und die Schleife unendlich oft hintereinander ausgef\u00fchrt wird. Das ist ein Versto\u00df gegen die Terminierung eines Algorithmus. In einem solchen Fall werden wir irgendwann einen Fehler bei der Programmausf\u00fchrung erhalten (aber erst zur Ausf\u00fchrungszeit, nicht bereits beim Compilieren). Wir werden uns ausf\u00fchrlich mit Schleifen auseinandersetzen, da sie logisch recht anspruchsvoll und dadurch h\u00e4ufig fehleranf\u00e4llig sein k\u00f6nnen. Die Selektion \u00b6 Bei der Selektion handelt es sich, im Gegensatz zur Iteration, um eine einmalige Ausf\u00fchrung einer (oder mehrerer) Anweisung(en). Jedoch ist diese Ausf\u00fchrung, im Gegensatz zur Sequenz, von einer Bedingung abh\u00e4ngig. Wir hatten eine solche Selektion jeweils in obigen Beispielalgorithmen. Selektion aus dem euklidischen Algorithmus: wenn a gr\u00f6\u00dfer ist als b, dann: ziehe b von a ab und weise das Ergebnis a zu andernfalls: ziehe a von b ab und weise das Ergebnis b zu Selektion aus der (3n+1)-Vermutung (dem Collatz-Problem): wenn n ungerade, dann: berechne 3 *n +1 und weise das Ergebnis n zu andernfalls: berechne n/2 und weise das Ergebnis n zu Es gibt also immer eine Bedingung (z.B. wenn a gr\u00f6\u00dfer ist als b ) und abh\u00e4ngig vom Wert dieser Bedingung (wahr oder falsch), wird entweder die eine Anweisung (z.B. ziehe b von a ab und weise das Ergebnis a zu ) oder die andere (z.B. ziehe a von b ab und weise das Ergebnis b zu ) ausgef\u00fchrt. Das Ablaufdiagramm einer Selektion sieht so aus: Beachte Anweisung1 und auch Anweisung2 m\u00fcssen nicht zwingend jeweils nur genau eine Anweisung sein. Bei beiden kann es sich auch um eine Sequenz von Anweisungen oder eine Selektion oder um eine Iteration handeln! Verschachteln von Kontrollstrukturen \u00b6 Mehr als diese drei genannten Kontrollstrukturen gibt es nicht. Aber diese Kontrollstrukturen k\u00f6nnen beliebig ineinander verschachtelt werden. \u00dcberall dort, wo eine Anweisung steht (z.B. Anweisung1 ) kann auch eine komplette Kontrollstruktur eingesetzt werden, also eine Sequenz von Anwesiungen oder eine Iteration oder eine Selektion. Die kann dann beliebig fortgef\u00fchrt werden. So entstehen komplexe Strukturen - und somit komplexe Programme. Ein (immernoch recht einfaches) Beispiel f\u00fcr eine etwas komplexere Struktur: \u00dcbung Programmablaufpl\u00e4ne Erstellen Sie sowohl f\u00fcr den euklidischen Algorithmus als auch f\u00fcr die (3n+1)-Vermutung einen Programmablaufplan! \u00dcbung Algorithmus und Programmablaufplan Ein Jahr ist ein Schaltjahr, wenn es sich durch 4 teilen l\u00e4sst. Au\u00dfer, es l\u00e4sst sich durch 100 teilen. Dann ist es doch kein Schaltjahr. Au\u00dfer, es l\u00e4sst sich durch 400 teilen. Dann ist es doch ein Schaltjahr. Beschreiben Sie diese Vorschrift als einen Algorithmus in der Form, in der auch der euklidische Algorithmus und die (3n+1)-Vermutung beschrieben wurden. Erstellen Sie dann den dazugeh\u00f6rigen Programmablaufplan. Success Wir wissen nun, dass es nur drei verschiedene Programmablaufstrukturen gibt: die Sequenz, die Iteration und die Selektion. Wir haben ein Verst\u00e4ndnis davon, was die drei Programmablaufstrukturen ausmacht, welchen Zweck sie haben und was sie voneinander unterscheidet. Wir wissen, dass sich diese Strukturen beliebig ineinander verschachteln lassen. Wenn wir ganz genau sein wollen, dann ist out vom Typ PrintStream und wir greifen auf die Objektmethode println() des PrintStream -Objektes out zu. \u21a9 Man unterscheidet bei Programmiersprachen, ob die Programme durch einen Compiler oder durch einen Interpreter \u00fcbersetzt werden. Programmiersprachen, bei denen die Programme durch einen Interpreter \u00fcbersetzt werden, werden auch Skriptsprachen genannt. In Skriptsprachen wird jede einzelne Anweisung nach und nach interpretiert , d.h. \u00fcbersetzt, dann ausgef\u00fchrt, dann die n\u00e4chste Anweisung \u00fcbersetzt, ausgef\u00fchrt usw. Java-Programme werden compiliert, d.h. sie werden als Ganzes \u00fcbersetzt und erst dann ausgef\u00fchrt. \u21a9 Genauer handelt es sich dabei um einen Interpreter . Der Java-Bytecode wird Anweisung f\u00fcr Anweisung interpretiert und ausgef\u00fchrt. \u21a9 Benannt nach Euklid von Alexandria, einem Mathematiker aus dem 3. Jahrhundert, Autor der Elemente - einem Kompendium des Wissens der Mathematik seiner Zeit. \u21a9","title":"Start"},{"location":"start/#unser-erstes-programm","text":"Bevor wir uns mit der Funktionsweise von Java auseinandersetzen, schreiben wir einfach einmal unser erstes Programm. Wir \u00f6ffnen dazu Eclipse und erstellen uns ein Klasse HelloFIW . Dazu erstellen wir uns ein Java-Projekt (falls noch nicht geschehen): Men\u00fcpunkt File --> New --> Java Project , geben dort z.B. WiSe20 ein und wenn wir gefragt, werden, ob wir eine module-info.java erstellen wollen, w\u00e4hlen wir Don't create . erstellen wir uns ein Paket: Men\u00fcpunkt File --> New --> Package und geben themen.eins.start ein. erstellen wir uns eine Klasse: Wir w\u00e4hlen das Paket themen.eins.start aus und w\u00e4hlen den Men\u00fcpunkt File --> New --> Class , geben in dem Fenster den Klassennamen HelloFIW ein und setzen bei public static void main(Strg[] args) ein H\u00e4kchen: Im Editor-Fenster von Eclipse erscheint: Schauen wir uns diesen Code zun\u00e4chst an: in Zeile 1 sehen wir, in welchem Paket sich unsere Klasse befindet. Die Anweisung package themen.eins.start; definiert, dass wir uns im Paket themen.eins.start` befinden. Mit Paketen werden wir uns in K\u00fcrze ausf\u00fchrlich auseinandersetzen. in Zeile 3 steht unsere Klassendefinition. Diese erkennen wir am Schl\u00fcsselwort class gefolgt von dem Namen der Klasse HelloFIW . Das Schl\u00fcsselwort public beschreibt, dass es sich um eine \u00f6ffentliche Klasse handelt, die von allen genutzt werden kann. Dieses Schl\u00fcsselwort ist ein sogenannter Sichtbarkeitsmodifierer (auch Zugriffsmodifizierer ). Mit Sichtbarkeitsmodifizierern werden wir uns ebenfalls noch ausf\u00fchrlich auseinandersetzen. Wichtig ist, dass die Klasse nicht nur aus dem Klassenkopf ( public class HelloFIW ) besteht, sondern aus allem, was diese Klassen enth\u00e4lt (dem Klassenrumpf). Der Klassenrumpf beginnt mit einer \u00f6ffnenden geschweiften Klammer { (Zeile 4 ) und endet mit einer schlie\u00dfenden geschweiften Klammer } (Zeile 12 ). eine Klasse kann beliebig viele Methoden enthalten. Unsere Klasse enth\u00e4lt bis jetzt eine Methode, die Methode namens main() . Methoden erkennen wir an den runden Klammern nach dem Methodennamen. Hier ist der Name main gefolgt von runden Klammern, in denen Parameter (auch Argumente genannt) definiert sein k\u00f6nnen (hier ein Parameter namens \u00e0rgs vom Typ String-Array: Strg[] args ). Wie bei den Klassen auch, bestehen Methoden aus einem Methodenkopf und einem Methodenrumpf. Wie bei den Klassen auch, beginnt der Methodenrumpf mit einer \u00f6ffnenden geschweiften Klammer (Zeile 7 ) und endet mit einer schlie\u00dfenden geschweiften Klammer (Zeile 10`). Der Methodenkopf beginnt erneut mit einem Sichtbarkeitsmodifizierer. Dieser ist hier wieder public und gibt an, dass diese Methode \u00f6ffentlich ist und von allen ausgef\u00fchrt werden kann. Danach kommt das Schl\u00fcsselwort static . Dieses Schl\u00fcsselwort besagt, dass es sich bei dieser Methode um eine Klassenmethode handelt. Das Gegenst\u00fcck zu einer Klassenmethode ist die Objektmethode . Wir werden uns mit der Unterscheidung zwischen Klassen- und Objektmnethoden ausf\u00fchrlich auseinandersetzen. Wir k\u00f6nnen uns aber schon merken (wenn \u00fcberhaupt), dass wir eine Klassenmethode aufrufen k\u00f6nnen ohne ein Objekt der Klasse erstellen zu m\u00fcssen. Danach kommt das Schl\u00fcsselwort void . Dieses Schl\u00fcsslwort gibt an, dass die Methode nichts zur\u00fcckgibt. An dieser Stelle steht der R\u00fcckgabetyp eine Methode - wenn die Methode etwas zur\u00fcckgibt. Unsere Methode gibt nichts zur\u00fcck, deshalb hier void . Wir werden uns mit Methodenr\u00fcckgaben ausf\u00fchrlich besch\u00e4ftigen. Jetzt kommt der Name der Methode, hier main . Die main() -Methode ist eine ganz besondere Methode. Sie existiert in einem Programm genau einmal und wird aufgerufen, wenn das Programm aufgerufen wird - die sogenannte Programmmethode . Wenn wir ein Programm ausf\u00fchren, wird alles das ausgef\u00fchrt, was in dem Rumpf der main() -Methode definiert ist (derzeit noch nichts). In den runden Klammern stehen Parameter (auch Argumente genannt). In unserem Fall ist ein Parameter namens args definiert. Der Datentyp dieses Parameters ist Strg[] , d.h. dass der Parameter einem Array von Zeichenketten Strings entspricht. Wir k\u00fcmmern uns um Parameter sp\u00e4ter ausf\u00fchrlich. In unserer Methode gibt es derzeit nur einen einzigen Eintrag (Zeile 8 ). Dabei handelt es sich um einen Kommentar , genauer hier um einen Zeilenkommentar . Zeilenkommentare beginnen mit einem Doppelslash // . Hinter diesen Doppelslash k\u00f6nnen Sie schreiben, was Sie m\u00f6chten - bis an das Zeilenende. Kommentare dienen Ihnen dazu, den Code verst\u00e4ndlicher zu gestalten oder Ihnen Hinweise zu geben. Hier steht der Hinweis, dass die Methode automatisch durch Eclipse erstellt wurde und Sie noch das ToDo haben, die Methode zu bef\u00fcllen. Das machen wir jetzt auch! Wir l\u00f6schen den Kommentar und f\u00fcgen nun die Anweisung System.out.println(\"HelloFIW !\"); in unseren Methodenrumpf ein. Unsere Klasse sieht nun so aus (die neuhinzugekommene Zeile ist markiert): HelloFIW.java 1 2 3 4 5 6 7 8 9 10 11 12 package themen.eins.start ; public class HelloFIW { public static void main ( String [] args ) { System . out . println ( \"Hello FIW!\" ); } } Jetzt w\u00e4hlen wir entweder im Men\u00fc Run --> Run oder klicken auf den kleinen gr\u00fcnen Kreis mit dem wei\u00dfen Pfeil in der Mitte in der Werkzeugleiste. Sie werden gefragt, ob Sie Ihr Programm zun\u00e4chst speichern wollen. Bevor Sie das best\u00e4tigen, sollten Sie ein H\u00e4kchen setzen, um zu sagen, dass Sie das gar nicht mehr gefragt werden wollen, sondern das Programm immer gespeichert werden soll, bevor Sie es ausf\u00fchren. In der Konsole erscheint: Success Herzlichen Gl\u00fcckwunsch! Sie haben Ihr erstes Java-Programm geschrieben und ausgef\u00fchrt!","title":"Unser erstes Programm"},{"location":"start/#systemoutprintlnhello-fiw","text":"Schauen wir uns System.out.println(\"Hello FIW!\"); zun\u00e4chst etwas genauer an. Wir verwenden hier eine Klasse, n\u00e4mlcih die Klasse System . Diese Klasse existiert bereits und wurde von den Java-Entwicklern f\u00fcr uns gesschrieben. Sie geh\u00f6rt zum Standardpaket von Java, existiert bereits seit der ersten Version von Java und befindet sich im Paket java.lang . Diese Klasse hat eine interssante Klassenvariable, die wir verwenden, n\u00e4mlich out . Diese Variable stellt in unserem (Betriebs-)System die Verbindung zu unserem Standardausgabeger\u00e4t bereit, in unserem Fall die Konsole. Um nun eine Ausgabe auf diese Konsole zu generieren verwenden wir die Methode println() . Wir sehen hier eine typische Notation in Java, die sogenannte Punktnotation . Mithilfe dieser Punktnotation greifen wir auf Eigenschaften von Klassen und Objekten zu. In unserem Beispiel greifen wir mit System.out auf das Standardausgabeger\u00e4t zu und mit System.out.println() auf die println() -Methode des Ausgabeger\u00e4tes 1 . Die Methode println() erzeugt also eine Ausgabe auf unsere Konsole. Jetzt m\u00fcssen wir nur noch sagen, WAS ausgegeben werden sollen. Dazu \u00fcbergeben wir dieser Methode eine Zeichenkette (einen String ). Eine Zeichenkette erkennt man an den doppelten Anf\u00fchrungsstrichen \"das ist eine Zeichekette\" . Innerhalb dieser Anf\u00fchrungsstriche k\u00f6nnen Sie schreiben, was Sie m\u00f6chten (au\u00dfer \" ). Wir haben uns f\u00fcr \"Hello FIW!\" entschieden und genau diese Zeichenkette (ohne die Anf\u00fchrungsstriche) wird ausgegeben. Die Zeichnkette, die wir ausgeben m\u00f6chten, schreiben wir in die runden Klammern der println() -Methode, also println(\"Hello FIW!\") . Bei System.out.println(\"Hello FIW!\"); handelt es sich um eine Anweisung . Eine Anweisung endet in Java immer mit einem Semikolon ; . Dieses d\u00fcrfen wir nicht vergessen, ansonsten haben wir einen Syntaxfehler und unser Programm kann nicht compiliert und nicht ausgef\u00fchrt werden. Tipp Wir m\u00fcssen System.out.println() von nun an recht h\u00e4ufig schreiben. Deshalb gibt es in Eclipse daf\u00fcr einen Shortcut. Schreiben Sie einfach syso und klicken dann die Control ( Strg )-Taste zusammen mit der Leertaste und dann Enter . Aus dem syso macht Eclipse dann automatisch System.out.println() .","title":"System.out.println(\"Hello FIW!\");"},{"location":"start/#println-vs-print","text":"In unserem ersten Programm haben wir die Methode println() verwendet, um etwas auf der Konsole auszugeben. Es gibt noch eine andere M\u00f6glichkeit f\u00fcr die Ausgabe auf die Konsole, n\u00e4mlich die Methode print() , also ohne ln . Das ln steht f\u00fcr Line und gibt an, dass nach der Ausgabe ein Zeilenumbruch erfolgt. Wir \u00e4ndern zun\u00e4chst unser Programm, indem wir die Anweisung System.out.println(\"Hello FIW!\"); kopieren und weitere 2x einf\u00fcgen. main()-Methode mit println() 1 2 3 4 5 6 7 8 9 10 11 12 13 package themen.eins.start ; public class HelloFIW { public static void main ( String [] args ) { System . out . println ( \"Hello FIW!\" ); System . out . println ( \"Hello FIW!\" ); System . out . println ( \"Hello FIW!\" ); } } Wir f\u00fchren das Programm erneut aus (gr\u00fcner Pfeil) und erhalten auf der Konsole die Ausgabe: Hello FIW! Hello FIW! Hello FIW! Das hei\u00dft, dass jede der Ausgaben mithilfe der println() -Methode in einer neuen Zeile erfolgt. Nach jeder Ausgabe erfolgt also ein Zeilenumbruch, der Ausgabecursor wird in die n\u00e4chste Zeile gesetzt. Die n\u00e4chste Ausgabe beginnt am Anfang der neuen Zeile. Wir wollen nun unser Programm \u00e4ndern und verwenden nicht mehr die println() - Methode, sondern print() : main()-Methode mit print() 1 2 3 4 5 6 7 8 9 10 11 12 13 package themen.eins.start ; public class HelloFIW { public static void main ( String [] args ) { System . out . print ( \"Hello FIW!\" ); System . out . print ( \"Hello FIW!\" ); System . out . print ( \"Hello FIW!\" ); } } Wir f\u00fchren das Programm erneut aus (gr\u00fcner Pfeil ) und erhalten auf der Konsole die Ausgabe: Hello FIW!Hello FIW!Hello FIW! Die print() -Methode gibt also nur die Zeichenkette aus, f\u00fchrt aber danach keinen Zeilenumbruch durch. Der Ausgabecursor bleibt hinter dem letzten ausgegebenen Zeichen stehen. Unsere drei Zeichenketten werden in der Konsole deshalb hintereinander ausgegeben. \u00dcbung Was m\u00fcssen Sie im Programm \u00e4ndern, damit zwischen ! und H jeweils ein Leerzeichen ist, also anstelle von Hello FIW!Hello FIW!Hello FIW! besser Hello FIW! Hello FIW! Hello FIW! ausgegeben wird? Wir \u00e4ndern nun unser Programm erneut und f\u00fcgen folgende Anweisungen hinzu: System.out.println() . Wir rufen also die println() -Methode auf, ohne eine Zeichenkette zu \u00fcbergeben, die ausgegeben werden soll. Diese Anweisung sorgt einfach daf\u00fcr, dass ein Zeilenumbruch erfolgt. Es wird also nichts ausgegeben, aber der Ausgabecursor an den Beginn der n\u00e4chsten Zeile gesetzt. main()-Methode mit print() und println() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package themen.eins.start ; public class HelloFIW { public static void main ( String [] args ) { System . out . print ( \"Hello FIW!\" ); System . out . println (); System . out . print ( \"Hello FIW!\" ); System . out . println (); System . out . print ( \"Hello FIW!\" ); System . out . println (); } } Wir f\u00fchren das Programm erneut aus (gr\u00fcner Pfeil ) und erhalten auf der Konsole die Ausgabe: Hello FIW! Hello FIW! Hello FIW! \u00dcbung Erzeugen Sie folgende Ausgabe auf der Konsole: Hello FIW! Hello FIW! Hello FIW! Eine m\u00f6gliche L\u00f6sung 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package themen.eins.start ; public class HelloFIW { public static void main ( String [] args ) { System . out . println ( \"Hello FIW!\" ); System . out . println (); System . out . println ( \"Hello FIW!\" ); System . out . println (); System . out . println ( \"Hello FIW!\" ); System . out . println (); } }","title":"println() vs. print()"},{"location":"start/#syntaxfehler","text":"Programmieren bedeutet auch, Fehler zu machen. Wichtig ist, dass Sie die Fehlerausschriften lesen und die Fehler analysieren. Haben Sie einen Syntaxfehler, so ist ein Bereich Ihres Programmcodes rot unterstrichen und an der Seite erscheint ein rotes Kreuz. Fahren Sie mit der Maus \u00fcber das rote Kreuz, um die Fehlerausschrift zu erhalten. Bei einem Syntaxfehler l\u00e4sst sich das Programm nicht compilieren. Sie k\u00f6nnen es trotzdem versuchen und erhalten die Fehlerausschrift dann auf der Konsole. Das folgende Bild zeigt einen Fehler: Es erscheint die Fehlermeldung Syntax error, insert \";\" to complete BlockStatements - ein Hinweis darauf, dass ein Semikolon fehlt - n\u00e4mlcih am Ende der Anweisung. In vielen F\u00e4llen bietet Eclipse einen sogenannten Quickfix an. Meistens k\u00f6nnen Sie diesen Vorschlag einfach annehmen (durch Mausclick auf den Vorschlag). Die folgende Abbildung zeigt einen solchen Quickfix f\u00fcr den Fehler, dass die Methode prntln() nicht existiert (es fehlt das i ). Success Wir haben unser erstes Java-Programm geschrieben und ausgef\u00fchrt! Wir haben gelernt, wie wir mithilfe der Methoden println() und print() Zeichenketten auf die Konsole ausgeben k\u00f6nnen und wir haben uns angeschaut, wie wir Fehlerausschriften lesen. Nun schauen wir uns einmal an, was im Hintergrund passiert, wenn wir das Programm ausf\u00fchren.","title":"Syntaxfehler"},{"location":"start/#kommentare","text":"In Ihren Quellcode (Ihr Programm) k\u00f6nnen Sie an allen beliebigen Stellen Kommentare schreiben. Kommentare werden vom Compiler ignoriert, d.h. Sie k\u00f6nnen dort hineinschreiben, was und wie Sie m\u00f6chten. Es gibt drei Arten von Kommentaren in Java: Zeilenkommentare : Diese beginnen mit // und danach kommt der Kommentar bis zum Zeilenende. Die neue Zeile ist dann wieder \"normaler\" Quellcode System . out . println ( \"Ausgabe1\" ); // hier ist ein Zeilenkommentar bis zum Ende der Zeile System . out . println ( \"Ausgabe2\" ); // hier ist noch ein Zeilenkommentar Blockkommentare : Diese beginnen mit /* und danach kommt der Kommentar. Er kann sich \u00fcber mehrere Zeilen erstrecken. Ein Blockkommentar endet mit */ . Nach diesem Ende ist sofort wieder \"normaler\" Quellcode. System . out . println ( \"Ausgabe1\" ); /* hier ist ein Blockkommentar er kann \u00fcber beliebig viele Zeilen gehen Er endet erst mit */ System . out . println ( \"Ausgabe2\" ); Java-Doc-Kommentare : javadoc ist ein Programm aus dem Java Development Kit (JDK) . Es wird eingesetzt, um den Code zu dokumentieren. Wir werden javadoc noch ausf\u00fchrlich behandeln. Mit javadoc kommentierte Klassen finden Sie hier . Java-Doc-Kommentare beginnen mit /** und enden mit */ . Java-Doc-Kommentare verhalten sich wie Blockkommentare. Sie erstrecken sich \u00fcber mehrere Zeilen und nach dem */ ist, wie bei Blockkommentaren, wieder \"normaler\" Quellcode. package uebungen.uebung0 ; /** * * @author jornfreiheit * * Das ist die erste Klasse, die wir geschrieben haben. * Sie erzeugt einfache Ausgaben von Zeichenketten auf * die Konsole. * */ public class MyFirstClass { // Hier die Implementierung unserer Klasse - nicht gezeigt }","title":"Kommentare"},{"location":"start/#compilieren-und-ausfuhren","text":"Wir haben nun unser erstes einfaches Programm geschrieben - in der Programmiersprache Java . Wie wir in Werkzeuge -> Java bereits bei der Installation von Java erl\u00e4utert haben, ist Java nicht nur eine Programmiersprache, sondern auch ein Programm, in dem wir Java-Programme ausf\u00fchren k\u00f6nnen - die Laufzeitumgebung von Java. Wir werden zun\u00e4chst erl\u00e4utern, was im Hintergrund passiert, wenn wir ein selbstgeschriebenes Java-Programm ausf\u00fchren. Zum besseren Verst\u00e4ndnis erzeugen wir uns zun\u00e4chst ein Verzeichnis test irgendwo auf unserem Rechner: mkdir test cd test Dieses Verzeichnis werden wir sp\u00e4ter wieder l\u00f6schen. Nun erzeugen wir uns mithilfe von vi oder vim eine Datei Test.java : vim Test.java Die Datei \u00f6ffnet sich zum Schreiben und nach Eingabe von i k\u00f6nnen wir in diese Datei Text einf\u00fcgen. Wir f\u00fcgen folgendes Programm ein (Kopieren Sie das Programm und f\u00fcgen es mit Strg+V in die Datei Test.java ein: Test.java 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Test { public static void main ( String [] args ) { System . out . print ( \"Hello \" ); for ( String s : args ) { System . out . print ( s + \" \" ); } System . out . println ( \"!\" ); } } Beenden Sie den Einf\u00fcgemodus von vim durch Dr\u00fccken der Taste Esc und speichern die Datei und beenden vim unter Eingabe von ZZ . In unserem Ordner test befindet sich nun die Datei Test.java : ls -la zeigt den Inhalt unseres Verzeichnisses test an (z.B.): total 8 drwxr-xr-x@ 3 jornfreiheit staff 96 3 Aug 14 :17 . drwxr-xr-x@ 39 jornfreiheit staff 1248 1 Nov 2018 .. -rw-r--r-- 1 jornfreiheit staff 189 3 Aug 14 :17 Test.java Wir haben eine Klasse Test in der Datei erstellt, die genauso hei\u00dft, wie die Klasse, n\u00e4mlich Test.java . Wir werden in Zukunft immer die Klasse in der gleichnamigen Datei speichern, die die Dateiendung .java hat - das macht Eclipse f\u00fcr uns automatisch.","title":"Compilieren und Ausf\u00fchren"},{"location":"start/#compilieren-der-klasse","text":"Ein Computer kann keine Datei ausf\u00fchren, die in einer Programmiersprache geschrieben wurde, egal um welche Programmiersprache es sich handelt. Computer verstehen nur Folgen von Nullen und Einsen, also so etwas wie 1000111110101011... . In eine solche Maschinensprache muss unser Programm \u00fcbersetzt werden. Das \u00dcbersetzen erfolgt durch einen Compiler 2 . Der Java-Compiler hei\u00dft javac . Wir haben den Java-Compiler zusammen mit dem Java Development Kit (JDK) installiert (siehe hier ). Mithilfe des Compilers \u00fcbersetzen wir nun unsere Klasse: javac Test . java Wenn wir uns nun erneut den Inhalt unseres Verzeichnisses ansehen ls -la dann entdecken wir, dass eine Datei Test.class erzeugt wurde. total 16 drwxr-xr-x@ 4 jornfreiheit staff 128 7 Aug 11 :02 . drwxr-xr-x@ 39 jornfreiheit staff 1248 1 Nov 2018 .. -rw-r--r-- 1 jornfreiheit staff 1001 7 Aug 11 :02 Test.class -rw-r--r-- 1 jornfreiheit staff 189 3 Aug 14 :17 Test.java Unser Java-Compiler hat unser Programm, das in Test.java enthalten ist, in sogenannten Bytecode \u00fcbersetzt. Das ist ein Zwischenschritt, den es in Java gibt. Das Programm wird nicht direkt in Maschinencode \u00fcbersetzt, sondern in Bytecode.","title":"Compilieren der Klasse"},{"location":"start/#ausfuhren-des-programms","text":"Dieser Bytecode kann nun von der Java-Laufzeitumgebung (Java Runtime Environment - JRE) ausgef\u00fchrt werden. Diese Laufzeitumgebung ist selbst ein Programm, eine sogenannte Virtuelle Maschine 3 . Die Ausf\u00fchrung unseres Programms erfolgt mithilfe der Java-Laufzeitumgebung java : java Test Beachten Sie, dass Sie nicht die Dateiendung .class f\u00fcr Ihr Programm angeben (m\u00fcssen/d\u00fcrfen). Auf unserer Konsole erscheint die Ausgabe Hello ! Diese Ausgabe erfolgt durch die Anweisung System.out.print(\"Hello \"); (in Zeile 6 ), gefolgt von der Anweisung System.out.println(\"!\"); (in Zeile 11 ). In den Zeilen 7 - 10 stehen Anweisungen, die wir noch nicht verstehen. Das macht nichts, wir kommen sp\u00e4ter darauf zur\u00fcck. Es ist jedoch so, dass wir dadurch unserem Programm Argumente \u00fcbergeben k\u00f6nnen. Betrac hten wir zum Beispiel die Anweisung ls -la . ls w\u00e4re z.B. ein \"Programm\" und -la ein Argument ( -l sorgt daf\u00fcr, dass ein langes Listenformat erscheint, also alle Angaben zu den Dateien und Ordnern erscheinen und -a sorgt daf\u00fcr, dass auch die Dateien und Ordner angezeigt werden, die mit . beginnen). Versuchen wir also einmal, umserem Programm Test ein Argument zu \u00fcbergeben (ohne - ): java Test FIW Es erscheint die Ausgabe: Hello FIW ! Wir k\u00f6nnen sogar mehrere Argumente \u00fcbergeben: java Test FIW HTW Berlin Welt Es erscheint die Ausgabe: Hello FIW HTW Berlin Welt ! Es erscheint zun\u00e4chst aufwendig, das Programm zun\u00e4chst in Bytecode zu \u00fcbersetzen und dann den Bytecode nochmal interpretieren und ausf\u00fchren zu lassen. Warum wird nicht direkt in Maschinencode \u00fcbersetzt? Die Antwort ist, dass der Java-Compiler so beriebssystemunabh\u00e4ngig arbeiten kann. Alle, egal, ob Windows-, iOS- oder Linux-Nutzerinnen k\u00f6nnen den gleichen Compiler verwenden. Die Programme k\u00f6nnen v\u00f6llig systemunabh\u00e4ngig geschrieben und von allen compiliert werden. Erst die Java-Laufzeitumgebung ist beriebssystemabh\u00e4ngig, d.h. diese wird entsprechend dem Betriebssystem installiert. Alle Java-Programme und auch ihre Compilierung sind jedoch v\u00f6llig losgel\u00f6st vom verwendeten Betriebssystem und k\u00f6nnen deshalb \u00fcberall ausgef\u00fchrt werden. Success Wir haben uns angeschaut, was passiert, wenn wir das Programm \u00fcbersetzen und ausf\u00fchren. Die \u00dcbersetzung erfolgt durch den Java-Compiler javac . Dieser erzeugt Java-Bytecode . Die Ausf\u00fchrung dieses Bytcodes \u00fcbernimmt die Java-Laufzeitumgebung java . Diese interpretiert den Bytecode und f\u00fchrt ihn sequentiell (also nacheinander, Anweisung f\u00fcr Anweisung) aus.","title":"Ausf\u00fchren des Programms"},{"location":"start/#was-ist-programmieren","text":"Ehe wir uns weiter mit Java und Programmierkonzepten besch\u00e4ftigen, wollen wir uns bewusst werden, was Programmieren \u00fcberhaupt ist. Prinzipiell l\u00f6sen wir beim Programmieren ein Problem mithilfe einer Programmiersprache. Dabei stellt sich die Frage, welche Probleme mithilfe eines Computers l\u00f6sbar sind und welche nicht. Dazu gibt es umfangreiche theoretische Untersuchungen - viele davon werden Sie in den \"Grundlegenden Konzepten der Informatik\" diskutieren. Ein wesentlicher Begriff dabei ist Algorithmus . Ein Algorithmus ist eine eindeutige Handlungsvorschrift, die aus endlich vielen einzelnen Schritten besteht und ein Problem l\u00f6st. Algorithmen sind also auch Kochrezepte oder Bauanleitungen, wenn sie denn \"eindeutig\" sind. Wir kennen alle das Problem, dass Handlungsanweisungen nicht immer eindeutig sind - man kann es manchmal so oder so machen. In der Programmierung darf eine solche Mehrdeutigkeit nat\u00fcrlich nicht vorkommen. Der Algorithmusbegriff wurde deshalb detailliert und folgende Eigenschaften m\u00fcssen f\u00fcr eine Handlungsanweisung f\u00fcr einen Computer gelten, um ein Algrithmus zu sein: Finitheit Das Verfahren muss in einem endlichen Text (Programm) eindeutig beschreibbar sein. Ausf\u00fchrbarkeit Jeder einzelne Schritt des Verfahrens muss auch tats\u00e4chlich ausf\u00fchrbar sein. Dynamische Finitheit Das Verfahren darf zu jedem Zeitpunkt nur endlich viel Speicherplatz ben\u00f6tigen. Terminierung Das Verfahren muss irgendwann enden, d.h. darf nur endlich viele Ausf\u00fchrungsschritte ben\u00f6tigen. Determiniertheit Das Verfahren muss bei denselben Voraussetzungen das gleiche Ergebnis liefern. Determinismus Die n\u00e4chste anzuwendende Regel im Verfahren ist zu jedem Zeitpunkt (in jedem Zustand) eindeutig definiert.","title":"Was ist Programmieren?"},{"location":"start/#beispiel-euklidischer-algorithmus","text":"Mit dem euklidischen Algorithmus 4 kann der gr\u00f6\u00dfte gemeinsame Teiler (ggT) zweier Zahlen berechnet werden. In seinen Elementen hat er diesen Algorithmus ungef\u00e4hr so formuliert: Euklidischer Algorithmus Wenn CD aber AB nicht misst, und man nimmt bei AB, CD abwechselnd immer das kleinere vom gr\u00f6\u00dferen weg, dann muss (schlie\u00dflich) eine Zahl \u00fcbrig bleiben, die die vorangehende misst. Hm, das ist recht schwierig zu verstehen. Euklid betrachtet die beiden Zahlen, von denen der gr\u00f6\u00dfte gemeinsame Teiler ermittelt werden soll, als Strecken ( AB und CD ). Er zieht wiederholt die kleinere der beiden Strecken von der gr\u00f6\u00dferen ab. Er wiederholt dies solange, bis die beiden Strecken gleich lang sind - genauer: er wiederholt dies solange, solange die beiden Strecken nicht gleich lang sind ( ... CD aber AB nicht misst... ). Beispiel: ggT von 24 und 40 AB: 40, CD: 24, AB gr\u00f6\u00dfer als CD \u2192 40 - 24 = 16 AB: 16, CD: 24, CD gr\u00f6\u00dfer als AB \u2192 24 - 16 = 8 AB: 16, CD: 8, AB gr\u00f6\u00dfer als CD \u2192 16 - 8 = 8 AB: 8, CD: 8, AB gleich CD \u2192 Ende \u2192 ggT ist 8 Wir versuchen, den Algorithmus in einer verst\u00e4ndlicheren und genaueren Sprache zu \u00fcberf\u00fchren, ohne bereits eine Programmiersprache zu verwenden. Wir benutzen sogenannten Pseudocode : Angenommen, die beiden Zahlen, von denen wir den ggT berechnen wollen, sind a und b : 1 2 3 4 5 6 7 solange a ungleich b ist, wiederhole wenn a gr\u00f6\u00dfer ist als b, dann: ziehe b von a ab und weise das Ergebnis a zu andernfalls: ziehe a von b ab und weise das Ergebnis b zu wenn a gleich b ist, dann: a ( oder auch b ) ist der gesuchte ggT Wichtig ist, dass das Einr\u00fccken hier eine Bedeutung hat (eine Semantik ). In Zeile 1 formulieren wir, dass sich etwas wiederholen soll, solange eine bestimmte Bedingung gilt. Das, was sich wiederholen soll, ist in den Zeilen 2 bis 5 formuliert. Zeile 1 formuliert eine Schleife und in den Zeilen 2 - 5 befindet sich der Schleifeninhalt . Die Zeilen 2 - 5 formulieren eine eigenes Konstrukt, n\u00e4mlich eine Auswahl zwischen Alternativen, abh\u00e4ngig von einer Bedingung. Die Bedingung ist, ob a gr\u00f6\u00dfer ist als b . Wenn das der Fall ist, dann wird die Alternative ziehe b von a ab und weise das Ergebnis a zu ausgef\u00fchrt. Ist jedoch a nicht gr\u00f6\u00dfer als b , dann wird die Alternative ziehe a von b ab und weise das Ergebnis b zu ausgef\u00fchrt. Ein solches Konstrukt wird Selektion (oder auch bedingte Alternative ) genannt. Nachdem entweder Zeile 3 oder Zeile 5 ausgef\u00fchrt wurde (es wird genau eins von beiden ausgef\u00fchrt), wird erneut in Zeile 1 gepr\u00fcft, ob a ungleich b ist. Wenn ja, wird die Selektion wiederholt. Wenn nicht, dann ist die Schleife beendet und Zeile 6 wird ausgef\u00fchrt. Die in Zeile 6 formulierte Bedingung wenn a gleich b ist , ist eigentlich unn\u00f6tig. Frage Warum ist die Bedingung wenn a gleich b ist in Zeile 6 unn\u00f6tig? Wir betrachten nochmals die im obigen Algorithmus betrachteten Konstrukte (wir sprechen vom Kontrollfluss von Anweisungen ): Iteration : die Schleife, die in Zeile 1 formuliert wird und die als Schleifeninhalt die Zeilen 2 - 5 hat, beschreibt einen iterativen (sich wiederholenden) Kontrollfluss . Selektion : die bedingte Alternative , die eine Bedingung pr\u00fcft (Zeile 2 ) und dann, je nachdem, ob die Bedingung richtig oder falsch ist, jeweils eine alternative Anweisung ausf\u00fchrt (entweder Zeile 3 oder Zeile 4 ), wird Selektion genannt (siehe Zeilen 2 - 5 ). Sequenz : die Anweisungen werden hintereinander ausgef\u00fchrt, erst Zeile 1 , dann Zeile 2 , dann entweder Zeile 3 oder Zeile 4 usw. Das Hintereinanderausf\u00fchren von Anweisungen wird Sequenz genannt. Schauen wir uns f\u00fcr unseren Algorithmus nochmal die Eigenschaften eines Algorithmus an: Finitheit unsere Beschreibung des Algorithmus ist endlich (siehe oben). Ausf\u00fchrbarkeit jeder einzelne Schritt kann ausgef\u00fchrt werden. Dynamische Finitheit \u00fcber den Speicherplatz k\u00f6nnen wir noch nicht viel sagen, aber wir m\u00fcssen nur einige wenige Zahlen speichern. Das sollte klappen. Terminierung Wann endet unser Algorithmus? Was muss gelten? Wissen wir, ob der Algorithmus irgendwann stoppt? Determiniertheit Es ist sicherlich nicht so leicht zu sehen, ob bei gleicher Eingabe (die Zahlen a und b ) auch stets der gleiche gr\u00f6\u00dfte gemneinsame Teiler berechnet wird. Dazu m\u00fcssten wir uns erstmal \u00fcberlegen, wie wir das pr\u00fcfen k\u00f6nnen. Determinismus Wir werden unseren Algorithmus nochmal an einem Beispiel durchspielen , um ein Gef\u00fchl daf\u00fcr zu bekommen, dass wir stets wissen, welche Anweisung als n\u00e4chstes ausgef\u00fchrt wird.","title":"Beispiel: Euklidischer Algorithmus"},{"location":"start/#beispielzahlen-fur-den-euklidischen-algorithmus","text":"Wir nehmen die Zahlen a=40 und b=24 und spielen damit unseren Algorithmus durch: Zeile 1 : a (40) ist ungleich b (24) , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : a ist gr\u00f6\u00dfer als b , also wird Zeile 3 ausgef\u00fchrt (und genau nicht Zeilen 4 und 5 ) Zeile 3 : das Ergebnis von a-b ist 16. Der neue Wert von a ist 16. Zeile 1 : wegen wiederhole (Iteration): a (16) ist ungleich b (24) , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : a ist nicht gr\u00f6\u00dfer als b , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 5 : das Ergebnis von b-a ist 8. Der neue Wert von b ist 8. Zeile 1 : wegen wiederhole (Iteration): a (16) ist ungleich b (8) , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : a ist gr\u00f6\u00dfer als b , also wird Zeile 3 ausgef\u00fchrt (und genau nicht Zeile 5 ) Zeile 3 : das Ergebnis von a-b ist 8. Der neue Wert von a ist 8. Zeile 1 : wegen wiederhole (Iteration): a (8) ist nicht ungleich b (8) , also wird der Schleifeninhalt nicht ausgef\u00fchrt Zeile 6 : a (8) ist gleich b (8) Zeile 7 : der gesuchte ggT ist 8 Ende F\u00fcr dieses Beispiel war stets eindeutig, welche Anweisung als n\u00e4chstes ausgef\u00fchrt wird. Der Algrorithmus hat auch terminiert, d.h. er wurde beendet und es sollte auch klar sein, dass das Ergebnis f\u00fcr die die Eingabe a=40 und b=24 stets 8 ist. Fragen Was \u00e4ndert sich, wenn am Anfang a=24 und b=40 sind? Was \u00e4ndert sich, wenn am Anfang a=-40 und b=24 sind? Was \u00e4ndert sich, wenn am Anfang a=-40 und b=-24 sind? Was \u00e4ndert sich, wenn am Anfang a=24 und b=24 sind?","title":"Beispielzahlen f\u00fcr den euklidischen Algorithmus"},{"location":"start/#beispiel-3n1-vermutung-collatz-problem","text":"Wir betrachten noch einen weiteren Algorithmus: Als Eingabe bekommen wir eine positive nat\u00fcrliche Zahl, z.B. 5 . Der Algorithmus berechnet eine Folge von Zahlen und zwar nach folgender Vorschrift: ist die Zahl ungerade, dann wird ihr Nachfolger dadurch berechnet, dass die Zahl mit 3 multipliziert und dann 1 addiert wird. Ist die Zahl gerade, dann wird ihr Nachfolger dadurch berechnet, dass die Zahl durch 2 geteilt wird. Der Algorithmus stoppt, wenn der Nachfolger 1 ist. Angenommen, die eingegebene positive nat\u00fcrliche Zahl ist n : 1 2 3 4 5 solange n ungleich 1 ist, wiederhole wenn n ungerade, dann: berechne 3 *n +1 und weise das Ergebnis n zu andernfalls: berechne n/2 und weise das Ergebnis n zu Wir begeben uns also in eine Schleife und berechnen so lange einen Nachfolger f\u00fcr die Zahl bis der NAchfolger 1 ist. Betrachten wir den Algorithmus f\u00fcr die EIngabe von n=5 : Zeile 1 : n (5) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist ungerade , also wird Zeile 3 ausgef\u00fchrt (und genau nicht Zeilen 4 und 5 ) Zeile 3 : das Ergebnis von 3*5+1 ist 16 . Der neue Wert von n ist 16. Zeile 1 : wegen wiederhole (Iteration): n (16) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist nicht ungerade , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 3 : das Ergebnis von 16/2 ist 8 n. Der neue Wert von n ist 8. Zeile 1 : wegen wiederhole (Iteration): n (8) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist nicht ungerade , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 3 : das Ergebnis von 8/2 ist 4 . Der neue Wert von n ist 4. Zeile 1 : wegen wiederhole (Iteration): n (4) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist nicht ungerade , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 3 : das Ergebnis von 4/2 ist 2 . Der neue Wert von n ist 2. Zeile 1 : wegen wiederhole (Iteration): n (2) ist ungleich 1 , also wird der Schleifeninhalt ausgef\u00fchrt Zeile 2 : n ist nicht ungerade , also wird Zeile 5 ausgef\u00fchrt (und genau nicht Zeile 3 ) Zeile 3 : das Ergebnis von 2/2 ist 1 . Der neue Wert von n ist 1. Zeile 1 : wegen wiederhole (Iteration): n (1) ist nicht ungleich 1 , also wird der Schleifeninhalt nicht ausgef\u00fchrt Ende Auch f\u00fcr dieses Beispiel war erneut stets eindeutig, welche Anweisung als n\u00e4chstes ausgef\u00fchrt wird. Der Algrorithmus hat auch terminiert, d.h. er wurde beendet und es sollte auch klar sein, dass das Ergebnis f\u00fcr die die Eingabe n=5 stets 1 ist. Fragen Spielen Sie den Algorithmus ruhig einmal f\u00fcr n=7 durch oder auch f\u00fcr andere n Denken Sie, dass der Algorithmus f\u00fcr jede beliebige positive nat\u00fcrliche Zahl n terminiert? Wenn ein Algorithmus f\u00fcr eine konkrete Eingabe stets ein eindeutiges Ergebnis (und zwar immer das gleiche)liefert, wie k\u00f6nnen dann Zufallszahlen berechnet werden? Success Wir haben ein Verst\u00e4ndnis \u00fcber den Algorithmus -Begriff erlangt und wissen, was Finitheit , Determiniertheit , Determinismus und * Terminierung* bedeuten.","title":"Beispiel: (3n+1)-Vermutung (Collatz-Problem)"},{"location":"start/#programmablaufstrukturen","text":"Interessanterweise gibt es nur drei verschiedene Ablaufstrukturen in Programmen bzw. Algorithmen. Alle drei haben wir bereits verwendet. Mit Ablaufstrukturen meinen wir die Abarbeitungsreihenfolge von Anweisungen. Man sagt auch Kontrollfluss dazu. Die drei Ablaufstrukturen, die es gibt, sind: die Sequenz : die Anweisungen werden in sequenzieller Abfolge, d.h. hintereinander ausgef\u00fchrt die Iteration : die Abl\u00e4ufe werden wiederholt ausgef\u00fchrt, also in einer Schleife die Selektion : die Abl\u00e4ufe werden selektiv , d.h. unter einer bestimmten Bedingung ausgef\u00fchrt. Man nennt diese Struktur auch Verzweigung oder bedingte Alternative Wir schauen uns alle drei Kontrollstrukturen einmal genauer an.","title":"Programmablaufstrukturen"},{"location":"start/#die-sequenz","text":"Bei der Sequenz handelt es sich einfach um hintereinander ausgef\u00fchrte Anweisungen. Es wird stets erst die eine Anweisung vollst\u00e4ndig abgearbeitet, ehe die andere begonnen wird. Sequenz von 3 Anweisungen Anweisung1 Anweisung2 Anweisung3 Ein Beispiel (mit 2 Anweisungen) w\u00e4re: berechne 3 *n und weise das Ergebnis n zu berechne n+1 und weise das Ergebnis n zu Zur Visulaisierung von Kontrollstrukturen werden auch sogannnte Programmablaufdiagramme oder Programmablaufpl\u00e4ne verwendet. F\u00fcr eine Sequenz s\u00e4he ein solches Ablaufidagramm so aus: So ein Diagramm wird von oben nach unten gelsen. Es wird also erst Anweisung1 ausgef\u00fchrt, dann Anweisung2 und zuletzt Anweisung3 . Innerhalb einer Sequenz gilt immer single entry / single exit , d.h. keine der Anweisungen innerhalb einer Sequenz kann mehrer Ausg\u00e4nge oder mehrere Eing\u00e4nge haben. Es w\u00e4re ansonsten nicht-determinsitisch und somit ein Versto\u00df gegen unseren Algorithmusbegriff.","title":"Die Sequenz"},{"location":"start/#die-iteration","text":"Bei der Iteration handelt es sich um eine wiederholte Ausf\u00fchrung einer Anweisung bzw. einer Sequenz von Anweisungen. Wie oft eine Iteration ausgef\u00fchrt wird, h\u00e4ngt von einer Bedingung ab. In der Programmierung sprechen wir bei der Iteration auch von einer Schleife . Bedingungen f\u00fcr eine solche Schleife haben wir bereits kennengelernt: solange a ungleich b ist, wiederhole hier die Anweisung oder die Anweisungen, die wiederholt werden, solange die Bedingung gilt bzw. solange n ungleich 1 ist, wiederhole hier die Anweisung oder die Anweisungen, die wiederholt werden, solange die Bedingung gilt Wichtig ist, dass es auch hier eine strikte Reihenfolge der Abarbeitung der Anweisungen gibt: es wird zun\u00e4chst gepr\u00fcft, ob die Bedingung erf\u00fcllt (wahr) ist, also ob z.B. a ungleich b ist oder ob n ungleich 1 . Wenn diese Bedingung erf\u00fcllt (also wahr) ist, dann werden die Anweisung(en) innerhalb der Schleife nacheinander (sequenziell) abgearbeitet. Erst wenn alle Anweisungen innerhalb der Schleife abgearbeitet wurden, wird die Schleifenbedingung erneut gepr\u00fcft. Ist sie wieder wahr, werden die Anweisungen innerhalb der Schleife erneut abgearbeitet usw. Ist sie nicht wahr, also wenn z.B. a gleich b ist oder n gleich 1 ist , dann wird die Schleife beendet und die Anweisungen innerhalb der Schleife nicht (erneut) abgearbeitet. Das Ablaufdiagramm einer Schleife (Iteration) sieht so aus: Die eigentliche Iteration ist gr\u00fcn dargestellt. Wir kommen von einer anderen Anweisung und pr\u00fcfen die Bedingung. Ist sie wahr, wird Anweisung1 ausgef\u00fchrt. Beachte Anweisung1 muss nicht zwingend nur genau eine Anweisung sein. Bei Anweisung1 kann es sich auch um eine Sequenz von Anweisungen oder eine Selektion oder sogar selbst um eine Iteration (Schleife in der Schleife - verschachtelte Schleife) handeln! Nach jeder Ausf\u00fchrung von Anweisung1 wird die Bedingung erneut gepr\u00fcft. Ist sie (immernoch) wahr, wird Anweisung1 erneut ausgef\u00fchrt. Ist die Bedingung jedoch falsch, dann wird Anweisung1 nicht (mehr) ausgef\u00fchrt, sondern die Schleife wird verlassen und die Anweisung, die der Schleife folgt, wird ausgef\u00fchrt ( Anweisung2 ) oder das Programm ist dann zu Ende. Beachte Es kann sein, dass Anweisung1 gar nicht ausgef\u00fchrt wird, weil die Bedingung bereits bei der ersten Pr\u00fcfung falsch ist. Es ist also nicht gesagt, dass sich eine Iteration wirklich wiederholt . Es kann sein, dass Anweisung1 gar nicht oder nur genau ein Mal ausgef\u00fchrt wird (wenn die Bedingung nach der ersten Ausf\u00fchrung falsch ist). Das ist kein Problem! Ein Problem ist es jedoch, wenn die Bedingung niemals falsch wird und die Schleife unendlich oft hintereinander ausgef\u00fchrt wird. Das ist ein Versto\u00df gegen die Terminierung eines Algorithmus. In einem solchen Fall werden wir irgendwann einen Fehler bei der Programmausf\u00fchrung erhalten (aber erst zur Ausf\u00fchrungszeit, nicht bereits beim Compilieren). Wir werden uns ausf\u00fchrlich mit Schleifen auseinandersetzen, da sie logisch recht anspruchsvoll und dadurch h\u00e4ufig fehleranf\u00e4llig sein k\u00f6nnen.","title":"Die Iteration"},{"location":"start/#die-selektion","text":"Bei der Selektion handelt es sich, im Gegensatz zur Iteration, um eine einmalige Ausf\u00fchrung einer (oder mehrerer) Anweisung(en). Jedoch ist diese Ausf\u00fchrung, im Gegensatz zur Sequenz, von einer Bedingung abh\u00e4ngig. Wir hatten eine solche Selektion jeweils in obigen Beispielalgorithmen. Selektion aus dem euklidischen Algorithmus: wenn a gr\u00f6\u00dfer ist als b, dann: ziehe b von a ab und weise das Ergebnis a zu andernfalls: ziehe a von b ab und weise das Ergebnis b zu Selektion aus der (3n+1)-Vermutung (dem Collatz-Problem): wenn n ungerade, dann: berechne 3 *n +1 und weise das Ergebnis n zu andernfalls: berechne n/2 und weise das Ergebnis n zu Es gibt also immer eine Bedingung (z.B. wenn a gr\u00f6\u00dfer ist als b ) und abh\u00e4ngig vom Wert dieser Bedingung (wahr oder falsch), wird entweder die eine Anweisung (z.B. ziehe b von a ab und weise das Ergebnis a zu ) oder die andere (z.B. ziehe a von b ab und weise das Ergebnis b zu ) ausgef\u00fchrt. Das Ablaufdiagramm einer Selektion sieht so aus: Beachte Anweisung1 und auch Anweisung2 m\u00fcssen nicht zwingend jeweils nur genau eine Anweisung sein. Bei beiden kann es sich auch um eine Sequenz von Anweisungen oder eine Selektion oder um eine Iteration handeln!","title":"Die Selektion"},{"location":"start/#verschachteln-von-kontrollstrukturen","text":"Mehr als diese drei genannten Kontrollstrukturen gibt es nicht. Aber diese Kontrollstrukturen k\u00f6nnen beliebig ineinander verschachtelt werden. \u00dcberall dort, wo eine Anweisung steht (z.B. Anweisung1 ) kann auch eine komplette Kontrollstruktur eingesetzt werden, also eine Sequenz von Anwesiungen oder eine Iteration oder eine Selektion. Die kann dann beliebig fortgef\u00fchrt werden. So entstehen komplexe Strukturen - und somit komplexe Programme. Ein (immernoch recht einfaches) Beispiel f\u00fcr eine etwas komplexere Struktur: \u00dcbung Programmablaufpl\u00e4ne Erstellen Sie sowohl f\u00fcr den euklidischen Algorithmus als auch f\u00fcr die (3n+1)-Vermutung einen Programmablaufplan! \u00dcbung Algorithmus und Programmablaufplan Ein Jahr ist ein Schaltjahr, wenn es sich durch 4 teilen l\u00e4sst. Au\u00dfer, es l\u00e4sst sich durch 100 teilen. Dann ist es doch kein Schaltjahr. Au\u00dfer, es l\u00e4sst sich durch 400 teilen. Dann ist es doch ein Schaltjahr. Beschreiben Sie diese Vorschrift als einen Algorithmus in der Form, in der auch der euklidische Algorithmus und die (3n+1)-Vermutung beschrieben wurden. Erstellen Sie dann den dazugeh\u00f6rigen Programmablaufplan. Success Wir wissen nun, dass es nur drei verschiedene Programmablaufstrukturen gibt: die Sequenz, die Iteration und die Selektion. Wir haben ein Verst\u00e4ndnis davon, was die drei Programmablaufstrukturen ausmacht, welchen Zweck sie haben und was sie voneinander unterscheidet. Wir wissen, dass sich diese Strukturen beliebig ineinander verschachteln lassen. Wenn wir ganz genau sein wollen, dann ist out vom Typ PrintStream und wir greifen auf die Objektmethode println() des PrintStream -Objektes out zu. \u21a9 Man unterscheidet bei Programmiersprachen, ob die Programme durch einen Compiler oder durch einen Interpreter \u00fcbersetzt werden. Programmiersprachen, bei denen die Programme durch einen Interpreter \u00fcbersetzt werden, werden auch Skriptsprachen genannt. In Skriptsprachen wird jede einzelne Anweisung nach und nach interpretiert , d.h. \u00fcbersetzt, dann ausgef\u00fchrt, dann die n\u00e4chste Anweisung \u00fcbersetzt, ausgef\u00fchrt usw. Java-Programme werden compiliert, d.h. sie werden als Ganzes \u00fcbersetzt und erst dann ausgef\u00fchrt. \u21a9 Genauer handelt es sich dabei um einen Interpreter . Der Java-Bytecode wird Anweisung f\u00fcr Anweisung interpretiert und ausgef\u00fchrt. \u21a9 Benannt nach Euklid von Alexandria, einem Mathematiker aus dem 3. Jahrhundert, Autor der Elemente - einem Kompendium des Wissens der Mathematik seiner Zeit. \u21a9","title":"Verschachteln von Kontrollstrukturen"},{"location":"tools/","text":"Werkzeuge \u00b6 Literaturempfehlungen \u00b6 Joachim Goll, Cornelia Heinisch: \"Java als erste Programmiersprache. Ein professioneller Einstieg in die Objektorientierung mit Java\" , Springer Vieweg Sebastian D\u00f6rn: \"Java lernen in abgeschlossenen Lerneinheiten\" , Springer Vieweg Dietmar Ratz, Jens Scheffler, Detlef Seese, Jan Wiesenberger: *\"Grundkurs Programmieren in Java x\", Hanser Verlag Kathy Sierra, Bert Bates: \"Java von Kopf bis Fu\u00df\" , O'Reilly Verlag Joshua Bloch: \"Effective Java. Best practices for the Java platform\" , Pearson Education Inc. Robin C. Martin: \"Clean Code: A Handbook of Agile Software Craftmanship\" , Prentice Hall und alle B\u00fccher f\u00fcr Einsteigerinnen, die Sie ansprechen... Java \u00b6 Wir verwenden die Programmiersprache Java , um die Programmierkonzepte, die wir lernen und anwenden wollen, zu implementieren. Java besteht aus 2 Teilen: der Java Run Time Environment (Java RTE) (Java-Laufzeitumgebung) dem Java Development Kit (JDK) (die Java-Entwicklungsumgebung) Die Java-Laufzeitumgebung ist \u00fcblicherweise bereits auf allen Rechnern installiert. Sie ist selbst ein Programm. Innerhalb dieses Programms werden Java-Programme ausgef\u00fchrt. Das JDK m\u00fcssen Sie installieren. Verwenden Sie dazu diesen Link und gehen wie f\u00fcr Ihr Betriebssystem angegeben vor (pr\u00fcfen Sie aber zun\u00e4chst, ob Sie nicht eventuell bereits Beides haben - java -version und javac -version - siehe folgend). Testen Sie am besten auf Ihrer Konsole (Terminal), ob Ihr Java korrekt funktioniert. Zum Testen Ihrer Laufzeitumgebung geben Sie dazu java -version ein. Es sollte soetwas erscheinen, wie (Versionsnummern bei Ihnen sicherlich schon h\u00f6her): java version \"12.0.1\" 2019 -04-16 Java ( TM ) SE Runtime Environment ( build 12 .0.1+12 ) Java HotSpot ( TM ) 64 -Bit Server VM ( build 12 .0.1+12, mixed mode, sharing ) Somit wissen Sie, dass die Laufzeitumgebung funktioniert. Zum Testen des JDK rufen wir am besten den Compiler ( javac ) auf: javac -version Es sollte soetwas erscheinen, wie (Versionsnummern bei Ihnen sicherlich schon h\u00f6her): javac 12 .0.1 Success Sie haben nun die Java-Laufzeitumgebung installiert, in der unsere Java-Programme ausgef\u00fchrt werden und Sie haben das Java Development Kit installiert. Teil des JDK ist z.B. der Compiler , der unsere Java-Programme in Byte-Code \u00fcbersetzt. Dieser Bytecode wird in unserer Java-Laufzeitumgebung ausgef\u00fchrt. IDE \u00b6 Um unsere Programme \"zu schreiben\", verwenden wir eine sogenannte Integrated Development Environment (IDE) , eine integrierte Entwicklungsumgebung, die uns beim Programmieren unterst\u00fctzt. Wir k\u00f6nnten unsere Programme auch mit einfachen Texteditoren schreiben, aber eine IDE unterst\u00fctzt uns, indem der Programmcode geeignet hervorgehoben wird ( Syntx-Highlighting ) und uns Vorschl\u00e4ge f\u00fcr die Verwendung von Methoden und Variablen gemacht werden ( Intelligent Code Completion ). Eclipse \u00b6 Sie sind in der Wahl Ihrer IDE frei. Wir verwenden Eclipse . Eclipse ist in Java geschrieben und Open-Source. Den Download-Link f\u00fcr Eclipse finden Sie hier . Es gibt verschiedene Versionen von Eclipse, wir verwenden die Eclipse IDE for Java Developers . Installieren Sie Eclipse am besten in ihren Applications oder Programme Ordner. Starten Sie Eclipse durch Doppelklick auf das Programmsymbol. Erstellen Sie einen Workspace (Arbeitsbereich) in einem gewu\u0308nschten Ordner (z. B. Programmieren) im Dateisystem. Achten Sie darauf, dass Sie Schreibrechte in diesem Ordner besitzen. Anlegen eines Projektordners: Auswahl im Men\u00fc File-->New-->Java Project . Eingabe des Project name: Name des Projektes (z.B. WiSe20 oder Uebung1 oder Aufgabe2 ). Wenn Sie gefragt werden, ob Sie ein module-info.java erstellen wollen, w\u00e4hlen Sie Don't create . Klicken auf den Button Finish . Erstellen eines neuen Packages (Paketes): \u00d6ffnen der Projektmappe im Package Explorer . Auswahl des Ordners src mit der rechten Maustaste. Auswahl des Men\u00fcpunktes New --> Package . Geben Sie einen Paketnamen ein (Paketnamen werden kleingeschrieben), z.B. themen.start . Erstellen einer neuen Klasse: \u00d6ffnen der Projektmappe im Package Explorer. Auswahl des Paketes (z.B. themen.start ) mit der rechten Maustaste. Auswahl des Menu\u0308punktes New --> Class . Eingabe eines beliebigen Namens, der gleichzeitig der Klassen- und Dateiname ist (z.B. HelloFIW ). Klassennamen werden immer gro\u00df geschrieben. Setzen des H\u00e4kchens bei public static void main() . Klicken auf den Button Finish . Die folgende Abbildung gibt einen \u00dcberblick \u00fcber die Bedeutung der einzelnen Fenster in Eclipse: IntelliJ \u00b6 Diejenigen von Ihnen, die nicht Eclipse verwenden, werden sich stattdessen wahrscheinlich f\u00fcr IntelliJ entscheiden. Das ist v\u00f6llig in Ordnung. IntelliJ ist von JetBrains, einem tschechischen Unternehmen, und derzeit die wohl modernste IDE auf dem Markt, nicht nur f\u00fcr Java- sondern auch f\u00fcr Web-Entwicklungen. IntelliJ ist nicht Open-Source und ist kostenpflichtig. Mit einer Hochschullizenz erhalten Sie jedoch kostenlosen Zugriff auf alle Enterprise-Versionen. Sie m\u00fcssen sich dazu bei JetBrains mit Ihrer HTW-Adresse registrieren. Visual Studio Code \u00b6 Wer gerne mit Microsoft-Produkten arbeitet, kann auch gerne Visual Studio Code arbeiten. Das ist auch eine sehr gute IDE und ebenfalls nicht nur zur Nutzung f\u00fcr die Java-Entwicklung, sondern auch f\u00fcr Web- und App-Entwicklungen geeignet. Weitere n\u00fctzliche Werkzeuge \u00b6 Windows: gitBash \u00b6 Das Terminal ( cmd ) in Windows ist nicht so gut. Installieren Sie sich lieber die GitBash f\u00fcr Windows . Unter Downloads \u00f6ffnet sich das GitHub-Repository f\u00fcr Git. Aktuell w\u00e4hlen Sie dort Git-2.29.2-64-bit.exe und folgen dann den Installationsanweisungen. Online-Kurse \u00b6 SoloLearn https://www.sololearn.com/Course/Java/ JetBrains Academy https://hyperskill.org/tracks/1","title":"Werkzeuge"},{"location":"tools/#werkzeuge","text":"","title":"Werkzeuge"},{"location":"tools/#literaturempfehlungen","text":"Joachim Goll, Cornelia Heinisch: \"Java als erste Programmiersprache. Ein professioneller Einstieg in die Objektorientierung mit Java\" , Springer Vieweg Sebastian D\u00f6rn: \"Java lernen in abgeschlossenen Lerneinheiten\" , Springer Vieweg Dietmar Ratz, Jens Scheffler, Detlef Seese, Jan Wiesenberger: *\"Grundkurs Programmieren in Java x\", Hanser Verlag Kathy Sierra, Bert Bates: \"Java von Kopf bis Fu\u00df\" , O'Reilly Verlag Joshua Bloch: \"Effective Java. Best practices for the Java platform\" , Pearson Education Inc. Robin C. Martin: \"Clean Code: A Handbook of Agile Software Craftmanship\" , Prentice Hall und alle B\u00fccher f\u00fcr Einsteigerinnen, die Sie ansprechen...","title":"Literaturempfehlungen"},{"location":"tools/#java","text":"Wir verwenden die Programmiersprache Java , um die Programmierkonzepte, die wir lernen und anwenden wollen, zu implementieren. Java besteht aus 2 Teilen: der Java Run Time Environment (Java RTE) (Java-Laufzeitumgebung) dem Java Development Kit (JDK) (die Java-Entwicklungsumgebung) Die Java-Laufzeitumgebung ist \u00fcblicherweise bereits auf allen Rechnern installiert. Sie ist selbst ein Programm. Innerhalb dieses Programms werden Java-Programme ausgef\u00fchrt. Das JDK m\u00fcssen Sie installieren. Verwenden Sie dazu diesen Link und gehen wie f\u00fcr Ihr Betriebssystem angegeben vor (pr\u00fcfen Sie aber zun\u00e4chst, ob Sie nicht eventuell bereits Beides haben - java -version und javac -version - siehe folgend). Testen Sie am besten auf Ihrer Konsole (Terminal), ob Ihr Java korrekt funktioniert. Zum Testen Ihrer Laufzeitumgebung geben Sie dazu java -version ein. Es sollte soetwas erscheinen, wie (Versionsnummern bei Ihnen sicherlich schon h\u00f6her): java version \"12.0.1\" 2019 -04-16 Java ( TM ) SE Runtime Environment ( build 12 .0.1+12 ) Java HotSpot ( TM ) 64 -Bit Server VM ( build 12 .0.1+12, mixed mode, sharing ) Somit wissen Sie, dass die Laufzeitumgebung funktioniert. Zum Testen des JDK rufen wir am besten den Compiler ( javac ) auf: javac -version Es sollte soetwas erscheinen, wie (Versionsnummern bei Ihnen sicherlich schon h\u00f6her): javac 12 .0.1 Success Sie haben nun die Java-Laufzeitumgebung installiert, in der unsere Java-Programme ausgef\u00fchrt werden und Sie haben das Java Development Kit installiert. Teil des JDK ist z.B. der Compiler , der unsere Java-Programme in Byte-Code \u00fcbersetzt. Dieser Bytecode wird in unserer Java-Laufzeitumgebung ausgef\u00fchrt.","title":"Java"},{"location":"tools/#ide","text":"Um unsere Programme \"zu schreiben\", verwenden wir eine sogenannte Integrated Development Environment (IDE) , eine integrierte Entwicklungsumgebung, die uns beim Programmieren unterst\u00fctzt. Wir k\u00f6nnten unsere Programme auch mit einfachen Texteditoren schreiben, aber eine IDE unterst\u00fctzt uns, indem der Programmcode geeignet hervorgehoben wird ( Syntx-Highlighting ) und uns Vorschl\u00e4ge f\u00fcr die Verwendung von Methoden und Variablen gemacht werden ( Intelligent Code Completion ).","title":"IDE"},{"location":"tools/#eclipse","text":"Sie sind in der Wahl Ihrer IDE frei. Wir verwenden Eclipse . Eclipse ist in Java geschrieben und Open-Source. Den Download-Link f\u00fcr Eclipse finden Sie hier . Es gibt verschiedene Versionen von Eclipse, wir verwenden die Eclipse IDE for Java Developers . Installieren Sie Eclipse am besten in ihren Applications oder Programme Ordner. Starten Sie Eclipse durch Doppelklick auf das Programmsymbol. Erstellen Sie einen Workspace (Arbeitsbereich) in einem gewu\u0308nschten Ordner (z. B. Programmieren) im Dateisystem. Achten Sie darauf, dass Sie Schreibrechte in diesem Ordner besitzen. Anlegen eines Projektordners: Auswahl im Men\u00fc File-->New-->Java Project . Eingabe des Project name: Name des Projektes (z.B. WiSe20 oder Uebung1 oder Aufgabe2 ). Wenn Sie gefragt werden, ob Sie ein module-info.java erstellen wollen, w\u00e4hlen Sie Don't create . Klicken auf den Button Finish . Erstellen eines neuen Packages (Paketes): \u00d6ffnen der Projektmappe im Package Explorer . Auswahl des Ordners src mit der rechten Maustaste. Auswahl des Men\u00fcpunktes New --> Package . Geben Sie einen Paketnamen ein (Paketnamen werden kleingeschrieben), z.B. themen.start . Erstellen einer neuen Klasse: \u00d6ffnen der Projektmappe im Package Explorer. Auswahl des Paketes (z.B. themen.start ) mit der rechten Maustaste. Auswahl des Menu\u0308punktes New --> Class . Eingabe eines beliebigen Namens, der gleichzeitig der Klassen- und Dateiname ist (z.B. HelloFIW ). Klassennamen werden immer gro\u00df geschrieben. Setzen des H\u00e4kchens bei public static void main() . Klicken auf den Button Finish . Die folgende Abbildung gibt einen \u00dcberblick \u00fcber die Bedeutung der einzelnen Fenster in Eclipse:","title":"Eclipse"},{"location":"tools/#intellij","text":"Diejenigen von Ihnen, die nicht Eclipse verwenden, werden sich stattdessen wahrscheinlich f\u00fcr IntelliJ entscheiden. Das ist v\u00f6llig in Ordnung. IntelliJ ist von JetBrains, einem tschechischen Unternehmen, und derzeit die wohl modernste IDE auf dem Markt, nicht nur f\u00fcr Java- sondern auch f\u00fcr Web-Entwicklungen. IntelliJ ist nicht Open-Source und ist kostenpflichtig. Mit einer Hochschullizenz erhalten Sie jedoch kostenlosen Zugriff auf alle Enterprise-Versionen. Sie m\u00fcssen sich dazu bei JetBrains mit Ihrer HTW-Adresse registrieren.","title":"IntelliJ"},{"location":"tools/#visual-studio-code","text":"Wer gerne mit Microsoft-Produkten arbeitet, kann auch gerne Visual Studio Code arbeiten. Das ist auch eine sehr gute IDE und ebenfalls nicht nur zur Nutzung f\u00fcr die Java-Entwicklung, sondern auch f\u00fcr Web- und App-Entwicklungen geeignet.","title":"Visual Studio Code"},{"location":"tools/#weitere-nutzliche-werkzeuge","text":"","title":"Weitere n\u00fctzliche Werkzeuge"},{"location":"tools/#windows-gitbash","text":"Das Terminal ( cmd ) in Windows ist nicht so gut. Installieren Sie sich lieber die GitBash f\u00fcr Windows . Unter Downloads \u00f6ffnet sich das GitHub-Repository f\u00fcr Git. Aktuell w\u00e4hlen Sie dort Git-2.29.2-64-bit.exe und folgen dann den Installationsanweisungen.","title":"Windows: gitBash"},{"location":"tools/#online-kurse","text":"SoloLearn https://www.sololearn.com/Course/Java/ JetBrains Academy https://hyperskill.org/tracks/1","title":"Online-Kurse"},{"location":"uebungen/","text":"\u00dcbungen \u00b6 \u00dcbungsbl\u00e4tter (wochenweise) \u00b6 \u00dcbung 0 Installieren Sie sich - falls noch nicht geschehen - eine Java-Entwicklungsumgebung (siehe Java ). Installieren Sie sich die IDE Ihrer Wahl (siehe IDE ). In den Vorlesungen und \u00dcbungen (Videos) verwende ich Eclipse und beschreibe die Schritte auch f\u00fcr Eclipse. Starten Sie Eclipse durch Doppelklick auf das Programmsymbol. Erstellen Sie einen Workspace (Arbeitsbereich) in einem gewu\u0308nschten Ordner (z. B. Programmieren) im Dateisystem. Achten Sie darauf, dass Sie Schreibrechte in diesem Ordner besitzen. Anlegen eines Projektordners: Auswahl im Men\u00fc File-->New-->Java Project . Eingabe des Project name: Name des Projektes (z.B. WiSe20 ). Wenn Sie gefragt werden, ob Sie ein module-info.java erstellen wollen, w\u00e4hlen Sie Don't create . Klicken auf den Button Finish . Erstellen eines neuen Packages (Paketes): \u00d6ffnen der Projektmappe im Package Explorer . Auswahl des Ordners src mit der rechten Maustaste. Auswahl des Men\u00fcpunktes New --> Package . Geben Sie folgenden Paketnamen ein (Paketnamen werden kleingeschrieben) uebungen.uebung0 (Achten Sie auf den Punkt und dass Sie alles zusammen schreiben). Erstellen einer neuen Klasse: \u00d6ffnen der Projektmappe im Package Explorer. Auswahl des Paketes ( uebungen.uebung0 ) mit der rechten Maustaste. Auswahl des Menu\u0308punktes New --> Class . Eingabe des Namens, der gleichzeitig der Klassen- und Dateiname ist: Uebung0 . Klassennamen werden immer gro\u00df geschrieben. Setzen des H\u00e4kchens bei public static void main() . (Sollten Sie vergessen haben, das H\u00e4kchen zu setzen, dann ist die Klasse, nachdem Sie Finish gedr\u00fcckt haben, leer. Setzen Sie dann den Cursor zwischen die beiden geschweiften Klammern { } , geben dann main ein und dr\u00fccken die Ctrl + Leer -Tasten und anschlie\u00dfend Enter . Dann erscheint die main() -Methode) Klicken auf den Button Finish . In die main() -Methode (zwischen die geschweiften Klammern { und } geben Sie ein: System.out.println(\"Uebung 0\")); . Dr\u00fccken Sie dann entweder auf den -Button oder w\u00e4hlen Sie aus dem Men\u00fc Run --> Run oder dr\u00fccken Sie shift + command + f11 . In der Console in Ihrer IDE (in Eclipse unten) erscheint Uebung 0 . Uebung1.java package uebungen.uebung0 ; public class Uebung0 { public static void main ( String [] args ) { System . out . println ( \"Uebung 0\" ); } } Success Fertig! Ihre Entwicklungsumgebung ist bereit! Wir k\u00f6nnen loslegen. \u00dcbung 1 Erstellen Sie ein package uebungen.uebung1 . Erstellen Sie in diesem package eine Klasse Uebung1 mit main() -Methode. Deklarieren und initialisieren Sie in der main() -Methode jeweils eine Variable mit dem Datentyp int , long , char , byte , short , float , double , boolean und String . Geben Sie alle Werte einzeln durch Aufruf der println() -Methode aus. Erzeugen Sie dabei folgende Ausgabe (Werte nur Beispiele): Wert vom Typ int : 123 Wert vom Typ long : 456789 Wert vom Typ char : a Wert vom Typ byte : 127 Wert vom Typ short : 32767 Wert vom Typ float : 4 .23 Wert vom Typ double : 6 .98 Wert vom Typ boolean : true Wert vom Typ String : Hallo! Setzen Sie den Wert Ihrer int -Variablen auf 2147483647 . Geben Sie den Wert auf der Konsole aus, z.B.: Wert von i : 2147483647 Erh\u00f6hen Sie nun den Wert der Variablen um 1 und geben Sie den Wert erneut aus. Was passiert? Warum? Wiederholen Sie das gleiche mit einer `long-Variablen. Weisen Sie Ihrer char -Variablen den Wert 65 zu. Geben Sie den Wert Ihrer char -Variablen aus. Was passiert? Warum? Schreiben Sie eine Methode public static void printIntDivision ( int nr1 , int nr2 ) { } Diese Methode soll folgende Ausgabe auf die Konsole erzeugen, z.B. f\u00fcr printIntDivision(7, 4); die Ausgabe 7 geteilt durch 4 ergibt 1 . Es bleibt ein Rest von 3 z.B. f\u00fcr printIntDivision(17, 4); die Ausgabe 17 geteilt durch 4 ergibt 4 . Es bleibt ein Rest von 1 Schreiben/\u00e4ndern Sie die Methode so, dass bei einer ganzzahligen Division ohne Rest die Ausgabe in der Form ist (Aufruf z.B. printIntDivision(16, 4); ): 16 geteilt durch 4 ergibt 4 ohne Rest. Schreiben Sie zwei Methoden public static int getQuotient ( int nr1 , int nr2 ) {} // und public static int getRemainder ( int nr1 , int nr2 ) {} Deklarieren Sie in der main()-Methode zwei int-Variablen und weisen Sie diesen Werte zu (z.B. 17 und 4 ). Wenden Sie die beiden Methoden so an, dass mit Hilfe der println() -Methode folgende Ausgaben erscheinen: 17 /4 = 4 17 mod 4 = 1 Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung1 package uebungen.uebung1 ; public class Uebung1 { public static void printIntDivision ( int nr1 , int nr2 ) { int quotient = nr1 / nr2 ; int rest = nr1 % nr2 ; if ( rest == 0 ) { System . out . println ( nr1 + \" geteilt durch \" + nr2 + \" ergibt \" + quotient + \" ohne Rest.\" ); } else { System . out . println ( nr1 + \" geteilt durch \" + nr2 + \" ergibt \" + quotient + \". Es bleibt ein Rest von \" + rest ); } } public static int getQuotient ( int nr1 , int nr2 ) { int quotient = nr1 / nr2 ; return quotient ; } public static int getRemainder ( int nr1 , int nr2 ) { int remainder = nr1 % nr2 ; return remainder ; } public static void main ( String [] args ) { int in = 123 ; long lo = 456789 ; char ch = 'a' ; byte by = 127 ; short sh = 32767 ; float fl = 4.23f ; double d1 = 6.98 ; boolean b1 = true ; String s1 = \"Hallo!\" ; System . out . println ( \" --- Aufgabe 3 -------\" ); System . out . println (); System . out . println ( \"Wert vom Typ int : \" + in ); System . out . println ( \"Wert vom Typ long : \" + lo ); System . out . println ( \"Wert vom Typ char : \" + ch ); System . out . println ( \"Wert vom Typ byte : \" + by ); System . out . println ( \"Wert vom Typ short : \" + sh ); System . out . println ( \"Wert vom Typ float : \" + fl ); System . out . println ( \"Wert vom Typ double : \" + d1 ); System . out . println ( \"Wert vom Typ boolean : \" + b1 ); System . out . println ( \"Wert vom Typ String : \" + s1 ); System . out . println (); System . out . println ( \" --- Aufgabe 4 -------\" ); System . out . println (); in = 2147483647 ; System . out . println ( \"Wert vom Typ int : \" + in ); in = in + 1 ; // in++; System . out . println ( \"Wert vom Typ int : \" + in ); System . out . println (); System . out . println ( \" --- Aufgabe 5 -------\" ); System . out . println (); lo = 2147483647L ; System . out . println ( \"Wert vom Typ long : \" + lo ); lo = lo + 1 ; System . out . println ( \"Wert vom Typ long : \" + lo ); System . out . println (); System . out . println ( \" --- Aufgabe 6 -------\" ); System . out . println (); ch = 65 ; System . out . println ( \"Wert vom Typ char : \" + ch ); System . out . println (); System . out . println ( \" --- Aufgabe 7 -------\" ); System . out . println (); printIntDivision ( 7 , 4 ); printIntDivision ( 17 , 4 ); printIntDivision ( 16 , 4 ); System . out . println (); System . out . println ( \" --- Aufgabe 7 -------\" ); System . out . println (); int number1 = 17 ; int number2 = 4 ; int result = getQuotient ( number1 , number2 ); System . out . println ( number1 + \"/\" + number2 + \" = \" + result ); int rest = getRemainder ( number1 , number2 ); System . out . println ( number1 + \" mod \" + number2 + \" = \" + rest ); } } Video zu \u00dcbung 1 \u00dcbung 2 Erstellen Sie ein package uebungen.uebung2 . Erstellen Sie in diesem package eine Klasse Uebung2 mit main() -Methode. Schreiben Sie eine Methode public static void printTimesTables(int nr1, int nr2) . Bei Aufruf der Methode z.B. f\u00fcr printTimesTables(10,10); soll das kleine Ein-Mal-Eins in der folgenden Form ausgegeben werden: Ausgabe f\u00fcr printTimesTables(10,10); 1 * 1 = 1 1 * 2 = 2 1 * 3 = 3 1 * 4 = 4 1 * 5 = 5 1 * 6 = 6 1 * 7 = 7 1 * 8 = 8 1 * 9 = 9 1 * 10 = 10 2 * 1 = 2 2 * 2 = 4 2 * 3 = 6 2 * 4 = 8 2 * 5 = 10 2 * 6 = 12 2 * 7 = 14 2 * 8 = 16 2 * 9 = 18 2 * 10 = 20 3 * 1 = 3 3 * 2 = 6 3 * 3 = 9 3 * 4 = 12 3 * 5 = 15 3 * 6 = 18 3 * 7 = 21 3 * 8 = 24 3 * 9 = 27 3 * 10 = 30 4 * 1 = 4 4 * 2 = 8 4 * 3 = 12 4 * 4 = 16 4 * 5 = 20 4 * 6 = 24 4 * 7 = 28 4 * 8 = 32 4 * 9 = 36 4 * 10 = 40 5 * 1 = 5 5 * 2 = 10 5 * 3 = 15 5 * 4 = 20 5 * 5 = 25 5 * 6 = 30 5 * 7 = 35 5 * 8 = 40 5 * 9 = 45 5 * 10 = 50 6 * 1 = 6 6 * 2 = 12 6 * 3 = 18 6 * 4 = 24 6 * 5 = 30 6 * 6 = 36 6 * 7 = 42 6 * 8 = 48 6 * 9 = 54 6 * 10 = 60 7 * 1 = 7 7 * 2 = 14 7 * 3 = 21 7 * 4 = 28 7 * 5 = 35 7 * 6 = 42 7 * 7 = 49 7 * 8 = 56 7 * 9 = 63 7 * 10 = 70 8 * 1 = 8 8 * 2 = 16 8 * 3 = 24 8 * 4 = 32 8 * 5 = 40 8 * 6 = 48 8 * 7 = 56 8 * 8 = 64 8 * 9 = 72 8 * 10 = 80 9 * 1 = 9 9 * 2 = 18 9 * 3 = 27 9 * 4 = 36 9 * 5 = 45 9 * 6 = 54 9 * 7 = 63 9 * 8 = 72 9 * 9 = 81 9 * 10 = 90 10 * 1 = 10 10 * 2 = 20 10 * 3 = 30 10 * 4 = 40 10 * 5 = 50 10 * 6 = 60 10 * 7 = 70 10 * 8 = 80 10 * 9 = 90 10 * 10 = 100 Schreiben Sie eine Methode public static void printTimesMatrix(int nr1, int nr2) . Bei Aufruf der Methode z.B. f\u00fcr printTimesMatrix(10,10) soll das kleine Ein-Mal-Eins in der folgenden Form ausgegeben werden: Ausgabe f\u00fcr printTimesMatrix(10,10); 1 2 3 4 5 6 7 8 9 10 2 4 6 8 10 12 14 16 18 20 3 6 9 12 15 18 21 24 27 30 4 8 12 16 20 24 28 32 36 40 5 10 15 20 25 30 35 40 45 50 6 12 18 24 30 36 42 48 54 60 7 14 21 28 35 42 49 56 63 70 8 16 24 32 40 48 56 64 72 80 9 18 27 36 45 54 63 72 81 90 10 20 30 40 50 60 70 80 90 100 Schreiben Sie eine Methode public static void printTriangleUp(int height) . Bei Aufruf der Methode z.B. f\u00fcr printTriangleUp(7) soll folgende Ausgabe erscheinen: ******* ****** ***** **** *** ** * Geben Sie alle m\u00f6glichen Kombinationen f\u00fcr 3 ganze Zahlen x , y und z aus, f\u00fcr die gilt: x <= y <= z und x * y * z = 36 Schreiben Sie eine Umrechnung f\u00fcr eine gegebene Anzahl von Sekunden ( printSeconds(int seconds) ), z.B. printSeconds(3456789) : 3456789 Sekunden sind 40 Tage, 13 Minuten, 9 Sekunden. Aber z.B. printSeconds(2345678) : 2345678 Sekunden sind 27 Tage, 3 Stunden, 34 Minuten, 38 Sekunden. Aber z.B. printSeconds(123456) : 123456 Sekunden sind 1 Tag, 10 Stunden, 17 Minuten, 36 Sekunden. Aber z.B. printSeconds(12345) : 12345 Sekunden sind 3 Stunden, 25 Minuten, 45 Sekunden. Schreiben Sie eine Methode, die f\u00fcr eine nat\u00fcrliche Zahl deren Quersumme ausgibt, z.B.: crossSum(12345678) Die Quersumme von 12345678 ist 36 . Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 2 package uebungen.uebung2 ; public class Uebung2 { public static void printTimesTables ( int nr1 , int nr2 ) { for ( int faktor1 = 1 ; faktor1 <= nr1 ; faktor1 ++ ) { for ( int faktor2 = 1 ; faktor2 <= nr2 ; faktor2 ++ ) { int produkt = faktor1 * faktor2 ; System . out . println ( faktor1 + \" * \" + faktor2 + \" = \" + produkt ); } System . out . println (); } } public static void printTimesMatrix ( int nr1 , int nr2 ) { for ( int faktor1 = 1 ; faktor1 <= nr1 ; faktor1 ++ ) { for ( int faktor2 = 1 ; faktor2 <= nr2 ; faktor2 ++ ) { int produkt = faktor1 * faktor2 ; System . out . print ( produkt + \" \" ); } System . out . println (); } } public static void printTriangleUp ( int height ) { for ( int row = 0 ; row < height ; row ++ ) { //System.out.println(\"Zeile : \" + row + \" Sterne : \" + (height-row)); for ( int stars = row ; stars < height ; stars ++ ) { System . out . print ( \"*\" ); } /* System.out.print(\" \"); for(int stars=0; stars<=row; stars++) { System.out.print(\"*\"); } System.out.print(\" \"); for(int stars=0; stars<=row; stars++) { System.out.print(\"*\"); } */ System . out . println (); } } public static void printXYZ () { int product = 36 ; for ( int z = - product ; z <= product ; z ++ ) { for ( int y = - product ; y <= z ; y ++ ) { for ( int x = - product ; x <= y ; x ++ ) { //if(x * y * z == product && (x <= y) && y <= z) if ( x * y * z == product ) { System . out . println ( \"z=\" + z + \" y=\" + y + \" x=\" + x ); } } } } } public static void printSeconds ( int seconds ) { int minute = 60 ; int hour = 60 * minute ; // 3600 int day = 24 * hour ; // 86400 int days = seconds / day ; int restSeconds = seconds - ( days * day ); int hours = restSeconds / hour ; restSeconds = restSeconds - ( hours * hour ); int minutes = restSeconds / minute ; restSeconds = restSeconds - ( minutes * minute ); /* System.out.println(seconds + \" Sekunden sind \" + days + \" Tage, \" + hours + \" Stunden, \" + minutes + \" Minuten, \" + restSeconds + \" Sekunden.\"); */ String output = seconds + \" Sekunden sind \" ; if ( days == 1 ) { output = output + \" 1 Tag, \" ; } else { if ( days > 1 ) { output = output + days + \" Tage, \" ; } } if ( hours == 1 ) { output = output + \" 1 Stunde, \" ; } else { if ( hours > 1 ) { output = output + hours + \" Stunden, \" ; } } if ( minutes == 1 ) { output = output + \" 1 Minute, \" ; } else { if ( minutes > 1 ) { output = output + minutes + \" Minuten, \" ; } } if ( restSeconds == 1 ) { output = output + \" 1 Sekunde.\" ; } else { if ( restSeconds > 1 ) { output = output + restSeconds + \" Sekunden.\" ; } } System . out . println ( output ); } public static int crossSum ( int number ) { int sum = 0 ; int rest = number % 10 ; // letzte Ziffer sum = sum + rest ; int result = number / 10 ; // Zahl ohne letzte Ziffer while ( result > 0 ) { rest = result % 10 ; sum = sum + rest ; result = result / 10 ; } return sum ; } public static void main ( String [] args ) { System . out . println ( \"----- Aufgabe 1 ------\" ); System . out . println (); printTimesTables ( 10 , 10 ); System . out . println (); System . out . println ( \"----- Aufgabe 2 ------\" ); System . out . println (); printTimesMatrix ( 10 , 10 ); System . out . println (); System . out . println ( \"----- Aufgabe 3 ------\" ); System . out . println (); printTriangleUp ( 7 ); System . out . println (); System . out . println ( \"----- Aufgabe 4 ------\" ); System . out . println (); printXYZ (); System . out . println (); System . out . println ( \"----- Aufgabe 5 ------\" ); System . out . println (); printSeconds ( 3456789 ); printSeconds ( 2345678 ); printSeconds ( 123456 ); printSeconds ( 12345 ); System . out . println (); System . out . println ( \"----- Aufgabe 6 ------\" ); System . out . println (); int number = 123456789 ; int crossSum = crossSum ( number ); System . out . println ( \"Die Quersumme von \" + number + \" ist \" + crossSum + \".\" ); } } Video zu \u00dcbung 2 \u00dcbung 3 Erstellen Sie ein package uebungen.uebung3 . Erstellen Sie in diesem package eine Klasse Uebung3 mit main() -Methode. Implementieren Sie folgende Methoden: public static int inputInt() \u2013 in dieser Methode wird \u00fcber die Konsole eine int -Zahl eingelesen. Diese Zahl wird von der Methode zur\u00fcckgegeben. public static boolean isPrime(int number) \u2013 diese Methode pr\u00fcft, ob die als Parameter \u00fcbergebene number eine Primzahl ist. Die Methode gibt ein true zur\u00fcck, wenn number eine Primzahl ist und false sonst. public static void printPrimeNumbers(int maximum) \u2013 diese Methode gibt alle Primzahlen von 1 bis einschlie\u00dflich maximum wie folgt auf der Konsole aus (Bsp. f\u00fcr maximum=61 ): Zahl : 61 .2 3 .5 .7 ...11 .13 ...17 .19 ...23 .....29 .31 .....37 ...41 .43 ...47 .....53 .....59 .61 d.h. es werden die Zahlen, die Primzahlen sind, ausgegeben und f\u00fcr die anderen Zahlen erscheint nur ein Punkt. Verwenden Sie in der Methode printPrimenumbers(int) die Methode isPrime(int) . public static int getSmallestDivider(int number) \u2013 diese Methode gibt den kleinsten Teiler zur\u00fcck, der number ganzzahlig teilt. Ist number eine Primzahl, wird number zur\u00fcckgegeben. F\u00fcr den Fall, dass number kleiner als 2 ist, geben Sie ebenfalls number zur\u00fcck. public static String createStringOfPrimeFactorization(int number) \u2013 diese Methode gibt einen String in folgender Form zur\u00fcck (Bsp. f\u00fcr number=632060 ): \" 2 * 2 * 5 * 11 * 13 * 13 * 17 = 632060 \" d.h. alle kleinsten Teiler werden mit dem Multiplikationszeichen verbunden und am Ende erscheint = Wert von number . Testen Sie alle Methoden. Rufen Sie insbesondere inputInt() , printPrimenumbers(int) und createStringOfPrimeFactorization(int) in der main() -Methode auf. Tipp: Bei der \u00dcberpr\u00fcfung, ob number eine Primzahl ist, gen\u00fcgt es, Teiler bis zur Wurzel von number zu suchen. Werden bis dahin keine Teiler gefunden, ist number eine Primzahl. Sie k\u00f6nnen sich dazu z.B. eine Variable der Form int bound = (int) Math.sqrt(number); erstellen und m\u00fcssen dann den Teiler nur bis bound suchen (der Typkonvertierungsoperator (int) macht aus der double -Zahl einen int - schneidet die Nachkommastellen ab). Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 3 package uebungen.uebung3 ; import java.util.Scanner ; public class Uebung3 { public static int inputInt () { Scanner sc = new Scanner ( System . in ); System . out . print ( \"Geben Sie eine Zahl ein : \" ); int number = sc . nextInt (); sc . close (); return number ; } public static boolean isPrime ( int number ) { boolean isPrime = true ; // true ist wichtig! if ( number < 2 ) { isPrime = false ; } else { if ( number == 2 ) { isPrime = true ; } else { for ( int divider = 2 ; divider <= Math . sqrt ( number ) && isPrime ; divider ++ ) { if ( number % divider == 0 ) { isPrime = false ; } } } } return isPrime ; } public static void printPrimeNumbers ( int maximum ) { for ( int number = 1 ; number <= maximum ; number ++ ) { if ( isPrime ( number )) { System . out . print ( number + \" \" ); } else { System . out . print ( \". \" ); } if ( number % 30 == 0 ) { System . out . println (); } } } public static int getSmallestDivider ( int number ) { int smallestDivider = 0 ; boolean found = false ; if ( number < 2 ) { smallestDivider = number ; } else { if ( isPrime ( number )) { smallestDivider = number ; } else { for ( int divider = 2 ; divider < number && ! found ; divider ++ ) { if ( number % divider == 0 ) { smallestDivider = divider ; found = true ; } } } } return smallestDivider ; } public static String createStringOfPrimeFactorization ( int number ) { String s = \"\" ; /* * 2 * 2 * 5 * 11 * 13 * 13 * 17 = 632060 * 632060 --> 2 * 316030 --> 2 * 158015 --> 5 * ... --> divider * result/divider == 1 */ int smallestDivider = getSmallestDivider ( number ); s = s + smallestDivider ; int result = number / smallestDivider ; while ( result > 1 ) { smallestDivider = getSmallestDivider ( result ); s = s + \" * \" + smallestDivider ; result = result / smallestDivider ; } s = s + \" = \" + number ; return s ; } public static void main ( String [] args ) { System . out . printf ( \"%n%n----------- Aufgabe 1 ------------ %n %n\" ); int number = inputInt (); System . out . println ( \"Sie haben \" + number + \" eingegeben.\" ); System . out . printf ( \"%n%n----------- Aufgabe 2 ------------ %n %n\" ); System . out . println ( isPrime ( number )); System . out . printf ( \"%n%n----------- Aufgabe 3 ------------ %n %n\" ); printPrimeNumbers ( number ); System . out . printf ( \"%n%n----------- Aufgabe 4 ------------ %n %n\" ); System . out . println ( getSmallestDivider ( number )); System . out . printf ( \"%n%n----------- Aufgabe 5 ------------ %n %n\" ); String output = createStringOfPrimeFactorization ( 632060 ); System . out . println ( output ); } } Video zu \u00dcbung 3 \u00dcbung 4 Erstellen Sie ein package uebungen.uebung4 . Erstellen Sie in diesem package eine Klasse Uebung4 mit main() -Methode. Implementieren Sie folgende Methoden: Implementieren Sie eine public static void print(char[] ca) -Methode, so dass das char[] ca auf die Konsole ausgegeben wird. Achten Sie darauf, dass hinter dem letzten Element kein Komma steht. Testen Sie Ihre Methode auch f\u00fcr ein leeres Array. Bsp: print(['a', 'b', 'c', 'a', 'c', 'a', 'b', 'c']) Ausgabe auf Konsole: [a, b, c, a, c, a, b, c] Kopieren Sie die print -Methode vollst\u00e4ndig und \u00e4ndern Sie den Typ des Parameters von char[] in int[] . (Die Methode ist jetzt \u00fcberladen und print() kann jetzt entweder ein char[] oder ein int[] \u00fcbergeben werden, welches auf die Konsole ausgegeben wird.) Implementieren Sie eine Methode public static char[] stringToCharArray(String s) . Diese Methode wandelt einen String in ein char[] um, so dass jedes Zeichen des Strings im char[] enthalten ist. Das char[] wird zur\u00fcckgegeben. Tipps: die L\u00e4nge eines Strings wird mit der Objektmethode length() ermittelt. Die einzelnen Zeichen eines Strings k\u00f6nnen mithilfe der charAt(index) -Objektmethode von Strings ermittelt werden. Siehe String Bsp.: stringToCharArray(\"hallo!\") \u2192 ['h','a','l','l','o','!'] Implementieren Sie eine Methode public static char[] filter(char[] carr, char filter) , der als Parameter ein char -Array und ein char \u00fcbergeben wird. Die Methode soll ein char -Array zur\u00fcckgeben, das dem als Parameter \u00fcbergeben Array entspricht, au\u00dfer dass jedes Vorkommen des als Parameter \u00fcbergeben carr entfernt wurde Bsp: filter(['a', 'b', 'c', 'a', 'c', 'a', 'b', 'c'], 'c') \u2192 ['a', 'b', 'a', 'a', 'b'] Implementieren Sie eine Methode public static int[] minAndMax(int[] iarr) , der ein int -Array als Parameter \u00fcbergeben wird und die ein zweielementiges Array zur\u00fcckgibt. Das erste Element des zur\u00fcckgegeben Arrays ist das Minimum des als Parameter \u00fcbergebenen Arrays und das zweite Element ist das Maximum. Bsp.: minAndMax([4,2,8,1,6,2,4,1,8]) \u2192 [1,8] minAndMax([4]) \u2192 [4,4] Implementieren Sie eine Methode public static int[] reverse(int[] iarr) , der ein int -Array \u00fcbergeben wird und die die Reihenfolge der Elemente des Arrays umdreht (das letzte zuerst usw.) Das neuerstellte Array wird zur\u00fcckgegeben. Bsp.: reverse([4,2,8,1,6,2,4,1,8]) \u2192 [8,1,4,2,6,1,8,2,4] reverse([4]) \u2192 [4] Zusatz: Implementieren Sie eine Methode public static boolean containsDoublets(char[] ca) die ein true zur\u00fcckgibt, wenn mindestens ein Wert in ca mindestens zwei Mal vorkommt (wenn Sie schon dabei sind, k\u00f6nnen Sie sich auch \u00fcberlegen, wenn genau ein Wert genau zwei Mal vorkommt - oder mindestens ein Wert genau zwei Mal - oder genau ein Wert mindestens zwei Mal) und false sonst. Weitere \u00dcbungsaufgaben (selbst\u00e4ndiges \u00dcben) \u00b6 Hier werden lose und unregelm\u00e4\u00dfig \u00dcbungsaufgaben gesammelt. Am Ende des Semesters soll dann hier eine gro\u00dfe Sammlung von \u00dcbungsaufgaben entstanden sein, die der eigenen Kontrolle dienen sollen. Die \u00dcbungen sind thematisch sortiert, allerdings \u00fcberschneiden sich manche Themen in einigen \u00dcbungen. Ausdr\u00fccke \u00b6 gleich 12 Welche der folgenden Ausdr\u00fccke haben den Wert 12? a ) 12 % 13 b ) 24 % 2 c ) 24 /2 d ) 25 /2 Versuchen Sie zun\u00e4chst, die richtige Antwort im Kopf zu ermitteln und erstellen dann ein geeignetes Programm, das Ihnen den jeweiligen Wert des Ausdrucks ausgibt. Pre- und Postoperator Welchen Wert hat die Variable c nach Ausf\u00fchren der Anweisungen? int a = 300 ; int b = a++ ; int c = --b ; Begr\u00fcnden Sie die richtige Antwort! Was passiert durch die Anweisungen? Schleifen \u00b6 Laufvariablen Welche der Schleifen gibt alle Elemente des Arrays nums aus? Das Array enth\u00e4lt genau 4 Zahlen. a ) for ( int i = 0 ; i < nums.length ; i++ ) { System.out.println ( nums [ i ]) ; } b ) for ( int i = 0 ; i < = 3 ; i++ ) { System.out.println ( nums [ i ]) ; } c ) for ( int i = 1 ; i < = 3 ; i++ ) { System.out.println ( nums [ i ]) ; } d ) for ( int i = 0 ; i < = 3 ; i++ ) { System.out.println ( nums [ 0 ]) ; } e ) for ( int i = nums.length - 1 ; i > = 0 ; i-- ) { System.out.println ( nums [ i ]) ; } Quadratzahl Schreiben Sie eine Methode istQuadratzahl(int zahl) , die ein true zur\u00fcckgibt, wenn zahl eine Quadratzahl ist und ein false sonst. Die Math -Klasse soll nicht verwendet werden. Primzahl Schreiben Sie eine Methode printPrimzahlenBisN(int n) , die alle Primzahlen bis n auf die Konsole ausgibt. Schreiben Sie sich dazu eine Hilfsmethode istPrimzahl(int zahl) , die ein true zur\u00fcckgibt, wenn zahl eine Primzahl ist und ein false , wenn nicht. int-Zahl umdrehen Schreiben Sie eine Methode int reverseInt(int number) , die die \u00fcbergebene number umdreht und die umgedrehte int -Zahl zur\u00fcckgibt, also z.B. aus 1234 wird 4321 . Weitere Beispiele: aus -123 wird -321 und aus 1200 wird 21 . Zahlen raten Schreiben Sie folgendes Programm. Mithilfe von Random \"denkt\" sich das Programm eine Zahl zwischen 0 und 100 aus. Sie k\u00f6nnen \u00fcber die Konsole dann eine Zahl eingeben. Das Programm sagt Ihnen, ob die \"gedachte\" Zahl gr\u00f6\u00dfer oder kleiner als die von Ihnen eingegebene Zahl ist. Sie geben solange eine Zahl ein, bis Sie die \"gedachte\" Zahl erraten haben. Bin\u00e4rzahl Schreiben Sie eine Methode, die eine short -Zahl in eine Bin\u00e4rzahl umwandelt. Diese Bin\u00e4rzahl speichern Sie als long . Z.B. ist 32 bin\u00e4r 100000 , 63 ist 111111 , 48 ist 110000 usw. Arrays \u00b6 Implementieren Sie eine Methode, die zwei als Parameter \u00fcbergebene sortierte int -Arrays zu einem sortierten int -Array zusammenf\u00fcgt. Geben Sie das neue sortierte Array zur\u00fcck Implementieren Sie eine Methode, die zwei als Parameter \u00fcbergebene unsortierte int -Arrays zu einem sortierten int -Array zusammenf\u00fcgt. Geben Sie das neue sortierte Array zur\u00fcck Implementieren Sie eine Methode int[] explode(int number) . Diese Methode erstellt ein int[] -Array, das wie folgt bef\u00fcllt ist: Bsp. number=5 \u2192 {1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5} . F\u00fcr jede Zahl x gibt es also x Eintr\u00e4ge im Array bis einschlie\u00dflich number Wrapper-Klassen \u00b6 Initialisierung einer Long-Variablen Welche Anweisungen initialisieren eine Long-Variable korrekt? a ) Long val = new Long ( 4321 ) ; b ) Long val = 4321L ; c ) Long val = new Long ( \"4321\" ) ; d ) Long val = Long.parseLong ( \"4321\" ) ; Vererbung \u00b6 Sichtbarkeitsmodifizierer Gegeben sind die beiden Klassen - beide sind in verschiedenen Paketen: 1 2 3 public class BaseClass { ??? int a ; } und 1 2 3 4 5 6 7 public class DerivedClass extends BaseClass { private int b ; public int sum () { return a + b ; } } Welche der folgenden Sichtbarkeitsmodifizierer k\u00f6nnen anstelle von ??? eingesetzt werden, damit das Programm compiliert werden kann? a ) protected b ) keiner ( default ) c ) public d ) private","title":"\u00dcbungen"},{"location":"uebungen/#ubungen","text":"","title":"\u00dcbungen"},{"location":"uebungen/#ubungsblatter-wochenweise","text":"\u00dcbung 0 Installieren Sie sich - falls noch nicht geschehen - eine Java-Entwicklungsumgebung (siehe Java ). Installieren Sie sich die IDE Ihrer Wahl (siehe IDE ). In den Vorlesungen und \u00dcbungen (Videos) verwende ich Eclipse und beschreibe die Schritte auch f\u00fcr Eclipse. Starten Sie Eclipse durch Doppelklick auf das Programmsymbol. Erstellen Sie einen Workspace (Arbeitsbereich) in einem gewu\u0308nschten Ordner (z. B. Programmieren) im Dateisystem. Achten Sie darauf, dass Sie Schreibrechte in diesem Ordner besitzen. Anlegen eines Projektordners: Auswahl im Men\u00fc File-->New-->Java Project . Eingabe des Project name: Name des Projektes (z.B. WiSe20 ). Wenn Sie gefragt werden, ob Sie ein module-info.java erstellen wollen, w\u00e4hlen Sie Don't create . Klicken auf den Button Finish . Erstellen eines neuen Packages (Paketes): \u00d6ffnen der Projektmappe im Package Explorer . Auswahl des Ordners src mit der rechten Maustaste. Auswahl des Men\u00fcpunktes New --> Package . Geben Sie folgenden Paketnamen ein (Paketnamen werden kleingeschrieben) uebungen.uebung0 (Achten Sie auf den Punkt und dass Sie alles zusammen schreiben). Erstellen einer neuen Klasse: \u00d6ffnen der Projektmappe im Package Explorer. Auswahl des Paketes ( uebungen.uebung0 ) mit der rechten Maustaste. Auswahl des Menu\u0308punktes New --> Class . Eingabe des Namens, der gleichzeitig der Klassen- und Dateiname ist: Uebung0 . Klassennamen werden immer gro\u00df geschrieben. Setzen des H\u00e4kchens bei public static void main() . (Sollten Sie vergessen haben, das H\u00e4kchen zu setzen, dann ist die Klasse, nachdem Sie Finish gedr\u00fcckt haben, leer. Setzen Sie dann den Cursor zwischen die beiden geschweiften Klammern { } , geben dann main ein und dr\u00fccken die Ctrl + Leer -Tasten und anschlie\u00dfend Enter . Dann erscheint die main() -Methode) Klicken auf den Button Finish . In die main() -Methode (zwischen die geschweiften Klammern { und } geben Sie ein: System.out.println(\"Uebung 0\")); . Dr\u00fccken Sie dann entweder auf den -Button oder w\u00e4hlen Sie aus dem Men\u00fc Run --> Run oder dr\u00fccken Sie shift + command + f11 . In der Console in Ihrer IDE (in Eclipse unten) erscheint Uebung 0 . Uebung1.java package uebungen.uebung0 ; public class Uebung0 { public static void main ( String [] args ) { System . out . println ( \"Uebung 0\" ); } } Success Fertig! Ihre Entwicklungsumgebung ist bereit! Wir k\u00f6nnen loslegen. \u00dcbung 1 Erstellen Sie ein package uebungen.uebung1 . Erstellen Sie in diesem package eine Klasse Uebung1 mit main() -Methode. Deklarieren und initialisieren Sie in der main() -Methode jeweils eine Variable mit dem Datentyp int , long , char , byte , short , float , double , boolean und String . Geben Sie alle Werte einzeln durch Aufruf der println() -Methode aus. Erzeugen Sie dabei folgende Ausgabe (Werte nur Beispiele): Wert vom Typ int : 123 Wert vom Typ long : 456789 Wert vom Typ char : a Wert vom Typ byte : 127 Wert vom Typ short : 32767 Wert vom Typ float : 4 .23 Wert vom Typ double : 6 .98 Wert vom Typ boolean : true Wert vom Typ String : Hallo! Setzen Sie den Wert Ihrer int -Variablen auf 2147483647 . Geben Sie den Wert auf der Konsole aus, z.B.: Wert von i : 2147483647 Erh\u00f6hen Sie nun den Wert der Variablen um 1 und geben Sie den Wert erneut aus. Was passiert? Warum? Wiederholen Sie das gleiche mit einer `long-Variablen. Weisen Sie Ihrer char -Variablen den Wert 65 zu. Geben Sie den Wert Ihrer char -Variablen aus. Was passiert? Warum? Schreiben Sie eine Methode public static void printIntDivision ( int nr1 , int nr2 ) { } Diese Methode soll folgende Ausgabe auf die Konsole erzeugen, z.B. f\u00fcr printIntDivision(7, 4); die Ausgabe 7 geteilt durch 4 ergibt 1 . Es bleibt ein Rest von 3 z.B. f\u00fcr printIntDivision(17, 4); die Ausgabe 17 geteilt durch 4 ergibt 4 . Es bleibt ein Rest von 1 Schreiben/\u00e4ndern Sie die Methode so, dass bei einer ganzzahligen Division ohne Rest die Ausgabe in der Form ist (Aufruf z.B. printIntDivision(16, 4); ): 16 geteilt durch 4 ergibt 4 ohne Rest. Schreiben Sie zwei Methoden public static int getQuotient ( int nr1 , int nr2 ) {} // und public static int getRemainder ( int nr1 , int nr2 ) {} Deklarieren Sie in der main()-Methode zwei int-Variablen und weisen Sie diesen Werte zu (z.B. 17 und 4 ). Wenden Sie die beiden Methoden so an, dass mit Hilfe der println() -Methode folgende Ausgaben erscheinen: 17 /4 = 4 17 mod 4 = 1 Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung1 package uebungen.uebung1 ; public class Uebung1 { public static void printIntDivision ( int nr1 , int nr2 ) { int quotient = nr1 / nr2 ; int rest = nr1 % nr2 ; if ( rest == 0 ) { System . out . println ( nr1 + \" geteilt durch \" + nr2 + \" ergibt \" + quotient + \" ohne Rest.\" ); } else { System . out . println ( nr1 + \" geteilt durch \" + nr2 + \" ergibt \" + quotient + \". Es bleibt ein Rest von \" + rest ); } } public static int getQuotient ( int nr1 , int nr2 ) { int quotient = nr1 / nr2 ; return quotient ; } public static int getRemainder ( int nr1 , int nr2 ) { int remainder = nr1 % nr2 ; return remainder ; } public static void main ( String [] args ) { int in = 123 ; long lo = 456789 ; char ch = 'a' ; byte by = 127 ; short sh = 32767 ; float fl = 4.23f ; double d1 = 6.98 ; boolean b1 = true ; String s1 = \"Hallo!\" ; System . out . println ( \" --- Aufgabe 3 -------\" ); System . out . println (); System . out . println ( \"Wert vom Typ int : \" + in ); System . out . println ( \"Wert vom Typ long : \" + lo ); System . out . println ( \"Wert vom Typ char : \" + ch ); System . out . println ( \"Wert vom Typ byte : \" + by ); System . out . println ( \"Wert vom Typ short : \" + sh ); System . out . println ( \"Wert vom Typ float : \" + fl ); System . out . println ( \"Wert vom Typ double : \" + d1 ); System . out . println ( \"Wert vom Typ boolean : \" + b1 ); System . out . println ( \"Wert vom Typ String : \" + s1 ); System . out . println (); System . out . println ( \" --- Aufgabe 4 -------\" ); System . out . println (); in = 2147483647 ; System . out . println ( \"Wert vom Typ int : \" + in ); in = in + 1 ; // in++; System . out . println ( \"Wert vom Typ int : \" + in ); System . out . println (); System . out . println ( \" --- Aufgabe 5 -------\" ); System . out . println (); lo = 2147483647L ; System . out . println ( \"Wert vom Typ long : \" + lo ); lo = lo + 1 ; System . out . println ( \"Wert vom Typ long : \" + lo ); System . out . println (); System . out . println ( \" --- Aufgabe 6 -------\" ); System . out . println (); ch = 65 ; System . out . println ( \"Wert vom Typ char : \" + ch ); System . out . println (); System . out . println ( \" --- Aufgabe 7 -------\" ); System . out . println (); printIntDivision ( 7 , 4 ); printIntDivision ( 17 , 4 ); printIntDivision ( 16 , 4 ); System . out . println (); System . out . println ( \" --- Aufgabe 7 -------\" ); System . out . println (); int number1 = 17 ; int number2 = 4 ; int result = getQuotient ( number1 , number2 ); System . out . println ( number1 + \"/\" + number2 + \" = \" + result ); int rest = getRemainder ( number1 , number2 ); System . out . println ( number1 + \" mod \" + number2 + \" = \" + rest ); } } Video zu \u00dcbung 1 \u00dcbung 2 Erstellen Sie ein package uebungen.uebung2 . Erstellen Sie in diesem package eine Klasse Uebung2 mit main() -Methode. Schreiben Sie eine Methode public static void printTimesTables(int nr1, int nr2) . Bei Aufruf der Methode z.B. f\u00fcr printTimesTables(10,10); soll das kleine Ein-Mal-Eins in der folgenden Form ausgegeben werden: Ausgabe f\u00fcr printTimesTables(10,10); 1 * 1 = 1 1 * 2 = 2 1 * 3 = 3 1 * 4 = 4 1 * 5 = 5 1 * 6 = 6 1 * 7 = 7 1 * 8 = 8 1 * 9 = 9 1 * 10 = 10 2 * 1 = 2 2 * 2 = 4 2 * 3 = 6 2 * 4 = 8 2 * 5 = 10 2 * 6 = 12 2 * 7 = 14 2 * 8 = 16 2 * 9 = 18 2 * 10 = 20 3 * 1 = 3 3 * 2 = 6 3 * 3 = 9 3 * 4 = 12 3 * 5 = 15 3 * 6 = 18 3 * 7 = 21 3 * 8 = 24 3 * 9 = 27 3 * 10 = 30 4 * 1 = 4 4 * 2 = 8 4 * 3 = 12 4 * 4 = 16 4 * 5 = 20 4 * 6 = 24 4 * 7 = 28 4 * 8 = 32 4 * 9 = 36 4 * 10 = 40 5 * 1 = 5 5 * 2 = 10 5 * 3 = 15 5 * 4 = 20 5 * 5 = 25 5 * 6 = 30 5 * 7 = 35 5 * 8 = 40 5 * 9 = 45 5 * 10 = 50 6 * 1 = 6 6 * 2 = 12 6 * 3 = 18 6 * 4 = 24 6 * 5 = 30 6 * 6 = 36 6 * 7 = 42 6 * 8 = 48 6 * 9 = 54 6 * 10 = 60 7 * 1 = 7 7 * 2 = 14 7 * 3 = 21 7 * 4 = 28 7 * 5 = 35 7 * 6 = 42 7 * 7 = 49 7 * 8 = 56 7 * 9 = 63 7 * 10 = 70 8 * 1 = 8 8 * 2 = 16 8 * 3 = 24 8 * 4 = 32 8 * 5 = 40 8 * 6 = 48 8 * 7 = 56 8 * 8 = 64 8 * 9 = 72 8 * 10 = 80 9 * 1 = 9 9 * 2 = 18 9 * 3 = 27 9 * 4 = 36 9 * 5 = 45 9 * 6 = 54 9 * 7 = 63 9 * 8 = 72 9 * 9 = 81 9 * 10 = 90 10 * 1 = 10 10 * 2 = 20 10 * 3 = 30 10 * 4 = 40 10 * 5 = 50 10 * 6 = 60 10 * 7 = 70 10 * 8 = 80 10 * 9 = 90 10 * 10 = 100 Schreiben Sie eine Methode public static void printTimesMatrix(int nr1, int nr2) . Bei Aufruf der Methode z.B. f\u00fcr printTimesMatrix(10,10) soll das kleine Ein-Mal-Eins in der folgenden Form ausgegeben werden: Ausgabe f\u00fcr printTimesMatrix(10,10); 1 2 3 4 5 6 7 8 9 10 2 4 6 8 10 12 14 16 18 20 3 6 9 12 15 18 21 24 27 30 4 8 12 16 20 24 28 32 36 40 5 10 15 20 25 30 35 40 45 50 6 12 18 24 30 36 42 48 54 60 7 14 21 28 35 42 49 56 63 70 8 16 24 32 40 48 56 64 72 80 9 18 27 36 45 54 63 72 81 90 10 20 30 40 50 60 70 80 90 100 Schreiben Sie eine Methode public static void printTriangleUp(int height) . Bei Aufruf der Methode z.B. f\u00fcr printTriangleUp(7) soll folgende Ausgabe erscheinen: ******* ****** ***** **** *** ** * Geben Sie alle m\u00f6glichen Kombinationen f\u00fcr 3 ganze Zahlen x , y und z aus, f\u00fcr die gilt: x <= y <= z und x * y * z = 36 Schreiben Sie eine Umrechnung f\u00fcr eine gegebene Anzahl von Sekunden ( printSeconds(int seconds) ), z.B. printSeconds(3456789) : 3456789 Sekunden sind 40 Tage, 13 Minuten, 9 Sekunden. Aber z.B. printSeconds(2345678) : 2345678 Sekunden sind 27 Tage, 3 Stunden, 34 Minuten, 38 Sekunden. Aber z.B. printSeconds(123456) : 123456 Sekunden sind 1 Tag, 10 Stunden, 17 Minuten, 36 Sekunden. Aber z.B. printSeconds(12345) : 12345 Sekunden sind 3 Stunden, 25 Minuten, 45 Sekunden. Schreiben Sie eine Methode, die f\u00fcr eine nat\u00fcrliche Zahl deren Quersumme ausgibt, z.B.: crossSum(12345678) Die Quersumme von 12345678 ist 36 . Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 2 package uebungen.uebung2 ; public class Uebung2 { public static void printTimesTables ( int nr1 , int nr2 ) { for ( int faktor1 = 1 ; faktor1 <= nr1 ; faktor1 ++ ) { for ( int faktor2 = 1 ; faktor2 <= nr2 ; faktor2 ++ ) { int produkt = faktor1 * faktor2 ; System . out . println ( faktor1 + \" * \" + faktor2 + \" = \" + produkt ); } System . out . println (); } } public static void printTimesMatrix ( int nr1 , int nr2 ) { for ( int faktor1 = 1 ; faktor1 <= nr1 ; faktor1 ++ ) { for ( int faktor2 = 1 ; faktor2 <= nr2 ; faktor2 ++ ) { int produkt = faktor1 * faktor2 ; System . out . print ( produkt + \" \" ); } System . out . println (); } } public static void printTriangleUp ( int height ) { for ( int row = 0 ; row < height ; row ++ ) { //System.out.println(\"Zeile : \" + row + \" Sterne : \" + (height-row)); for ( int stars = row ; stars < height ; stars ++ ) { System . out . print ( \"*\" ); } /* System.out.print(\" \"); for(int stars=0; stars<=row; stars++) { System.out.print(\"*\"); } System.out.print(\" \"); for(int stars=0; stars<=row; stars++) { System.out.print(\"*\"); } */ System . out . println (); } } public static void printXYZ () { int product = 36 ; for ( int z = - product ; z <= product ; z ++ ) { for ( int y = - product ; y <= z ; y ++ ) { for ( int x = - product ; x <= y ; x ++ ) { //if(x * y * z == product && (x <= y) && y <= z) if ( x * y * z == product ) { System . out . println ( \"z=\" + z + \" y=\" + y + \" x=\" + x ); } } } } } public static void printSeconds ( int seconds ) { int minute = 60 ; int hour = 60 * minute ; // 3600 int day = 24 * hour ; // 86400 int days = seconds / day ; int restSeconds = seconds - ( days * day ); int hours = restSeconds / hour ; restSeconds = restSeconds - ( hours * hour ); int minutes = restSeconds / minute ; restSeconds = restSeconds - ( minutes * minute ); /* System.out.println(seconds + \" Sekunden sind \" + days + \" Tage, \" + hours + \" Stunden, \" + minutes + \" Minuten, \" + restSeconds + \" Sekunden.\"); */ String output = seconds + \" Sekunden sind \" ; if ( days == 1 ) { output = output + \" 1 Tag, \" ; } else { if ( days > 1 ) { output = output + days + \" Tage, \" ; } } if ( hours == 1 ) { output = output + \" 1 Stunde, \" ; } else { if ( hours > 1 ) { output = output + hours + \" Stunden, \" ; } } if ( minutes == 1 ) { output = output + \" 1 Minute, \" ; } else { if ( minutes > 1 ) { output = output + minutes + \" Minuten, \" ; } } if ( restSeconds == 1 ) { output = output + \" 1 Sekunde.\" ; } else { if ( restSeconds > 1 ) { output = output + restSeconds + \" Sekunden.\" ; } } System . out . println ( output ); } public static int crossSum ( int number ) { int sum = 0 ; int rest = number % 10 ; // letzte Ziffer sum = sum + rest ; int result = number / 10 ; // Zahl ohne letzte Ziffer while ( result > 0 ) { rest = result % 10 ; sum = sum + rest ; result = result / 10 ; } return sum ; } public static void main ( String [] args ) { System . out . println ( \"----- Aufgabe 1 ------\" ); System . out . println (); printTimesTables ( 10 , 10 ); System . out . println (); System . out . println ( \"----- Aufgabe 2 ------\" ); System . out . println (); printTimesMatrix ( 10 , 10 ); System . out . println (); System . out . println ( \"----- Aufgabe 3 ------\" ); System . out . println (); printTriangleUp ( 7 ); System . out . println (); System . out . println ( \"----- Aufgabe 4 ------\" ); System . out . println (); printXYZ (); System . out . println (); System . out . println ( \"----- Aufgabe 5 ------\" ); System . out . println (); printSeconds ( 3456789 ); printSeconds ( 2345678 ); printSeconds ( 123456 ); printSeconds ( 12345 ); System . out . println (); System . out . println ( \"----- Aufgabe 6 ------\" ); System . out . println (); int number = 123456789 ; int crossSum = crossSum ( number ); System . out . println ( \"Die Quersumme von \" + number + \" ist \" + crossSum + \".\" ); } } Video zu \u00dcbung 2 \u00dcbung 3 Erstellen Sie ein package uebungen.uebung3 . Erstellen Sie in diesem package eine Klasse Uebung3 mit main() -Methode. Implementieren Sie folgende Methoden: public static int inputInt() \u2013 in dieser Methode wird \u00fcber die Konsole eine int -Zahl eingelesen. Diese Zahl wird von der Methode zur\u00fcckgegeben. public static boolean isPrime(int number) \u2013 diese Methode pr\u00fcft, ob die als Parameter \u00fcbergebene number eine Primzahl ist. Die Methode gibt ein true zur\u00fcck, wenn number eine Primzahl ist und false sonst. public static void printPrimeNumbers(int maximum) \u2013 diese Methode gibt alle Primzahlen von 1 bis einschlie\u00dflich maximum wie folgt auf der Konsole aus (Bsp. f\u00fcr maximum=61 ): Zahl : 61 .2 3 .5 .7 ...11 .13 ...17 .19 ...23 .....29 .31 .....37 ...41 .43 ...47 .....53 .....59 .61 d.h. es werden die Zahlen, die Primzahlen sind, ausgegeben und f\u00fcr die anderen Zahlen erscheint nur ein Punkt. Verwenden Sie in der Methode printPrimenumbers(int) die Methode isPrime(int) . public static int getSmallestDivider(int number) \u2013 diese Methode gibt den kleinsten Teiler zur\u00fcck, der number ganzzahlig teilt. Ist number eine Primzahl, wird number zur\u00fcckgegeben. F\u00fcr den Fall, dass number kleiner als 2 ist, geben Sie ebenfalls number zur\u00fcck. public static String createStringOfPrimeFactorization(int number) \u2013 diese Methode gibt einen String in folgender Form zur\u00fcck (Bsp. f\u00fcr number=632060 ): \" 2 * 2 * 5 * 11 * 13 * 13 * 17 = 632060 \" d.h. alle kleinsten Teiler werden mit dem Multiplikationszeichen verbunden und am Ende erscheint = Wert von number . Testen Sie alle Methoden. Rufen Sie insbesondere inputInt() , printPrimenumbers(int) und createStringOfPrimeFactorization(int) in der main() -Methode auf. Tipp: Bei der \u00dcberpr\u00fcfung, ob number eine Primzahl ist, gen\u00fcgt es, Teiler bis zur Wurzel von number zu suchen. Werden bis dahin keine Teiler gefunden, ist number eine Primzahl. Sie k\u00f6nnen sich dazu z.B. eine Variable der Form int bound = (int) Math.sqrt(number); erstellen und m\u00fcssen dann den Teiler nur bis bound suchen (der Typkonvertierungsoperator (int) macht aus der double -Zahl einen int - schneidet die Nachkommastellen ab). Eine m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 3 package uebungen.uebung3 ; import java.util.Scanner ; public class Uebung3 { public static int inputInt () { Scanner sc = new Scanner ( System . in ); System . out . print ( \"Geben Sie eine Zahl ein : \" ); int number = sc . nextInt (); sc . close (); return number ; } public static boolean isPrime ( int number ) { boolean isPrime = true ; // true ist wichtig! if ( number < 2 ) { isPrime = false ; } else { if ( number == 2 ) { isPrime = true ; } else { for ( int divider = 2 ; divider <= Math . sqrt ( number ) && isPrime ; divider ++ ) { if ( number % divider == 0 ) { isPrime = false ; } } } } return isPrime ; } public static void printPrimeNumbers ( int maximum ) { for ( int number = 1 ; number <= maximum ; number ++ ) { if ( isPrime ( number )) { System . out . print ( number + \" \" ); } else { System . out . print ( \". \" ); } if ( number % 30 == 0 ) { System . out . println (); } } } public static int getSmallestDivider ( int number ) { int smallestDivider = 0 ; boolean found = false ; if ( number < 2 ) { smallestDivider = number ; } else { if ( isPrime ( number )) { smallestDivider = number ; } else { for ( int divider = 2 ; divider < number && ! found ; divider ++ ) { if ( number % divider == 0 ) { smallestDivider = divider ; found = true ; } } } } return smallestDivider ; } public static String createStringOfPrimeFactorization ( int number ) { String s = \"\" ; /* * 2 * 2 * 5 * 11 * 13 * 13 * 17 = 632060 * 632060 --> 2 * 316030 --> 2 * 158015 --> 5 * ... --> divider * result/divider == 1 */ int smallestDivider = getSmallestDivider ( number ); s = s + smallestDivider ; int result = number / smallestDivider ; while ( result > 1 ) { smallestDivider = getSmallestDivider ( result ); s = s + \" * \" + smallestDivider ; result = result / smallestDivider ; } s = s + \" = \" + number ; return s ; } public static void main ( String [] args ) { System . out . printf ( \"%n%n----------- Aufgabe 1 ------------ %n %n\" ); int number = inputInt (); System . out . println ( \"Sie haben \" + number + \" eingegeben.\" ); System . out . printf ( \"%n%n----------- Aufgabe 2 ------------ %n %n\" ); System . out . println ( isPrime ( number )); System . out . printf ( \"%n%n----------- Aufgabe 3 ------------ %n %n\" ); printPrimeNumbers ( number ); System . out . printf ( \"%n%n----------- Aufgabe 4 ------------ %n %n\" ); System . out . println ( getSmallestDivider ( number )); System . out . printf ( \"%n%n----------- Aufgabe 5 ------------ %n %n\" ); String output = createStringOfPrimeFactorization ( 632060 ); System . out . println ( output ); } } Video zu \u00dcbung 3 \u00dcbung 4 Erstellen Sie ein package uebungen.uebung4 . Erstellen Sie in diesem package eine Klasse Uebung4 mit main() -Methode. Implementieren Sie folgende Methoden: Implementieren Sie eine public static void print(char[] ca) -Methode, so dass das char[] ca auf die Konsole ausgegeben wird. Achten Sie darauf, dass hinter dem letzten Element kein Komma steht. Testen Sie Ihre Methode auch f\u00fcr ein leeres Array. Bsp: print(['a', 'b', 'c', 'a', 'c', 'a', 'b', 'c']) Ausgabe auf Konsole: [a, b, c, a, c, a, b, c] Kopieren Sie die print -Methode vollst\u00e4ndig und \u00e4ndern Sie den Typ des Parameters von char[] in int[] . (Die Methode ist jetzt \u00fcberladen und print() kann jetzt entweder ein char[] oder ein int[] \u00fcbergeben werden, welches auf die Konsole ausgegeben wird.) Implementieren Sie eine Methode public static char[] stringToCharArray(String s) . Diese Methode wandelt einen String in ein char[] um, so dass jedes Zeichen des Strings im char[] enthalten ist. Das char[] wird zur\u00fcckgegeben. Tipps: die L\u00e4nge eines Strings wird mit der Objektmethode length() ermittelt. Die einzelnen Zeichen eines Strings k\u00f6nnen mithilfe der charAt(index) -Objektmethode von Strings ermittelt werden. Siehe String Bsp.: stringToCharArray(\"hallo!\") \u2192 ['h','a','l','l','o','!'] Implementieren Sie eine Methode public static char[] filter(char[] carr, char filter) , der als Parameter ein char -Array und ein char \u00fcbergeben wird. Die Methode soll ein char -Array zur\u00fcckgeben, das dem als Parameter \u00fcbergeben Array entspricht, au\u00dfer dass jedes Vorkommen des als Parameter \u00fcbergeben carr entfernt wurde Bsp: filter(['a', 'b', 'c', 'a', 'c', 'a', 'b', 'c'], 'c') \u2192 ['a', 'b', 'a', 'a', 'b'] Implementieren Sie eine Methode public static int[] minAndMax(int[] iarr) , der ein int -Array als Parameter \u00fcbergeben wird und die ein zweielementiges Array zur\u00fcckgibt. Das erste Element des zur\u00fcckgegeben Arrays ist das Minimum des als Parameter \u00fcbergebenen Arrays und das zweite Element ist das Maximum. Bsp.: minAndMax([4,2,8,1,6,2,4,1,8]) \u2192 [1,8] minAndMax([4]) \u2192 [4,4] Implementieren Sie eine Methode public static int[] reverse(int[] iarr) , der ein int -Array \u00fcbergeben wird und die die Reihenfolge der Elemente des Arrays umdreht (das letzte zuerst usw.) Das neuerstellte Array wird zur\u00fcckgegeben. Bsp.: reverse([4,2,8,1,6,2,4,1,8]) \u2192 [8,1,4,2,6,1,8,2,4] reverse([4]) \u2192 [4] Zusatz: Implementieren Sie eine Methode public static boolean containsDoublets(char[] ca) die ein true zur\u00fcckgibt, wenn mindestens ein Wert in ca mindestens zwei Mal vorkommt (wenn Sie schon dabei sind, k\u00f6nnen Sie sich auch \u00fcberlegen, wenn genau ein Wert genau zwei Mal vorkommt - oder mindestens ein Wert genau zwei Mal - oder genau ein Wert mindestens zwei Mal) und false sonst.","title":"\u00dcbungsbl\u00e4tter (wochenweise)"},{"location":"uebungen/#weitere-ubungsaufgaben-selbstandiges-uben","text":"Hier werden lose und unregelm\u00e4\u00dfig \u00dcbungsaufgaben gesammelt. Am Ende des Semesters soll dann hier eine gro\u00dfe Sammlung von \u00dcbungsaufgaben entstanden sein, die der eigenen Kontrolle dienen sollen. Die \u00dcbungen sind thematisch sortiert, allerdings \u00fcberschneiden sich manche Themen in einigen \u00dcbungen.","title":"Weitere \u00dcbungsaufgaben (selbst\u00e4ndiges \u00dcben)"},{"location":"uebungen/#ausdrucke","text":"gleich 12 Welche der folgenden Ausdr\u00fccke haben den Wert 12? a ) 12 % 13 b ) 24 % 2 c ) 24 /2 d ) 25 /2 Versuchen Sie zun\u00e4chst, die richtige Antwort im Kopf zu ermitteln und erstellen dann ein geeignetes Programm, das Ihnen den jeweiligen Wert des Ausdrucks ausgibt. Pre- und Postoperator Welchen Wert hat die Variable c nach Ausf\u00fchren der Anweisungen? int a = 300 ; int b = a++ ; int c = --b ; Begr\u00fcnden Sie die richtige Antwort! Was passiert durch die Anweisungen?","title":"Ausdr\u00fccke"},{"location":"uebungen/#schleifen","text":"Laufvariablen Welche der Schleifen gibt alle Elemente des Arrays nums aus? Das Array enth\u00e4lt genau 4 Zahlen. a ) for ( int i = 0 ; i < nums.length ; i++ ) { System.out.println ( nums [ i ]) ; } b ) for ( int i = 0 ; i < = 3 ; i++ ) { System.out.println ( nums [ i ]) ; } c ) for ( int i = 1 ; i < = 3 ; i++ ) { System.out.println ( nums [ i ]) ; } d ) for ( int i = 0 ; i < = 3 ; i++ ) { System.out.println ( nums [ 0 ]) ; } e ) for ( int i = nums.length - 1 ; i > = 0 ; i-- ) { System.out.println ( nums [ i ]) ; } Quadratzahl Schreiben Sie eine Methode istQuadratzahl(int zahl) , die ein true zur\u00fcckgibt, wenn zahl eine Quadratzahl ist und ein false sonst. Die Math -Klasse soll nicht verwendet werden. Primzahl Schreiben Sie eine Methode printPrimzahlenBisN(int n) , die alle Primzahlen bis n auf die Konsole ausgibt. Schreiben Sie sich dazu eine Hilfsmethode istPrimzahl(int zahl) , die ein true zur\u00fcckgibt, wenn zahl eine Primzahl ist und ein false , wenn nicht. int-Zahl umdrehen Schreiben Sie eine Methode int reverseInt(int number) , die die \u00fcbergebene number umdreht und die umgedrehte int -Zahl zur\u00fcckgibt, also z.B. aus 1234 wird 4321 . Weitere Beispiele: aus -123 wird -321 und aus 1200 wird 21 . Zahlen raten Schreiben Sie folgendes Programm. Mithilfe von Random \"denkt\" sich das Programm eine Zahl zwischen 0 und 100 aus. Sie k\u00f6nnen \u00fcber die Konsole dann eine Zahl eingeben. Das Programm sagt Ihnen, ob die \"gedachte\" Zahl gr\u00f6\u00dfer oder kleiner als die von Ihnen eingegebene Zahl ist. Sie geben solange eine Zahl ein, bis Sie die \"gedachte\" Zahl erraten haben. Bin\u00e4rzahl Schreiben Sie eine Methode, die eine short -Zahl in eine Bin\u00e4rzahl umwandelt. Diese Bin\u00e4rzahl speichern Sie als long . Z.B. ist 32 bin\u00e4r 100000 , 63 ist 111111 , 48 ist 110000 usw.","title":"Schleifen"},{"location":"uebungen/#arrays","text":"Implementieren Sie eine Methode, die zwei als Parameter \u00fcbergebene sortierte int -Arrays zu einem sortierten int -Array zusammenf\u00fcgt. Geben Sie das neue sortierte Array zur\u00fcck Implementieren Sie eine Methode, die zwei als Parameter \u00fcbergebene unsortierte int -Arrays zu einem sortierten int -Array zusammenf\u00fcgt. Geben Sie das neue sortierte Array zur\u00fcck Implementieren Sie eine Methode int[] explode(int number) . Diese Methode erstellt ein int[] -Array, das wie folgt bef\u00fcllt ist: Bsp. number=5 \u2192 {1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5} . F\u00fcr jede Zahl x gibt es also x Eintr\u00e4ge im Array bis einschlie\u00dflich number","title":"Arrays"},{"location":"uebungen/#wrapper-klassen","text":"Initialisierung einer Long-Variablen Welche Anweisungen initialisieren eine Long-Variable korrekt? a ) Long val = new Long ( 4321 ) ; b ) Long val = 4321L ; c ) Long val = new Long ( \"4321\" ) ; d ) Long val = Long.parseLong ( \"4321\" ) ;","title":"Wrapper-Klassen"},{"location":"uebungen/#vererbung","text":"Sichtbarkeitsmodifizierer Gegeben sind die beiden Klassen - beide sind in verschiedenen Paketen: 1 2 3 public class BaseClass { ??? int a ; } und 1 2 3 4 5 6 7 public class DerivedClass extends BaseClass { private int b ; public int sum () { return a + b ; } } Welche der folgenden Sichtbarkeitsmodifizierer k\u00f6nnen anstelle von ??? eingesetzt werden, damit das Programm compiliert werden kann? a ) protected b ) keiner ( default ) c ) public d ) private","title":"Vererbung"},{"location":"variablen/","text":"Variablen und Datentypen \u00b6 Sowohl in dem euklidischen Algorithmus als auch bei der (3n+1)-Vermutung haben wir mit Zahlen gerechnet. Diese haben wir in Variablen gespeichert. Wir kennen Variablen bereits aus der Mathematik. Dort \"speichern\" wir Werte in diesen Variablen. Das gleiche passiert auch beim Programmieren. Eine Variable kann man sich wie eine Kiste vorstellen, in die genau ein Wert passt. Diese Kiste hat einen Namen (den Namen der Variable) und in der Programmierung wird auch noch gesagt, welche Art von Wert dort hineinpasst. Man spricht auch vom Typ der Variablen oder noch besser vom Datentyp . Eine Variable besteht also aus drei Dingen: dem Wert der Variablen (genau einer) dem Datentyp der Variablen (besteimmt den Wertebereich, also die m\u00f6glichen Werte, die die Variable annehmen kann) dem Namen der Variablen (daf\u00fcr gibt es Regeln, wie solche Bezeichner aussehen d\u00fcrfen) Das Erstellen einer Variablen (die Definition einer Variablen ) besteht in der Programmierung aus zwei Schritten: der Variablendeklaration : in der Deklaration wird festgelegt, wie die Variable hei\u00dft und von welchem Datentyp sie ist der Initialisierung : bei der Initialisierung wird der Variablen ihr erster Wert zugewiesen Damit wir einer Variablen ihren Datentyp zuweisen k\u00f6nnen, m\u00fcssen wir die Datentypen zun\u00e4chst kennenlernen, die eine Variable haben kann. Datentypen in Java \u00b6 In Java gibt es acht sogenannte primitive Datentypen . Wir bezeichnen diese primitiven Datentypen als Wertetypen . Eine Variable von einem Wertetyp kann genau einen Wert annehmen. In folgender Tabelle sind diese Datentypen aufgelistet und ihre jeweilige Bedeutung erkl\u00e4rt. Datentyp Bedeutung int eine Variable vom Datentyp int kann ganzzahlige Werte speichern, also positive und negative ganze Zahlen. Die kleinste Zahl vom Typ int ist -2^31 \"klein\" und die gr\u00f6\u00dfte Zahl vom Typ int ist 2^31-1 gro\u00df. int ist der Standard-Typ f\u00fcr ganze Zahlen in Java. int steht f\u00fcr integer . byte eine Variable vom Datentyp byte kann ebenfalls ganzzahlige Werte speichern, also positive und negative ganze Zahlen. Im Gegensatz zu int ist der Wertebereich aber viel kleiner. Die kleinste byte -Zahl ist -2^7 klein und die gr\u00f6\u00dfte byte -Zahl ist 2^7-1 gro\u00df. short eine Variable vom Datentyp short kann ebenfalls ganzzahlige Werte speichern, also positive und negative ganze Zahlen. Im Gegensatz zu int ist der Wertebereich aber viel kleiner. Im Gegensatz zu byte ist er aber gr\u00f6\u00dfer. Die kleinste short -Zahl ist -2^15 klein und die gr\u00f6\u00dfte short -Zahl ist 2^15-1 gro\u00df. long eine Variable vom Datentyp long kann ebenfalls ganzzahlige Werte speichern, also positive und negative ganze Zahlen. Im Gegensatz zu int ist der Wertebereich aber viel gr\u00f6\u00dfer. long wird immer dann verwendet, wenn der Wertebereich von int nicht ausreicht, also entweder f\u00fcr sehr, sehr kleine oder sehr, sehr gro\u00dfe Zahlen. Die kleinste long -Zahl ist -2^63 klein und die gr\u00f6\u00dfte long -Zahl ist 2^63-1 gro\u00df. char Der Datenyp char steht f\u00fcr character . Mit diesem Datentypen werden einzelne Zeichen gespeichert. Der Datentyp char ist ebenfalls ein ganzzahliger Datentyp, nimmt aber nur positive Werte (aus dem Wertebereich 0 bis 65535 an.) Diese Werte sind Zahlenwerte, die der Codierung eines Zeichens entsprechen, z.B. dem Zeichen 'a' . Ein solches Zeichen steht immer in einfachen Hochkommata '' . boolean Der Datentyp boolean kennt nur genau zwei Werte true und false . Eine Variable vom Datentyp boolean kann also entweder genau true sein oder genau false , nichts anderes. double Der Datentyp double ist in Java der Standard-Datentyp f\u00fcr Gleitkommazahlen (also gebrochene Zahlen mit Komma). Die kleinste und gr\u00f6\u00dfte double -Zahl l\u00e4sst sich nicht genau bestimmen, denn das h\u00e4ngt von der Genauigkeit der Angabe hinter dem Komma ab. Es werden aber 64 bit verwendet, um eine double -Zahl zu speichern. float float ist neben double ein weiterer Datentyp f\u00fcr Gleitkommazahlen. Die Genauigkeit der Speicherung als float ist aber nicht so gro\u00df wie bei double , da float nur 32 bit zur Speicherung einer Zahl zur Verf\u00fcgung hat. Deklaration von Variablen \u00b6 Nun, da wir Datentypen kennen, k\u00f6nnen wir Variablen \"erzeugen\". Das \"Erzeugen\" von Variablen besteht aus zwei Schritten: wir vergeben einen Namen f\u00fcr unsere Variable und wir weisen der Variablen einen Datentyp zu. Dieses Erzeugen von Variablen nennt sich Deklaration (oder Variablendeklaration ). Die allgemine Syntax der Variablendeklaration ist wie folgt: datentyp variablenName ; Wir geben also zuerst den Datentyp an, dann kommt ein Leerschritt, dann den Bezeichner f\u00fcr die Variable (den Namen) und dann folgt ein Semikolon, weil es sich um eine Anweisung handelt. Beispiele: int ganzeZahl ; int number ; long bigNumber ; byte smallNumber ; double nr1 ; float nr2 ; boolean condition ; char character ; F\u00fcr eine Variable wird die Deklaration genau einmal durchgef\u00fchrt. Danach existiert sie und sie kann auch (in Java) nicht ihren Datentypen \u00e4ndern. Noch haben unsere Variablen keine Werte. Das erfolgt erst durch die Initialisierung, also die erste Wertzuweisung. Ehe wir uns das anschauen, \u00fcberlegen wir uns zun\u00e4chst, welche m\u00f6glichen Bezeichner wir f\u00fcr unsere Variablennamen verwenden k\u00f6nnen. Bezeichner \u00b6 Wenn es um Namen geht, die wir in Java selbst vergeben wollen, dann sprechen wir von Bezeichnern . Bezeichner sind nicht nur die Namen von Variablen, sondern sp\u00e4ter auch f\u00fcr Methoden, Klassen, Enumerations, Exceptions und Interfaces. Es gibt einige Regeln f\u00fcr Bezeichner, die wir beachten m\u00fcssen: Bezeichner m\u00fcssen mit einem Java-Buchstaben beginnen Bezeichner setzen sich aus Java-Buchstaben und Java-Zahlen zusammen Java-Buchstaben sind mehr als 'a'-'z' und 'A'-'Z' z.B. auch \u20ac , \u00a3 , \u00a5 , $ , Umlaute \u00e4 , \u00f6 , \u00fc , \u00df sowie Buchstaben mit Apostrophen Aber: wir verwenden nur die normalen Buchstaben 'a'-'z' und 'A'-'Z'!!! Alles andere f\u00fchrt zu Problemen wichtig: keine Leerzeichen, keine reservierten Schl\u00fcsselw\u00f6rter und keine Sonderzeichen, wie z.B. ! , / , * , { , [ , . , ] , } In Java wird Gro\u00df- und Kleinschreibung unterschieden ( case sensitive )! Reservierte Schl\u00fcsselw\u00f6rter sind Begriffe aus dem Java-Sprachumfang (alle kleingeschrieben) 1 . Dazu geh\u00f6ren: abstract assert boolean break byte case catch char class const continue default do double else enum extends final finally float for goto if implements import instanceof int interface long native new package private protected public return short static strictfp super switch synchronized this throw throws transient try void volatile while \u00dcbung Bezeichner Warum sind das keine g\u00fcltigen Bezeichner in Java? 2und2macht4 class Hose gewaschen Hurtig! null Konventionen \u00b6 Wir wissen jetzt, was g\u00fcltige Bezeichner sind und was ung\u00fcltige. Dar\u00fcber hinaus gibt es aber auch Vereinbarungen, die helfen, einen besser verst\u00e4ndlichen und konsistenteren Code zu schreiben: wir vergeben nur \"sprechende\" Namen, d.h. man erkennt bereits am Bezeichner, wozu die Variable dient, z.B. sum , input , checkIfEmpty usw. Variablennamen beginnen stets mit einem Kleinbuchstaben (einzige Ausnahmen sind Konstanten, diese schreiben wir vollst\u00e4ndig gro\u00df, d.h. aus lauter Gro\u00dfbuchstaben) Methodennamen beginnen ebenfalls mit einem Kleinbuchstaben, Klassen und Interfaces beginnen stets mit einem Gro\u00dfbuchstaben verwenden die sogenannte camelCaseSchreibweise . Da keine Leerzeichen erlaubt sind, wir aber sprechende Namen haben wollen, die aus mehreren W\u00f6rtern bestehen k\u00f6nnen, schreiben wir den Beginn eines neuen Wortes immer gro\u00df (au\u00dfer ganz am Anfang, denn Methoden- und Variablennamen beginnen ja mit einem Kleinbuchstaben.) Initialisierung von Variablen \u00b6 Nach der Deklaration einer Variablen existiert diese zwar, sie hat jedoch noch keinen Wert. Wir wollen sicherstellen, dass Variablen immer einen Wert haben. Du weisen wir den Variablen direkt nach der Deklaration einen Wert zu. Die erstmalige Wertzuweisung einer Variablen wird Initialisierung genannt. Der Wertzuweisungsoperator = \u00b6 Um einer Variablen einen Wert zuzuweisen, wird der Wertzuweisungsoperator verwendet. Dieser ist ein eifaches Gleichheitszeichen = . Die Syntax der Wertzuweisung ist wie folgt: variablenName = wert ; Auf der linken Seite steht also immer die Variable und auf der rechten Seite der Wert. Auch hier muss am Ende wieder zwingend das Seikolon stehen, denn es handelt sich um eine Anweisung. Wichtig ist, dass der Wert dem Datentyp der Variablen entspricht! Wir geben einige Beispiele f\u00fcr Variablen an, die wir oben deklariert hatten: ganzeZahl = 5 ; // int number = - 1234 ; // int bigNumber = 12345678 ; // long nr1 = 6.54321 ; // double condition = true ; // boolean character = 'a' ; // char Nachdem einer Zahl mithilfe des Wertzuweisungsoperators ein Wert zugewiesen wurde, beh\u00e4lt die Variable den Wert so lange bis ihr ein neuer Wert (mithilfe des Wertzuweisungsoperators) zugewiesen wird. Einer Variablen kann beliebig oft ein neuer Wert zugewiesen werden. Deklaration und Initialisierung in einem Schritt \u00b6 Da wir m\u00f6chten, dass eine Variable sofort nach ihrer Deklaration einen Wert zugewiesen bekommt, ist es \u00fcblich, die Deklaration und die Initialisierung in einem Schritt, d.h. durch eine Anweisung durchzuf\u00fchren. Die Syntax der kombinierten Anweisung (Deklaration und INitialisierung) ist wie folgt: datentyp variablenName = wert ; Wir zeigen die Anwendung der kombinierten Deklaration und Initialisierung anhand der bereits verwendeten Beispiele: int ganzeZahl = 5 ; int number = - 1234 ; long bigNumber = 12345678 ; double nr1 = 6.54321 ; boolean condition = true ; char character = 'a' ; Beachte Wie bereits erw\u00e4hnt, kann eine Variable genau ein Mal deklariert, ihr aber beliebig oft ein neuer Wert zugewiesen werden. Angenommen, Sie wollen der Variablen ganzeZahl einen neuen Wert zuweisen, dann schreiben Sie die Anweisung ganzeZahl = 6; . Sie d\u00fcrfen auf keinen Fall int ganzeZahl = 6; schreiben, denn dann w\u00fcrden Sie ja versuchen, die Variable ganzeZahl erneut zu deklarieren. Diese existiert aber bereits. Sie bekommen einen Compilerfehler und k\u00f6nnen ihr Programm gar nicht erst \u00fcbersetzen. Details zu primitiven Datentypen (Wertetypen) \u00b6 Wie wir bereits bei der Vorstellung der primitiven Datentypen erw\u00e4hnt haben, ist f\u00fcr jeden Datentyp eine gewisse Speichergr\u00f6\u00dfe reserviert. Hier noch einmal die Gr\u00f6\u00dfe der primitiven Datentypen: Datentyp Gr\u00f6\u00dfe Wertebereich boolean 1 Byte 2 true / false char 16 bit 0 ... 65.535 (z.B. 'A' ) byte 8 bit -128 ... 127 short 16 bit -32.768 ... 32.767 int 32 bit -2.147.483.648 ... 2.147.483.647 long 64 bit -2^63 ... 2^63-1 float 32 bit +/-1,4E-45 ... +/-3,4E+38 double 64 bit +/-4,9E-324 ... +/-1,7E+308 Wir schauen uns jetzt noch einige interssante Details zu den Datentypen an. Ganzzahlige Datentypen int , long , short , byte \u00b6 Eine ganze Zahl in einem Java-Programm ist vom Typ int . Dieser Datentyp ist der Standard-Datentyp f\u00fcr ganze Zahlen. Ganze Zahlen werden intern im sogenannten Zweierkomplement dargestellt. Wir schauen uns diese Darstellung am Beispiel des Datentyps byte (der 8 bit gro\u00df ist) einmal genauer an. In der folgenden Darstellung steht die Bedeutung der Position der einzelnen bits ganz oben, beginnend mit der 1 ( 2^0 ) auf der rechten Seite (\"kleinstes\" bit) bis hin zu 2^7 auf der linken Seite (\"gr\u00f6\u00dftest\" bit). Beim Zweierkomplement entspricht diese h\u00f6chste Position jedoch nicht der 128 , sondern der -128 . Dies hat drei Vorteile es wird nicht ein ganzes bit daf\u00fcr verwendet, um zu unterscheiden, ob es sich um eine positive oder negative Zahl handelt die 0 kommt nicht 2x vor ( 1000 0000 und 0000 0000 w\u00e4re jeweils 0 , wenn das f\u00fchrende bit dar\u00fcber entscheiden w\u00fcrde, ob die Zahl positiv oder negativ ist) sowohl die Addition als auch die Subtraktion geht einfacher Die Abbildung zeigt in den oberen drei Zeilen die interne Darstellung von -128 , 127 und 0 . In den drei Zeilen darunter ist dargestellt, wie z.B. die Zahlen 85 , -43 und -85 als Zweierkomplement repr\u00e4sentiert werden. Die folgende Abbildung zeigt die Addition (und somit auch die Subtraktion) zweier Zahlen im Zweierkomplement. Dargestellt sidn die Repr\u00e4sentationen von -4 und 3 als Zweierkomplement. Es wird die Addition der beiden Zahlen gezeigt. Da die Werte alle einen begrenzten Wertebereich haben, kann es zu einem Wertebereichs\u00fcberlauf kommen. Ein solcher \u00dcberlauf ist in der folgenden Abbildung dargestellt. Im Datentyp byte ist 127 die gr\u00f6\u00dfte positive Zahl. Die Abbildung verdeutlicht, was passiert, wenn zu dieser gr\u00f6\u00dften Zahl eine 1 hinzuaddiert wird. Beachten Sie, dass ein solcher \u00dcberlauf unbemerkt passiert. Das bedeutet, dass Sie weder einen Fehler noch eine Warnung erhalten. Sie m\u00fcssen sich also immer gut \u00fcberlegen, ob ein solcher \u00dcberlauf bei Ihren Werten passieren kann. Wenn ja, dann sollten Sie zum n\u00e4chstgr\u00f6\u00dferen Datentypen wechseln, also z.B. von int nach long . Datentyp gr\u00f6\u00dfter Wert kleinster Wert byte 127 -128 short 32.767 -32.768 int 2.147.483.647 -2.147.483.648 long 9.223.372.036.854.775.807 -9.223.372.036.854.775.808 \u00dcbung Zweierkomplement Warum ist 1111 1111 als Zweierkomplement im Datentyp byte die Dezimalzahl -1 ? Wie ist die Repr\u00e4sentation der Zahlen -99 und 99 als Zweierkomplement im Datentyp byte ? Was ist das Ergebnis der Rechnung 2.147.483.647 + 1 im Datentyp int und warum? Initialisierung von long -Variablen. \u00b6 Eine ganze Zahl als Literal , also als alleinstehender Wert ist vom Typ int . Wenn wir folgende kombinierte Deklaration und INitialisierung betrachten: long bigNumber = 12345678 ; dann stellen wir fest, dass die Variable bigNumber auf der linken Seite des Wertzuweisungsoperators vom Typ long ist, die Zahl 12345678 aber vom Typ int . Wir werden sp\u00e4ter noch auf solche Typkonvertierung zu sprechen kommen. Es sei hier jedoch bereits angemerkt, dass man eine ganze Zahl auch um das Postfix L erg\u00e4nzen kann 3 - mit der Wirkung, dass die Zahl dann nicht mehr vom Typ int , sondern vom Typ long ist. Die \"richtige\" Initialisierung sieht so aus: long bigNumber = 12345678L ; Es ist nur in wenigen F\u00e4llen wirklich erforderlich, das L an die Zahl zu h\u00e4ngen, wenn wir eine long -Variable initialisieren. Warum das so ist, werden wir kennenlernen, wenn wir uns \u00fcber * Typkonvertierung* Gedanken machen. Trotzdem sei hier schonmal erw\u00e4hnt, dass diese Deklaration und Initailisierung kein Problem ist long bigNumber = 2147483647 ; aber hier bekommen wir einen Fehler und k\u00f6nnen das Programm gar nicht \u00fcbersetzen: long bigNumber = 2147483648 ; Warum k\u00f6nnte das wohl so sein? Wenn wir es \"richtig\" machen, also mit angeh\u00e4ngtem L , dann ist auch wieder alles in Ordnung und das Programm l\u00e4sst sich compilieren: long bigNumber = 2147483648L ; In unseren Programmen werden wir zu 99% den Datentyp int f\u00fcr ganzzahlige Werte verwenden und zu 1% long . Die anderen ganzzahligen Datentypen byte und short braucht man eigentlich gar nicht mehr, da wir keinen Wert mehr darauf legen m\u00fcssen, Arbeitsspeicher zu sparen. char \u00b6 Der Datentyp char ist f\u00fcr das Speichern von Zeichen vorgesehen. Es handelt sich um einen ganzzahligen Datentypen. Mit den ersten Computern stellte sich die Frage, wie Zeichen (also Ziffern und Buchstaben) intern codiert werden k\u00f6nnen. Es hat sich dann zun\u00e4chst die Zeichencodierung des American Standard Code for Information Interchange (ASCII) durchgesetzt, bei der 7 Bit (=128 Zeichen) dazu verwendet wurden, die wichtigsten Zeichen zu kodieren. Neben einigen Steuerzeichen (die ersten 33 \"Zeichen\", z.B. Zeilenvorschub, ESC -Zeichen) wurden z.B. folgende Zeichen wie folgt kodiert: Dezimalzahl Zeichen Dezimalzahl Zeichen Dezimalzahl Zeichen 33 ! 47 / 61 = 34 \"\" 48 0 62 > 35 # 49 1 63 ? 36 $ 50 2 64 @ 37 % 51 3 65 A 38 & 52 4 66 B 39 ' 53 5 67 C 40 ( 54 6 68 D 41 ) 55 7 69 E 42 * 56 8 70 F 43 + 57 9 71 G 44 , 58 : 72 H 45 - 59 ; 73 I 46 . 60 < 74 J Dezimalzahl Zeichen Dezimalzahl Zeichen Dezimalzahl Zeichen 75 K 89 Y 103 g 76 L 90 Z 104 h 77 M 91 [ 105 i 78 N 92 \\ 106 j 79 O 93 ] 107 k 80 P 94 ^ 108 l 81 Q 95 _ 109 m 82 R 96 ``` 110 n 83 S 97 a 111 o 84 T 98 b 112 p 85 U 99 c 113 q 86 V 100 d 114 r 87 W 101 e 115 s 88 X 102 f 116 t Dezimalzahl Zeichen Dezimalzahl Zeichen Dezimalzahl Zeichen 117 u 121 y 125 } 118 v 122 z 126 ~ 119 w 123 { 127 DEL 120 x 124 | Diese Zeichenkodierung erkl\u00e4rt, warum es sich bei char um einen ganzzahligen Typ handelt. Anstelle eines Zeichens, welches immer in einfachen Hochkommata '' angegeben werden muss, kann auch der ASCII-Code als Zahl verwendet werden. Folgende Beispiele zeigen dies: char ganzzahliger Typ char c1 = 'a' ; System . out . println ( c1 ); // a char c2 = 97 ; System . out . println ( c2 ); // a char c3 = '`' ; c3 ++ ; System . out . println ( c3 ); // a Die 128 verschiedenen Zeichen gen\u00fcgten nat\u00fcrlich schnell nicht mehr und es wurden deutlich gr\u00f6\u00dfere Kodierungstabellen entwickelt. Ein de-facto Standard ist UTF-8 , welcher Bytes (also 8 Bit) zur Kodierung der Zeichen verwendet. Die ersten 128 Zeichen sind dabei mit dem ASCII-Code identisch. Im UTF-8 k\u00f6nnen aber mehrere Bytes hintereinander geschrieben werden und erm\u00f6glichen so einen beliebig gro\u00dfen Kodierungsraum. Der Datentyp char ist 16 Bit gro\u00df, kann also 2 Byte gro\u00dfe Kodierungsr\u00e4ume darstellen (65 536 verschiedene Zeichen). Eine UTF-8-Tabelle finden Sie z.B. hier . Die linke Spalte in dieser Tabelle zeigt den Unicode . Dieser kann auch in Java (in leicht abgewandelter Form) verwendet werden. Scrollen Sie in der Tabelle ein wenig bis zur Position U+00A9 herunter. Dort sehen Sie z.B. die Codierung des \u00a9-Copyright-Zeichens. In Java kann dieser Code wie folgt verwendet werden: char UTF-8 Zeichen char u1 = '\\u00a9' ; System . out . println ( u1 ); // copyright-Zeichen char u2 = '\\u00b0' ; System . out . println ( u2 ); // Grad-Zeichen char u3 = '\\u00bd' ; System . out . println ( u3 ); // 1/2-Zeichen Gleitkomma-Datentypen double , float \u00b6 Eine Gleitkomma-Zahl (also eine Zahl mit einem Punkt, z.B. 5.0 oder -1.2345 ) in einem Java-Programm ist vom Typ double . Dieser Datentyp ist der Standard-Datentyp f\u00fcr Gleitkomma-Zahlen. Der Wertebereich der Datentypen double und float l\u00e4sst sich nicht so leicht angeben, denn entweder wird relativ viel \"Speicher\" f\u00fcr die Genauigkeit verwendet (f\u00fcr die Anzahl der Nachkommastellen, z.B. 0.123456789 ) oder f\u00fcr die Vorkommastellen (z.B. 987654321.0 ). Generell ist der Wertebereich (die Genauigkeit) bei double viel h\u00f6her, denn f\u00fcr eine Variable vom Typ double werden 64 bit reserviert, w\u00e4hrend eine Variable vom Typ float nur 32 bit gro\u00df ist. Bei float beschr\u00e4nkt sich die Genauigkeit auf ca. 7 signifikante Stellen (Nachkommastellen), w\u00e4hrend es bei double ca. 17 signifikante Stellen sind. Beispiel float float floatNumber = 1.0f / 3.0f ; System . out . println ( floatNumber ); // 0.33333334 Im obigen Beispiel wird mithilfe von float der Bruch 1/3 ausgerechnet. Zwei Sachen sind zu beachten Wie wir das schon beim Datentyp long gesehen haben, gibt es auch f\u00fcr Gleitkommazahlen ein Postfix, hier f , um zu sagen, dass eine Zahl vom Typ float sein soll. Ohne das f w\u00e4re sie vom Typ double und wir w\u00fcrden sogar einen Compilerfehler erhalten, wenn wir das f am Ende der Zahl nicht angeben w\u00fcrden. Hier ist es also wichtig, bei der Wertzuweisung anzugeben, dass die Zahl vom Typ float sein soll - n\u00e4mlcih durch die Angabe von f ( F ginge auch). Die Genauigkeit bei float ist nicht sehr hoch. 1/3 im float -Wertebereich ergibt 0.33333334 . Schauen wir uns das gleiche Beispiel mit double an: Beispiel float double doubleNumber = 1.0 / 3.0 ; System . out . println ( doubleNumber ); // 0.3333333333333333 Erstens hat der double -Wert deutlich mehr Nachkommastellen (16 statt 8 bei float ) und zweitens ist der Wert somit korrekter. Die Speicherung von Gleikommazahlen erfolgt nach IEEE 754 - Standard . Wir merken uns: wir sollten float eher nicht verwenden, wenn wir Wert auf Genauigkeit legen, wenn wir float verwenden, dann m\u00fcssen wir beim Initialisieren und bei allen Wertezuweisungen darauf achten, dass wir an die Gleikommazahl ein f anh\u00e4ngen, da es sich ansonsten um eine Gleitkommazahl vom Typ double handelt, double ist der Standardtyp f\u00fcr Gleikommazahlen und wenn eine Gleitkommazahl im Programmcode vorkommt, dann handelt es sich um eine Zahl vom Typ double . Datentyp gr\u00f6\u00dfter positiver Wert kleinster positiver Wert float ~3.4028234663852886E+038 ~1.4012984643248171E-045 double ~1.7976931348623157E+308 ~4.9406564584124654E-324 Der Datentyp String \u00b6 Der Datentyp String ist kein primitiver Datentyp (kein Wertetyp), sondern ein sogenannter komplexer Datentyp (oder, wie wir sagen Referenztyp ). Wir erkennen das bereits daran, dass der Datentyp mit einem Gro\u00dfbuchstaben beginnt. Der Unterschied zwischen Variablen von einem Wertetypen und Variablen von Referenztypen ist der, dass die ersten \"nur\" Werte speichern ( 3 , 5 , 'a' , 123.45 , true , ...) und die anderen speichern Objekte (oder richtiger: Referenzen auf Objekte) - darum k\u00fcmmern wir uns sp\u00e4ter sehr ausf\u00fchrlich. Wir k\u00f6nnen uns merken (ist aber derzeit noch nicht wichtig), dass ein String ein Objekt und kein einfacher Wert ist, aber derzeit betrachten wir den Datentyp String wie die primitiven Wertetypen auch. Ein String -Literal erkennt man an den doppelten Anf\u00fchrungsstrichen. Darin kann ein beliebiger Text (bestehend aus allen m\u00f6glichen Zeichen, Buchstaben, Sonderzeichen, Umlauten etc.) stehen, z.B. \"Hallo FIW!\" , \"2und2gleich4 und $ % & 0? | \\ !\" , \" \u00e4 \u00fc \u00f6 \u00df . Die Deklaration und Initialisierung einer String -Variablen sieht also so aus: String s1 = \"Informatik\" ; Auch f\u00fcr den Datentyp String gibt es einen Operator, der zwei Strings miteinander verbindet. Er wird Konkatenation ( String-Konkatenation oder Zeichenkettenverbindungsoperator genannt). Das Operatorsymbol der Konkatenation ist in Java + . String s1 = \"Informatik\" + \" und\" + \" Wirtschaft\" ; System . out . println ( s1 ); Die folgenden drei Ausgaben sind alle gleich: String s1 = \"Informatik\" + \" und\" + \" Wirtschaft\" ; System . out . println ( s1 ); // Informatik und Wirtschaft String s2 = \"Informatik\" ; String s3 = \" und\" ; String s4 = \" Wirtschaft\" ; System . out . println ( s2 + s3 + s4 ); // Informatik und Wirtschaft String s5 = \"Informatik\" ; String s6 = s5 + \" und\" ; String s7 = s6 + \" Wirtschaft\" ; System . out . println ( s7 ); //Informatik und Wirtschaft Doppelte Bedeutung des Operatorzeichens + \u00b6 Das + wird sowohl als arithmetischer Operator f\u00fcr numerische Datentypen als auch als Konkatenation f\u00fcr Strings verwendet. In den obigen Beispielen kommen wir damit nicht durcheinander, da v\u00f6llig klar ist, dass es sich dabei um die Konkatenation handelt. Es gibt aber Beispiele, bei denen in einem Ausdruck beide Bedeutungen vorkommen. Diese diskutieren wir jetzt. Zun\u00e4chst schauen wir uns noch eine Typische Verendung der Konkatenation an: typisches Beispiel f\u00fcr die Konkatenation 1 2 3 4 int summand1 = 3 ; int summand2 = 4 ; int summe = summand1 + summand2 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summe ); // 3 + 4 = 7 Die Ausgabe bei dem obigen Beispiel ist 3 + 4 = 7 . Schauen wir uns das Beispiel genauer an: In Zeile 3 wird das + eindeutig als arithmetischer Operator verwendet, denn es steht zwischen zwei numerischen Werten ( summand1 und summand2 sind jeweils vom Typ int ) In Zeile 4 kommt + mehrmals vor. Der Ausdruck in den runden Klammern von println() wird von links nach rechts aufgel\u00f6st: Das Literal \" + \" ist ein String. Hier ist + gar kein Operator, sondern nur ein Zeichen. Das + in summand1 + \" + \" ist die Konkatenation. Das liegt daran, dass einer der beiden Operanden, die das + verbindet, vom Typ String ist. Intern wird der Wert von summand1 ( die 3 ) zu einem String und dieser wird mit \" + \" verbunden. Es entsteht ein String \"3 + \" . Das bedeutet, dass das n\u00e4chste + in dem Ausdruck \"3 + \" + summand2 enthalten ist und auch hier die Bedeutung der Konkatenation hat, denn einer der beiden Operanden (der erste) ist vom Typ String . Intern wird der Wert von summand2 ( die 4 ) zu einem String und dieser wird mit \"3 + \" verbunden. Es entsteht ein String \"3 + 4\" . Das bedeutet, dass das n\u00e4chste + in dem Ausdruck \"3 + 4\" + \" = \" enthalten ist und auch hier die Bedeutung der Konkatenation hat, denn beide Operanden (der erste und der zweite) sind vom Typ String . Es entsteht der String \"3 + 4 = \" . Das letzte + steht also in dem Ausdruck \"3 + 4 = \" + summe . Auch hier handelt es sich wieder um die Konkatenation, da einer der beiden Operanden (der erste) vom Typ String ist. Intern wird der Wert von summe ( die 7 ) zu einem String und dieser wird mit \"3 + 4 = \" verbunden. Es entsteht ein String \"3 + 4 = 7\" . Dieser String wird ausgegegeben. 1. \u00dcbung Doppelte Bedeutung von + Angenommen, in dem obigen Beispiel wollen Sie die Summe der beiden Summanden nicht erst in einer Variablen zwischenspeichern, sondern gleich ausgeben. Sie schreiben deshalb folgendes Programm: int summand1 = 3 ; int summand2 = 4 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summand1 + summand2 ); Sie erhalten jedoch nicht die gew\u00fcnschte Ausgabe. Warum nicht? Wie k\u00f6nnen Sie doch die Summe ausgeben, ohne diese zwischenspeichern zu m\u00fcssen? Success Wir k\u00f6nnen nun Variablen deklarieren und initialisieren. Wir kennen alle acht primitiven Datentypen. Wir nennen diese Datentypen Wertetypen . Wir wissen, dass eine ganze Zahl im Java-Programm vom Typ int ist und eine Gleikommazahl vom Typ double . Wir kennen die interne Darstellung von ganzen Zahlen und wir wissen \u00fcber die Kodierung von Zeichen Bescheid. Der datentyp char ist ein ganzzahliger Typ, obwohl er f\u00fcr das Speichern von Zeichen zust\u00e4ndig ist. Dies liegt an der Kodierung der Zeichen als ganze Zahlen. Der Wertzuweisungsoperator ist = . Wenn einer Variablen ein Wert zugewiesen werden soll, dann muss die Variablen links stehen, der Wertuweisungsoperator in der Mitte und rechts der Wert. Konstanten \u00b6 Wir haben gesagt, dass Variablen beliebig oft einer neuer Wert zugewisen werden kann. Manchmal m\u00f6chte man aber genau das nicht. Sogenannten Konstanten m\u00f6chte man genau einmal einen Wert zuweisen und dann soll dieser Wert nicht mehr \u00fcberschrieben werden k\u00f6nnen. In Java kann man solche Konstanten mithilfe des Schl\u00fcsselwortes final deklarieren: final datentyp KONSTANTE = Wert; Eine Konstante wird zun\u00e4chst wie eine Variable deklariert, d.h. man vergibt einen Namen f\u00fcr die Variable und weist ihr einen Datentyp zu. Au\u00dferdem wird ihr mithilfe des Zuweisungsoperators ein Wert zugewiesen. Um zu verhindern, dass dieser Variablen erneut ein Wert zugewiesen kann, setzt man vor den Datentyp noch das Schl\u00fcsselwort final . Damit ist diese Variable schreibgesch\u00fctzt und es kann ihr nie wieder ein neuer Wert zugewiesen werden. Schauen wir uns ein Beispiel an: final double PI = 3.14159265359 ; Es wird eine Konstante PI deklariert und ihr der Wert 3.14159265359 zugewiesen. Damit wir Konstanten von \"normalen\" Variablen unterscheiden k\u00f6nnen, schreiben wir Konstenten immer gro\u00df . Wenn der Name einer Konstanten aus mehreren W\u00f6rtern besteht, verwendet man typischerweise den Unterstrich _ zum Verbinden der beiden W\u00f6rter, z.B. final int NOT_FOUND = - 1 ; final int MIN_VALUE = - 2147483648 ; final int MAX_VALUE = 2147483647 ; final char DEGREE_SYMBOL = '\\u00b0' ; final char DEGREE_CELSIUS = '\\u2103' ; final char DEGREE_FAHRENHEIT = '\\u2109' ; Ansonsten k\u00f6nnen Sie Konstanten ganz normal verwenden, aber immer nur lesend, also z.B. double area = PI * 25.0 ; System . out . println ( area ); System . out . println ( DEGREE_FAHRENHEIT ); System . out . println ( DEGREE_CELSIUS ); String fahrenheit = \"F\" + DEGREE_SYMBOL ; System . out . println ( fahrenheit ); ergibt folgende Ausgabe: 78 .53981633975 \u2109 \u2103 F\u00b0 Wenn Sie in Ihrem Programm versuchen, einer Konstanten einen neuen Wert zuzuweisen, erhalten Sie einen Fehler ( The final variable cannot be assigned ) und Sie k\u00f6nnen das Programm gar nicht erst compilieren. Wann immer Sie in Ihrem Programm ein Literal verwenden, also einen Wert, sollten Sie \u00fcberlegen, ob Sie diesem Wert nicht besser einen Namen geben k\u00f6nnen, n\u00e4mlich daf\u00fcr eine Konstante verwenden, und dann stets die Konstante anstelle des Wertes verwenden. Damit werden sogenannte magic numbers vermieden und das Programm ist lesbarer. const und goto geh\u00f6ren eigentlich gar nicht zum Sprachumfang von Java und sind aber trotzdem reservierte Schl\u00fcsselw\u00f6rter. \u21a9 Tats\u00e4chlich ist die Gr\u00f6\u00dfe eines boolean gar nicht genau definiert (siehe hier ). man braucht ja eigentlich nur ein bit. Man liest aber sehr h\u00e4ufig davon, dass einer Variablen vom Typ boolean ein ganzes Byte reserviert wird. \u21a9 Man k\u00f6nnte auch nit dem kleinen Buchstaben l erg\u00e4nzen, das macht man aber nicht, weil die Verwechselungsgefahr mit der 1 zu gro\u00df ist. \u21a9","title":"Variablen"},{"location":"variablen/#variablen-und-datentypen","text":"Sowohl in dem euklidischen Algorithmus als auch bei der (3n+1)-Vermutung haben wir mit Zahlen gerechnet. Diese haben wir in Variablen gespeichert. Wir kennen Variablen bereits aus der Mathematik. Dort \"speichern\" wir Werte in diesen Variablen. Das gleiche passiert auch beim Programmieren. Eine Variable kann man sich wie eine Kiste vorstellen, in die genau ein Wert passt. Diese Kiste hat einen Namen (den Namen der Variable) und in der Programmierung wird auch noch gesagt, welche Art von Wert dort hineinpasst. Man spricht auch vom Typ der Variablen oder noch besser vom Datentyp . Eine Variable besteht also aus drei Dingen: dem Wert der Variablen (genau einer) dem Datentyp der Variablen (besteimmt den Wertebereich, also die m\u00f6glichen Werte, die die Variable annehmen kann) dem Namen der Variablen (daf\u00fcr gibt es Regeln, wie solche Bezeichner aussehen d\u00fcrfen) Das Erstellen einer Variablen (die Definition einer Variablen ) besteht in der Programmierung aus zwei Schritten: der Variablendeklaration : in der Deklaration wird festgelegt, wie die Variable hei\u00dft und von welchem Datentyp sie ist der Initialisierung : bei der Initialisierung wird der Variablen ihr erster Wert zugewiesen Damit wir einer Variablen ihren Datentyp zuweisen k\u00f6nnen, m\u00fcssen wir die Datentypen zun\u00e4chst kennenlernen, die eine Variable haben kann.","title":"Variablen und Datentypen"},{"location":"variablen/#datentypen-in-java","text":"In Java gibt es acht sogenannte primitive Datentypen . Wir bezeichnen diese primitiven Datentypen als Wertetypen . Eine Variable von einem Wertetyp kann genau einen Wert annehmen. In folgender Tabelle sind diese Datentypen aufgelistet und ihre jeweilige Bedeutung erkl\u00e4rt. Datentyp Bedeutung int eine Variable vom Datentyp int kann ganzzahlige Werte speichern, also positive und negative ganze Zahlen. Die kleinste Zahl vom Typ int ist -2^31 \"klein\" und die gr\u00f6\u00dfte Zahl vom Typ int ist 2^31-1 gro\u00df. int ist der Standard-Typ f\u00fcr ganze Zahlen in Java. int steht f\u00fcr integer . byte eine Variable vom Datentyp byte kann ebenfalls ganzzahlige Werte speichern, also positive und negative ganze Zahlen. Im Gegensatz zu int ist der Wertebereich aber viel kleiner. Die kleinste byte -Zahl ist -2^7 klein und die gr\u00f6\u00dfte byte -Zahl ist 2^7-1 gro\u00df. short eine Variable vom Datentyp short kann ebenfalls ganzzahlige Werte speichern, also positive und negative ganze Zahlen. Im Gegensatz zu int ist der Wertebereich aber viel kleiner. Im Gegensatz zu byte ist er aber gr\u00f6\u00dfer. Die kleinste short -Zahl ist -2^15 klein und die gr\u00f6\u00dfte short -Zahl ist 2^15-1 gro\u00df. long eine Variable vom Datentyp long kann ebenfalls ganzzahlige Werte speichern, also positive und negative ganze Zahlen. Im Gegensatz zu int ist der Wertebereich aber viel gr\u00f6\u00dfer. long wird immer dann verwendet, wenn der Wertebereich von int nicht ausreicht, also entweder f\u00fcr sehr, sehr kleine oder sehr, sehr gro\u00dfe Zahlen. Die kleinste long -Zahl ist -2^63 klein und die gr\u00f6\u00dfte long -Zahl ist 2^63-1 gro\u00df. char Der Datenyp char steht f\u00fcr character . Mit diesem Datentypen werden einzelne Zeichen gespeichert. Der Datentyp char ist ebenfalls ein ganzzahliger Datentyp, nimmt aber nur positive Werte (aus dem Wertebereich 0 bis 65535 an.) Diese Werte sind Zahlenwerte, die der Codierung eines Zeichens entsprechen, z.B. dem Zeichen 'a' . Ein solches Zeichen steht immer in einfachen Hochkommata '' . boolean Der Datentyp boolean kennt nur genau zwei Werte true und false . Eine Variable vom Datentyp boolean kann also entweder genau true sein oder genau false , nichts anderes. double Der Datentyp double ist in Java der Standard-Datentyp f\u00fcr Gleitkommazahlen (also gebrochene Zahlen mit Komma). Die kleinste und gr\u00f6\u00dfte double -Zahl l\u00e4sst sich nicht genau bestimmen, denn das h\u00e4ngt von der Genauigkeit der Angabe hinter dem Komma ab. Es werden aber 64 bit verwendet, um eine double -Zahl zu speichern. float float ist neben double ein weiterer Datentyp f\u00fcr Gleitkommazahlen. Die Genauigkeit der Speicherung als float ist aber nicht so gro\u00df wie bei double , da float nur 32 bit zur Speicherung einer Zahl zur Verf\u00fcgung hat.","title":"Datentypen in Java"},{"location":"variablen/#deklaration-von-variablen","text":"Nun, da wir Datentypen kennen, k\u00f6nnen wir Variablen \"erzeugen\". Das \"Erzeugen\" von Variablen besteht aus zwei Schritten: wir vergeben einen Namen f\u00fcr unsere Variable und wir weisen der Variablen einen Datentyp zu. Dieses Erzeugen von Variablen nennt sich Deklaration (oder Variablendeklaration ). Die allgemine Syntax der Variablendeklaration ist wie folgt: datentyp variablenName ; Wir geben also zuerst den Datentyp an, dann kommt ein Leerschritt, dann den Bezeichner f\u00fcr die Variable (den Namen) und dann folgt ein Semikolon, weil es sich um eine Anweisung handelt. Beispiele: int ganzeZahl ; int number ; long bigNumber ; byte smallNumber ; double nr1 ; float nr2 ; boolean condition ; char character ; F\u00fcr eine Variable wird die Deklaration genau einmal durchgef\u00fchrt. Danach existiert sie und sie kann auch (in Java) nicht ihren Datentypen \u00e4ndern. Noch haben unsere Variablen keine Werte. Das erfolgt erst durch die Initialisierung, also die erste Wertzuweisung. Ehe wir uns das anschauen, \u00fcberlegen wir uns zun\u00e4chst, welche m\u00f6glichen Bezeichner wir f\u00fcr unsere Variablennamen verwenden k\u00f6nnen.","title":"Deklaration von Variablen"},{"location":"variablen/#bezeichner","text":"Wenn es um Namen geht, die wir in Java selbst vergeben wollen, dann sprechen wir von Bezeichnern . Bezeichner sind nicht nur die Namen von Variablen, sondern sp\u00e4ter auch f\u00fcr Methoden, Klassen, Enumerations, Exceptions und Interfaces. Es gibt einige Regeln f\u00fcr Bezeichner, die wir beachten m\u00fcssen: Bezeichner m\u00fcssen mit einem Java-Buchstaben beginnen Bezeichner setzen sich aus Java-Buchstaben und Java-Zahlen zusammen Java-Buchstaben sind mehr als 'a'-'z' und 'A'-'Z' z.B. auch \u20ac , \u00a3 , \u00a5 , $ , Umlaute \u00e4 , \u00f6 , \u00fc , \u00df sowie Buchstaben mit Apostrophen Aber: wir verwenden nur die normalen Buchstaben 'a'-'z' und 'A'-'Z'!!! Alles andere f\u00fchrt zu Problemen wichtig: keine Leerzeichen, keine reservierten Schl\u00fcsselw\u00f6rter und keine Sonderzeichen, wie z.B. ! , / , * , { , [ , . , ] , } In Java wird Gro\u00df- und Kleinschreibung unterschieden ( case sensitive )! Reservierte Schl\u00fcsselw\u00f6rter sind Begriffe aus dem Java-Sprachumfang (alle kleingeschrieben) 1 . Dazu geh\u00f6ren: abstract assert boolean break byte case catch char class const continue default do double else enum extends final finally float for goto if implements import instanceof int interface long native new package private protected public return short static strictfp super switch synchronized this throw throws transient try void volatile while \u00dcbung Bezeichner Warum sind das keine g\u00fcltigen Bezeichner in Java? 2und2macht4 class Hose gewaschen Hurtig! null","title":"Bezeichner"},{"location":"variablen/#konventionen","text":"Wir wissen jetzt, was g\u00fcltige Bezeichner sind und was ung\u00fcltige. Dar\u00fcber hinaus gibt es aber auch Vereinbarungen, die helfen, einen besser verst\u00e4ndlichen und konsistenteren Code zu schreiben: wir vergeben nur \"sprechende\" Namen, d.h. man erkennt bereits am Bezeichner, wozu die Variable dient, z.B. sum , input , checkIfEmpty usw. Variablennamen beginnen stets mit einem Kleinbuchstaben (einzige Ausnahmen sind Konstanten, diese schreiben wir vollst\u00e4ndig gro\u00df, d.h. aus lauter Gro\u00dfbuchstaben) Methodennamen beginnen ebenfalls mit einem Kleinbuchstaben, Klassen und Interfaces beginnen stets mit einem Gro\u00dfbuchstaben verwenden die sogenannte camelCaseSchreibweise . Da keine Leerzeichen erlaubt sind, wir aber sprechende Namen haben wollen, die aus mehreren W\u00f6rtern bestehen k\u00f6nnen, schreiben wir den Beginn eines neuen Wortes immer gro\u00df (au\u00dfer ganz am Anfang, denn Methoden- und Variablennamen beginnen ja mit einem Kleinbuchstaben.)","title":"Konventionen"},{"location":"variablen/#initialisierung-von-variablen","text":"Nach der Deklaration einer Variablen existiert diese zwar, sie hat jedoch noch keinen Wert. Wir wollen sicherstellen, dass Variablen immer einen Wert haben. Du weisen wir den Variablen direkt nach der Deklaration einen Wert zu. Die erstmalige Wertzuweisung einer Variablen wird Initialisierung genannt.","title":"Initialisierung von Variablen"},{"location":"variablen/#der-wertzuweisungsoperator","text":"Um einer Variablen einen Wert zuzuweisen, wird der Wertzuweisungsoperator verwendet. Dieser ist ein eifaches Gleichheitszeichen = . Die Syntax der Wertzuweisung ist wie folgt: variablenName = wert ; Auf der linken Seite steht also immer die Variable und auf der rechten Seite der Wert. Auch hier muss am Ende wieder zwingend das Seikolon stehen, denn es handelt sich um eine Anweisung. Wichtig ist, dass der Wert dem Datentyp der Variablen entspricht! Wir geben einige Beispiele f\u00fcr Variablen an, die wir oben deklariert hatten: ganzeZahl = 5 ; // int number = - 1234 ; // int bigNumber = 12345678 ; // long nr1 = 6.54321 ; // double condition = true ; // boolean character = 'a' ; // char Nachdem einer Zahl mithilfe des Wertzuweisungsoperators ein Wert zugewiesen wurde, beh\u00e4lt die Variable den Wert so lange bis ihr ein neuer Wert (mithilfe des Wertzuweisungsoperators) zugewiesen wird. Einer Variablen kann beliebig oft ein neuer Wert zugewiesen werden.","title":"Der Wertzuweisungsoperator ="},{"location":"variablen/#deklaration-und-initialisierung-in-einem-schritt","text":"Da wir m\u00f6chten, dass eine Variable sofort nach ihrer Deklaration einen Wert zugewiesen bekommt, ist es \u00fcblich, die Deklaration und die Initialisierung in einem Schritt, d.h. durch eine Anweisung durchzuf\u00fchren. Die Syntax der kombinierten Anweisung (Deklaration und INitialisierung) ist wie folgt: datentyp variablenName = wert ; Wir zeigen die Anwendung der kombinierten Deklaration und Initialisierung anhand der bereits verwendeten Beispiele: int ganzeZahl = 5 ; int number = - 1234 ; long bigNumber = 12345678 ; double nr1 = 6.54321 ; boolean condition = true ; char character = 'a' ; Beachte Wie bereits erw\u00e4hnt, kann eine Variable genau ein Mal deklariert, ihr aber beliebig oft ein neuer Wert zugewiesen werden. Angenommen, Sie wollen der Variablen ganzeZahl einen neuen Wert zuweisen, dann schreiben Sie die Anweisung ganzeZahl = 6; . Sie d\u00fcrfen auf keinen Fall int ganzeZahl = 6; schreiben, denn dann w\u00fcrden Sie ja versuchen, die Variable ganzeZahl erneut zu deklarieren. Diese existiert aber bereits. Sie bekommen einen Compilerfehler und k\u00f6nnen ihr Programm gar nicht erst \u00fcbersetzen.","title":"Deklaration und Initialisierung in einem Schritt"},{"location":"variablen/#details-zu-primitiven-datentypen-wertetypen","text":"Wie wir bereits bei der Vorstellung der primitiven Datentypen erw\u00e4hnt haben, ist f\u00fcr jeden Datentyp eine gewisse Speichergr\u00f6\u00dfe reserviert. Hier noch einmal die Gr\u00f6\u00dfe der primitiven Datentypen: Datentyp Gr\u00f6\u00dfe Wertebereich boolean 1 Byte 2 true / false char 16 bit 0 ... 65.535 (z.B. 'A' ) byte 8 bit -128 ... 127 short 16 bit -32.768 ... 32.767 int 32 bit -2.147.483.648 ... 2.147.483.647 long 64 bit -2^63 ... 2^63-1 float 32 bit +/-1,4E-45 ... +/-3,4E+38 double 64 bit +/-4,9E-324 ... +/-1,7E+308 Wir schauen uns jetzt noch einige interssante Details zu den Datentypen an.","title":"Details zu primitiven Datentypen (Wertetypen)"},{"location":"variablen/#ganzzahlige-datentypen-int-long-short-byte","text":"Eine ganze Zahl in einem Java-Programm ist vom Typ int . Dieser Datentyp ist der Standard-Datentyp f\u00fcr ganze Zahlen. Ganze Zahlen werden intern im sogenannten Zweierkomplement dargestellt. Wir schauen uns diese Darstellung am Beispiel des Datentyps byte (der 8 bit gro\u00df ist) einmal genauer an. In der folgenden Darstellung steht die Bedeutung der Position der einzelnen bits ganz oben, beginnend mit der 1 ( 2^0 ) auf der rechten Seite (\"kleinstes\" bit) bis hin zu 2^7 auf der linken Seite (\"gr\u00f6\u00dftest\" bit). Beim Zweierkomplement entspricht diese h\u00f6chste Position jedoch nicht der 128 , sondern der -128 . Dies hat drei Vorteile es wird nicht ein ganzes bit daf\u00fcr verwendet, um zu unterscheiden, ob es sich um eine positive oder negative Zahl handelt die 0 kommt nicht 2x vor ( 1000 0000 und 0000 0000 w\u00e4re jeweils 0 , wenn das f\u00fchrende bit dar\u00fcber entscheiden w\u00fcrde, ob die Zahl positiv oder negativ ist) sowohl die Addition als auch die Subtraktion geht einfacher Die Abbildung zeigt in den oberen drei Zeilen die interne Darstellung von -128 , 127 und 0 . In den drei Zeilen darunter ist dargestellt, wie z.B. die Zahlen 85 , -43 und -85 als Zweierkomplement repr\u00e4sentiert werden. Die folgende Abbildung zeigt die Addition (und somit auch die Subtraktion) zweier Zahlen im Zweierkomplement. Dargestellt sidn die Repr\u00e4sentationen von -4 und 3 als Zweierkomplement. Es wird die Addition der beiden Zahlen gezeigt. Da die Werte alle einen begrenzten Wertebereich haben, kann es zu einem Wertebereichs\u00fcberlauf kommen. Ein solcher \u00dcberlauf ist in der folgenden Abbildung dargestellt. Im Datentyp byte ist 127 die gr\u00f6\u00dfte positive Zahl. Die Abbildung verdeutlicht, was passiert, wenn zu dieser gr\u00f6\u00dften Zahl eine 1 hinzuaddiert wird. Beachten Sie, dass ein solcher \u00dcberlauf unbemerkt passiert. Das bedeutet, dass Sie weder einen Fehler noch eine Warnung erhalten. Sie m\u00fcssen sich also immer gut \u00fcberlegen, ob ein solcher \u00dcberlauf bei Ihren Werten passieren kann. Wenn ja, dann sollten Sie zum n\u00e4chstgr\u00f6\u00dferen Datentypen wechseln, also z.B. von int nach long . Datentyp gr\u00f6\u00dfter Wert kleinster Wert byte 127 -128 short 32.767 -32.768 int 2.147.483.647 -2.147.483.648 long 9.223.372.036.854.775.807 -9.223.372.036.854.775.808 \u00dcbung Zweierkomplement Warum ist 1111 1111 als Zweierkomplement im Datentyp byte die Dezimalzahl -1 ? Wie ist die Repr\u00e4sentation der Zahlen -99 und 99 als Zweierkomplement im Datentyp byte ? Was ist das Ergebnis der Rechnung 2.147.483.647 + 1 im Datentyp int und warum?","title":"Ganzzahlige Datentypen int, long, short, byte"},{"location":"variablen/#initialisierung-von-long-variablen","text":"Eine ganze Zahl als Literal , also als alleinstehender Wert ist vom Typ int . Wenn wir folgende kombinierte Deklaration und INitialisierung betrachten: long bigNumber = 12345678 ; dann stellen wir fest, dass die Variable bigNumber auf der linken Seite des Wertzuweisungsoperators vom Typ long ist, die Zahl 12345678 aber vom Typ int . Wir werden sp\u00e4ter noch auf solche Typkonvertierung zu sprechen kommen. Es sei hier jedoch bereits angemerkt, dass man eine ganze Zahl auch um das Postfix L erg\u00e4nzen kann 3 - mit der Wirkung, dass die Zahl dann nicht mehr vom Typ int , sondern vom Typ long ist. Die \"richtige\" Initialisierung sieht so aus: long bigNumber = 12345678L ; Es ist nur in wenigen F\u00e4llen wirklich erforderlich, das L an die Zahl zu h\u00e4ngen, wenn wir eine long -Variable initialisieren. Warum das so ist, werden wir kennenlernen, wenn wir uns \u00fcber * Typkonvertierung* Gedanken machen. Trotzdem sei hier schonmal erw\u00e4hnt, dass diese Deklaration und Initailisierung kein Problem ist long bigNumber = 2147483647 ; aber hier bekommen wir einen Fehler und k\u00f6nnen das Programm gar nicht \u00fcbersetzen: long bigNumber = 2147483648 ; Warum k\u00f6nnte das wohl so sein? Wenn wir es \"richtig\" machen, also mit angeh\u00e4ngtem L , dann ist auch wieder alles in Ordnung und das Programm l\u00e4sst sich compilieren: long bigNumber = 2147483648L ; In unseren Programmen werden wir zu 99% den Datentyp int f\u00fcr ganzzahlige Werte verwenden und zu 1% long . Die anderen ganzzahligen Datentypen byte und short braucht man eigentlich gar nicht mehr, da wir keinen Wert mehr darauf legen m\u00fcssen, Arbeitsspeicher zu sparen.","title":"Initialisierung von long-Variablen."},{"location":"variablen/#char","text":"Der Datentyp char ist f\u00fcr das Speichern von Zeichen vorgesehen. Es handelt sich um einen ganzzahligen Datentypen. Mit den ersten Computern stellte sich die Frage, wie Zeichen (also Ziffern und Buchstaben) intern codiert werden k\u00f6nnen. Es hat sich dann zun\u00e4chst die Zeichencodierung des American Standard Code for Information Interchange (ASCII) durchgesetzt, bei der 7 Bit (=128 Zeichen) dazu verwendet wurden, die wichtigsten Zeichen zu kodieren. Neben einigen Steuerzeichen (die ersten 33 \"Zeichen\", z.B. Zeilenvorschub, ESC -Zeichen) wurden z.B. folgende Zeichen wie folgt kodiert: Dezimalzahl Zeichen Dezimalzahl Zeichen Dezimalzahl Zeichen 33 ! 47 / 61 = 34 \"\" 48 0 62 > 35 # 49 1 63 ? 36 $ 50 2 64 @ 37 % 51 3 65 A 38 & 52 4 66 B 39 ' 53 5 67 C 40 ( 54 6 68 D 41 ) 55 7 69 E 42 * 56 8 70 F 43 + 57 9 71 G 44 , 58 : 72 H 45 - 59 ; 73 I 46 . 60 < 74 J Dezimalzahl Zeichen Dezimalzahl Zeichen Dezimalzahl Zeichen 75 K 89 Y 103 g 76 L 90 Z 104 h 77 M 91 [ 105 i 78 N 92 \\ 106 j 79 O 93 ] 107 k 80 P 94 ^ 108 l 81 Q 95 _ 109 m 82 R 96 ``` 110 n 83 S 97 a 111 o 84 T 98 b 112 p 85 U 99 c 113 q 86 V 100 d 114 r 87 W 101 e 115 s 88 X 102 f 116 t Dezimalzahl Zeichen Dezimalzahl Zeichen Dezimalzahl Zeichen 117 u 121 y 125 } 118 v 122 z 126 ~ 119 w 123 { 127 DEL 120 x 124 | Diese Zeichenkodierung erkl\u00e4rt, warum es sich bei char um einen ganzzahligen Typ handelt. Anstelle eines Zeichens, welches immer in einfachen Hochkommata '' angegeben werden muss, kann auch der ASCII-Code als Zahl verwendet werden. Folgende Beispiele zeigen dies: char ganzzahliger Typ char c1 = 'a' ; System . out . println ( c1 ); // a char c2 = 97 ; System . out . println ( c2 ); // a char c3 = '`' ; c3 ++ ; System . out . println ( c3 ); // a Die 128 verschiedenen Zeichen gen\u00fcgten nat\u00fcrlich schnell nicht mehr und es wurden deutlich gr\u00f6\u00dfere Kodierungstabellen entwickelt. Ein de-facto Standard ist UTF-8 , welcher Bytes (also 8 Bit) zur Kodierung der Zeichen verwendet. Die ersten 128 Zeichen sind dabei mit dem ASCII-Code identisch. Im UTF-8 k\u00f6nnen aber mehrere Bytes hintereinander geschrieben werden und erm\u00f6glichen so einen beliebig gro\u00dfen Kodierungsraum. Der Datentyp char ist 16 Bit gro\u00df, kann also 2 Byte gro\u00dfe Kodierungsr\u00e4ume darstellen (65 536 verschiedene Zeichen). Eine UTF-8-Tabelle finden Sie z.B. hier . Die linke Spalte in dieser Tabelle zeigt den Unicode . Dieser kann auch in Java (in leicht abgewandelter Form) verwendet werden. Scrollen Sie in der Tabelle ein wenig bis zur Position U+00A9 herunter. Dort sehen Sie z.B. die Codierung des \u00a9-Copyright-Zeichens. In Java kann dieser Code wie folgt verwendet werden: char UTF-8 Zeichen char u1 = '\\u00a9' ; System . out . println ( u1 ); // copyright-Zeichen char u2 = '\\u00b0' ; System . out . println ( u2 ); // Grad-Zeichen char u3 = '\\u00bd' ; System . out . println ( u3 ); // 1/2-Zeichen","title":"char"},{"location":"variablen/#gleitkomma-datentypen-double-float","text":"Eine Gleitkomma-Zahl (also eine Zahl mit einem Punkt, z.B. 5.0 oder -1.2345 ) in einem Java-Programm ist vom Typ double . Dieser Datentyp ist der Standard-Datentyp f\u00fcr Gleitkomma-Zahlen. Der Wertebereich der Datentypen double und float l\u00e4sst sich nicht so leicht angeben, denn entweder wird relativ viel \"Speicher\" f\u00fcr die Genauigkeit verwendet (f\u00fcr die Anzahl der Nachkommastellen, z.B. 0.123456789 ) oder f\u00fcr die Vorkommastellen (z.B. 987654321.0 ). Generell ist der Wertebereich (die Genauigkeit) bei double viel h\u00f6her, denn f\u00fcr eine Variable vom Typ double werden 64 bit reserviert, w\u00e4hrend eine Variable vom Typ float nur 32 bit gro\u00df ist. Bei float beschr\u00e4nkt sich die Genauigkeit auf ca. 7 signifikante Stellen (Nachkommastellen), w\u00e4hrend es bei double ca. 17 signifikante Stellen sind. Beispiel float float floatNumber = 1.0f / 3.0f ; System . out . println ( floatNumber ); // 0.33333334 Im obigen Beispiel wird mithilfe von float der Bruch 1/3 ausgerechnet. Zwei Sachen sind zu beachten Wie wir das schon beim Datentyp long gesehen haben, gibt es auch f\u00fcr Gleitkommazahlen ein Postfix, hier f , um zu sagen, dass eine Zahl vom Typ float sein soll. Ohne das f w\u00e4re sie vom Typ double und wir w\u00fcrden sogar einen Compilerfehler erhalten, wenn wir das f am Ende der Zahl nicht angeben w\u00fcrden. Hier ist es also wichtig, bei der Wertzuweisung anzugeben, dass die Zahl vom Typ float sein soll - n\u00e4mlcih durch die Angabe von f ( F ginge auch). Die Genauigkeit bei float ist nicht sehr hoch. 1/3 im float -Wertebereich ergibt 0.33333334 . Schauen wir uns das gleiche Beispiel mit double an: Beispiel float double doubleNumber = 1.0 / 3.0 ; System . out . println ( doubleNumber ); // 0.3333333333333333 Erstens hat der double -Wert deutlich mehr Nachkommastellen (16 statt 8 bei float ) und zweitens ist der Wert somit korrekter. Die Speicherung von Gleikommazahlen erfolgt nach IEEE 754 - Standard . Wir merken uns: wir sollten float eher nicht verwenden, wenn wir Wert auf Genauigkeit legen, wenn wir float verwenden, dann m\u00fcssen wir beim Initialisieren und bei allen Wertezuweisungen darauf achten, dass wir an die Gleikommazahl ein f anh\u00e4ngen, da es sich ansonsten um eine Gleitkommazahl vom Typ double handelt, double ist der Standardtyp f\u00fcr Gleikommazahlen und wenn eine Gleitkommazahl im Programmcode vorkommt, dann handelt es sich um eine Zahl vom Typ double . Datentyp gr\u00f6\u00dfter positiver Wert kleinster positiver Wert float ~3.4028234663852886E+038 ~1.4012984643248171E-045 double ~1.7976931348623157E+308 ~4.9406564584124654E-324","title":"Gleitkomma-Datentypen double, float"},{"location":"variablen/#der-datentyp-string","text":"Der Datentyp String ist kein primitiver Datentyp (kein Wertetyp), sondern ein sogenannter komplexer Datentyp (oder, wie wir sagen Referenztyp ). Wir erkennen das bereits daran, dass der Datentyp mit einem Gro\u00dfbuchstaben beginnt. Der Unterschied zwischen Variablen von einem Wertetypen und Variablen von Referenztypen ist der, dass die ersten \"nur\" Werte speichern ( 3 , 5 , 'a' , 123.45 , true , ...) und die anderen speichern Objekte (oder richtiger: Referenzen auf Objekte) - darum k\u00fcmmern wir uns sp\u00e4ter sehr ausf\u00fchrlich. Wir k\u00f6nnen uns merken (ist aber derzeit noch nicht wichtig), dass ein String ein Objekt und kein einfacher Wert ist, aber derzeit betrachten wir den Datentyp String wie die primitiven Wertetypen auch. Ein String -Literal erkennt man an den doppelten Anf\u00fchrungsstrichen. Darin kann ein beliebiger Text (bestehend aus allen m\u00f6glichen Zeichen, Buchstaben, Sonderzeichen, Umlauten etc.) stehen, z.B. \"Hallo FIW!\" , \"2und2gleich4 und $ % & 0? | \\ !\" , \" \u00e4 \u00fc \u00f6 \u00df . Die Deklaration und Initialisierung einer String -Variablen sieht also so aus: String s1 = \"Informatik\" ; Auch f\u00fcr den Datentyp String gibt es einen Operator, der zwei Strings miteinander verbindet. Er wird Konkatenation ( String-Konkatenation oder Zeichenkettenverbindungsoperator genannt). Das Operatorsymbol der Konkatenation ist in Java + . String s1 = \"Informatik\" + \" und\" + \" Wirtschaft\" ; System . out . println ( s1 ); Die folgenden drei Ausgaben sind alle gleich: String s1 = \"Informatik\" + \" und\" + \" Wirtschaft\" ; System . out . println ( s1 ); // Informatik und Wirtschaft String s2 = \"Informatik\" ; String s3 = \" und\" ; String s4 = \" Wirtschaft\" ; System . out . println ( s2 + s3 + s4 ); // Informatik und Wirtschaft String s5 = \"Informatik\" ; String s6 = s5 + \" und\" ; String s7 = s6 + \" Wirtschaft\" ; System . out . println ( s7 ); //Informatik und Wirtschaft","title":"Der Datentyp String"},{"location":"variablen/#doppelte-bedeutung-des-operatorzeichens","text":"Das + wird sowohl als arithmetischer Operator f\u00fcr numerische Datentypen als auch als Konkatenation f\u00fcr Strings verwendet. In den obigen Beispielen kommen wir damit nicht durcheinander, da v\u00f6llig klar ist, dass es sich dabei um die Konkatenation handelt. Es gibt aber Beispiele, bei denen in einem Ausdruck beide Bedeutungen vorkommen. Diese diskutieren wir jetzt. Zun\u00e4chst schauen wir uns noch eine Typische Verendung der Konkatenation an: typisches Beispiel f\u00fcr die Konkatenation 1 2 3 4 int summand1 = 3 ; int summand2 = 4 ; int summe = summand1 + summand2 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summe ); // 3 + 4 = 7 Die Ausgabe bei dem obigen Beispiel ist 3 + 4 = 7 . Schauen wir uns das Beispiel genauer an: In Zeile 3 wird das + eindeutig als arithmetischer Operator verwendet, denn es steht zwischen zwei numerischen Werten ( summand1 und summand2 sind jeweils vom Typ int ) In Zeile 4 kommt + mehrmals vor. Der Ausdruck in den runden Klammern von println() wird von links nach rechts aufgel\u00f6st: Das Literal \" + \" ist ein String. Hier ist + gar kein Operator, sondern nur ein Zeichen. Das + in summand1 + \" + \" ist die Konkatenation. Das liegt daran, dass einer der beiden Operanden, die das + verbindet, vom Typ String ist. Intern wird der Wert von summand1 ( die 3 ) zu einem String und dieser wird mit \" + \" verbunden. Es entsteht ein String \"3 + \" . Das bedeutet, dass das n\u00e4chste + in dem Ausdruck \"3 + \" + summand2 enthalten ist und auch hier die Bedeutung der Konkatenation hat, denn einer der beiden Operanden (der erste) ist vom Typ String . Intern wird der Wert von summand2 ( die 4 ) zu einem String und dieser wird mit \"3 + \" verbunden. Es entsteht ein String \"3 + 4\" . Das bedeutet, dass das n\u00e4chste + in dem Ausdruck \"3 + 4\" + \" = \" enthalten ist und auch hier die Bedeutung der Konkatenation hat, denn beide Operanden (der erste und der zweite) sind vom Typ String . Es entsteht der String \"3 + 4 = \" . Das letzte + steht also in dem Ausdruck \"3 + 4 = \" + summe . Auch hier handelt es sich wieder um die Konkatenation, da einer der beiden Operanden (der erste) vom Typ String ist. Intern wird der Wert von summe ( die 7 ) zu einem String und dieser wird mit \"3 + 4 = \" verbunden. Es entsteht ein String \"3 + 4 = 7\" . Dieser String wird ausgegegeben. 1. \u00dcbung Doppelte Bedeutung von + Angenommen, in dem obigen Beispiel wollen Sie die Summe der beiden Summanden nicht erst in einer Variablen zwischenspeichern, sondern gleich ausgeben. Sie schreiben deshalb folgendes Programm: int summand1 = 3 ; int summand2 = 4 ; System . out . println ( summand1 + \" + \" + summand2 + \" = \" + summand1 + summand2 ); Sie erhalten jedoch nicht die gew\u00fcnschte Ausgabe. Warum nicht? Wie k\u00f6nnen Sie doch die Summe ausgeben, ohne diese zwischenspeichern zu m\u00fcssen? Success Wir k\u00f6nnen nun Variablen deklarieren und initialisieren. Wir kennen alle acht primitiven Datentypen. Wir nennen diese Datentypen Wertetypen . Wir wissen, dass eine ganze Zahl im Java-Programm vom Typ int ist und eine Gleikommazahl vom Typ double . Wir kennen die interne Darstellung von ganzen Zahlen und wir wissen \u00fcber die Kodierung von Zeichen Bescheid. Der datentyp char ist ein ganzzahliger Typ, obwohl er f\u00fcr das Speichern von Zeichen zust\u00e4ndig ist. Dies liegt an der Kodierung der Zeichen als ganze Zahlen. Der Wertzuweisungsoperator ist = . Wenn einer Variablen ein Wert zugewiesen werden soll, dann muss die Variablen links stehen, der Wertuweisungsoperator in der Mitte und rechts der Wert.","title":"Doppelte Bedeutung des Operatorzeichens +"},{"location":"variablen/#konstanten","text":"Wir haben gesagt, dass Variablen beliebig oft einer neuer Wert zugewisen werden kann. Manchmal m\u00f6chte man aber genau das nicht. Sogenannten Konstanten m\u00f6chte man genau einmal einen Wert zuweisen und dann soll dieser Wert nicht mehr \u00fcberschrieben werden k\u00f6nnen. In Java kann man solche Konstanten mithilfe des Schl\u00fcsselwortes final deklarieren: final datentyp KONSTANTE = Wert; Eine Konstante wird zun\u00e4chst wie eine Variable deklariert, d.h. man vergibt einen Namen f\u00fcr die Variable und weist ihr einen Datentyp zu. Au\u00dferdem wird ihr mithilfe des Zuweisungsoperators ein Wert zugewiesen. Um zu verhindern, dass dieser Variablen erneut ein Wert zugewiesen kann, setzt man vor den Datentyp noch das Schl\u00fcsselwort final . Damit ist diese Variable schreibgesch\u00fctzt und es kann ihr nie wieder ein neuer Wert zugewiesen werden. Schauen wir uns ein Beispiel an: final double PI = 3.14159265359 ; Es wird eine Konstante PI deklariert und ihr der Wert 3.14159265359 zugewiesen. Damit wir Konstanten von \"normalen\" Variablen unterscheiden k\u00f6nnen, schreiben wir Konstenten immer gro\u00df . Wenn der Name einer Konstanten aus mehreren W\u00f6rtern besteht, verwendet man typischerweise den Unterstrich _ zum Verbinden der beiden W\u00f6rter, z.B. final int NOT_FOUND = - 1 ; final int MIN_VALUE = - 2147483648 ; final int MAX_VALUE = 2147483647 ; final char DEGREE_SYMBOL = '\\u00b0' ; final char DEGREE_CELSIUS = '\\u2103' ; final char DEGREE_FAHRENHEIT = '\\u2109' ; Ansonsten k\u00f6nnen Sie Konstanten ganz normal verwenden, aber immer nur lesend, also z.B. double area = PI * 25.0 ; System . out . println ( area ); System . out . println ( DEGREE_FAHRENHEIT ); System . out . println ( DEGREE_CELSIUS ); String fahrenheit = \"F\" + DEGREE_SYMBOL ; System . out . println ( fahrenheit ); ergibt folgende Ausgabe: 78 .53981633975 \u2109 \u2103 F\u00b0 Wenn Sie in Ihrem Programm versuchen, einer Konstanten einen neuen Wert zuzuweisen, erhalten Sie einen Fehler ( The final variable cannot be assigned ) und Sie k\u00f6nnen das Programm gar nicht erst compilieren. Wann immer Sie in Ihrem Programm ein Literal verwenden, also einen Wert, sollten Sie \u00fcberlegen, ob Sie diesem Wert nicht besser einen Namen geben k\u00f6nnen, n\u00e4mlich daf\u00fcr eine Konstante verwenden, und dann stets die Konstante anstelle des Wertes verwenden. Damit werden sogenannte magic numbers vermieden und das Programm ist lesbarer. const und goto geh\u00f6ren eigentlich gar nicht zum Sprachumfang von Java und sind aber trotzdem reservierte Schl\u00fcsselw\u00f6rter. \u21a9 Tats\u00e4chlich ist die Gr\u00f6\u00dfe eines boolean gar nicht genau definiert (siehe hier ). man braucht ja eigentlich nur ein bit. Man liest aber sehr h\u00e4ufig davon, dass einer Variablen vom Typ boolean ein ganzes Byte reserviert wird. \u21a9 Man k\u00f6nnte auch nit dem kleinen Buchstaben l erg\u00e4nzen, das macht man aber nicht, weil die Verwechselungsgefahr mit der 1 zu gro\u00df ist. \u21a9","title":"Konstanten"}]}